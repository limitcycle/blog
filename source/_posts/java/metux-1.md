---
title: '[Java] 互斥鎖'
date: 2022-09-24 19:24:01
tags: 
  - java 
  - Thread
categories: 學習
toc: true
---

在上篇文章，我們講解了Java如何避免可見性、有序性問題。

那**原子性問題**要怎麼解決？

我們已經知道造成可見性問題是**Thread切換**，如果能禁用Thread切換就能解決這個問題了

> **同一個時刻只有一個Thread執行**，我們稱為互斥。

如果我們能保證對共享變數的修改是互斥的，那麼就能保證原子性了。

## 簡易鎖模式

簡易鎖的圖示如下:


我們會把需要互斥執行的程式稱為**臨界區**，Thread在進入臨界區之前，首先會嘗試加鎖lock()，如果成功，則進入臨界區。否則就等待，直到持有鎖的Thread解鎖。持有鎖的Thread執行完臨界區的程式後，就會解鎖unlock()。

以上的解釋沒什麼問題，但是會讓我們忽略兩個非常重要的點: 我們鎖的是什麼?又是在保護什麼?

## 改善後的鎖模型

我們知道在現實世界裡，鎖和要保護的資源是有對應關係的，比如你家的鎖保護你家的東西，我用我家的鎖保護我家的東西。在併發程式裡，也有這樣的關係


在這我們把臨界區要保護的資源標記出來: 受保護的資源R。接著，我們為這個要保護的資源R創建一把鎖: LR。最後，在LR進出臨界區時加上加鎖和解鎖操作。

此外，我們在鎖LR和受保護的資源R之間，特地用一條線關聯起來。很多併發bug的出現都是把這個關聯忽略，產生了類似鎖自家門來保護他家資產的事，這樣的bug不好診斷，因為我們淺意識裡，認為我們已正確加鎖。

## synchronized

Java提供的synchronized關鍵字，就是鎖的一種實現。

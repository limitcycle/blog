{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/icarus/source/css/cyberpunk.styl","path":"css/cyberpunk.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/default.styl","path":"css/default.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/favicon.svg","path":"img/favicon.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/logo.svg","path":"img/logo.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/og_image.png","path":"img/og_image.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","path":"img/razor-bottom-black.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/razor-top-black.svg","path":"img/razor-top-black.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/animation.js","path":"js/animation.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/back_to_top.js","path":"js/back_to_top.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/column.js","path":"js/column.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/01-authorication-arch.png","path":"images/spring/keycloak-authorization-services/01-authorication-arch.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/03-Permission-and-Policy-Management.png","path":"images/spring/keycloak-authorization-services/03-Permission-and-Policy-Management.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/04-Policy-Enforcement.png","path":"images/spring/keycloak-authorization-services/04-Policy-Enforcement.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/05-add-realm.png","path":"images/spring/keycloak-authorization-services/05-add-realm.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/06-create-user.png","path":"images/spring/keycloak-authorization-services/06-create-user.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/07-create-role-bank-teller.png","path":"images/spring/keycloak-authorization-services/07-create-role-bank-teller.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/02-Resource-Management.png","path":"images/spring/keycloak-authorization-services/02-Resource-Management.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/08-create-role-account-owner.png","path":"images/spring/keycloak-authorization-services/08-create-role-account-owner.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/09-create-role-user.png","path":"images/spring/keycloak-authorization-services/09-create-role-user.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/10-create-client.png","path":"images/spring/keycloak-authorization-services/10-create-client.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/12-client-authorization-setting.png","path":"images/spring/keycloak-authorization-services/12-client-authorization-setting.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/13-create-scope.png","path":"images/spring/keycloak-authorization-services/13-create-scope.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/14-create-resource.png","path":"images/spring/keycloak-authorization-services/14-create-resource.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/15-create-role-based-policy-1.png","path":"images/spring/keycloak-authorization-services/15-create-role-based-policy-1.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/16-create-role-based-policy-1.png","path":"images/spring/keycloak-authorization-services/16-create-role-based-policy-1.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/11-setting-client.png","path":"images/spring/keycloak-authorization-services/11-setting-client.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/17-create-resource-base-permission.png","path":"images/spring/keycloak-authorization-services/17-create-resource-base-permission.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/18-Evaluating-the-Resource-Based-permission.png","path":"images/spring/keycloak-authorization-services/18-Evaluating-the-Resource-Based-permission.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/19-Evaluating-the-Resource-Based-permission-2.png","path":"images/spring/keycloak-authorization-services/19-Evaluating-the-Resource-Based-permission-2.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/21-Evaluating-the-Resource-Based-permission-result-2.png","path":"images/spring/keycloak-authorization-services/21-Evaluating-the-Resource-Based-permission-result-2.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/22-create-scope-based.png","path":"images/spring/keycloak-authorization-services/22-create-scope-based.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/23-Evaluatioin-new-change-1.png","path":"images/spring/keycloak-authorization-services/23-Evaluatioin-new-change-1.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/24-Evaluation-new-change-result-1.png","path":"images/spring/keycloak-authorization-services/24-Evaluation-new-change-result-1.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/20-Evaluating-the-Resource-Based-permission-result-1.png","path":"images/spring/keycloak-authorization-services/20-Evaluating-the-Resource-Based-permission-result-1.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/25-Evaluation-new-changet-2.png","path":"images/spring/keycloak-authorization-services/25-Evaluation-new-changet-2.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/26-Evaluation-new-change-result-2.png","path":"images/spring/keycloak-authorization-services/26-Evaluation-new-change-result-2.png","modified":0,"renderable":0},{"_id":"source/images/spring/keycloak-authorization-services/27-Evaluation-new-change-result-3.png","path":"images/spring/keycloak-authorization-services/27-Evaluation-new-change-result-3.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/02-init-admin-account.png","path":"images/spring/spring-boot-with-keycloak/02-init-admin-account.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/01-keycloack-features.png","path":"images/spring/spring-boot-with-keycloak/01-keycloack-features.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/03-admin-login.png","path":"images/spring/spring-boot-with-keycloak/03-admin-login.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/04-master-realm-detail.png","path":"images/spring/spring-boot-with-keycloak/04-master-realm-detail.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/05-master-realm-manage-other-realm.png","path":"images/spring/spring-boot-with-keycloak/05-master-realm-manage-other-realm.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/06-create-realm-in-menu.png","path":"images/spring/spring-boot-with-keycloak/06-create-realm-in-menu.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/07-create-realm.png","path":"images/spring/spring-boot-with-keycloak/07-create-realm.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/08-realm-detail.png","path":"images/spring/spring-boot-with-keycloak/08-realm-detail.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/09-role-page.png","path":"images/spring/spring-boot-with-keycloak/09-role-page.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/10-create-spring-user-role.png","path":"images/spring/spring-boot-with-keycloak/10-create-spring-user-role.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/11-user-page.png","path":"images/spring/spring-boot-with-keycloak/11-user-page.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/12-create-user.png","path":"images/spring/spring-boot-with-keycloak/12-create-user.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/13-user-set-password.png","path":"images/spring/spring-boot-with-keycloak/13-user-set-password.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/14-user-mapping-role.png","path":"images/spring/spring-boot-with-keycloak/14-user-mapping-role.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/15-client-page.png","path":"images/spring/spring-boot-with-keycloak/15-client-page.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/16-create-client.png","path":"images/spring/spring-boot-with-keycloak/16-create-client.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/17-client-detail-settings.png","path":"images/spring/spring-boot-with-keycloak/17-client-detail-settings.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/18-clientsecret.png","path":"images/spring/spring-boot-with-keycloak/18-clientsecret.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/19-accesstoken-request.png","path":"images/spring/spring-boot-with-keycloak/19-accesstoken-request.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/20-accesstoken-response.png","path":"images/spring/spring-boot-with-keycloak/20-accesstoken-response.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/21-keycloak-sessions.png","path":"images/spring/spring-boot-with-keycloak/21-keycloak-sessions.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/22-keycloak-usersessions.png","path":"images/spring/spring-boot-with-keycloak/22-keycloak-usersessions.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/23-Spring-Boot-Starter-Web.png","path":"images/spring/spring-boot-with-keycloak/23-Spring-Boot-Starter-Web.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/24-keycloak-steven'stoken.png","path":"images/spring/spring-boot-with-keycloak/24-keycloak-steven'stoken.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/25-keycloak-accesstokeninbearertoken.png","path":"images/spring/spring-boot-with-keycloak/25-keycloak-accesstokeninbearertoken.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/26-keycloak-Hello-user.png","path":"images/spring/spring-boot-with-keycloak/26-keycloak-Hello-user.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/27-keycloak-console.png","path":"images/spring/spring-boot-with-keycloak/27-keycloak-console.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/28-keycloak-role-springadmin.png","path":"images/spring/spring-boot-with-keycloak/28-keycloak-role-springadmin.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/29-keycloak-userdave.png","path":"images/spring/spring-boot-with-keycloak/29-keycloak-userdave.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/30-keycloak-daverolemapping.png","path":"images/spring/spring-boot-with-keycloak/30-keycloak-daverolemapping.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/31-keycloak-steve-nnoadmin.png","path":"images/spring/spring-boot-with-keycloak/31-keycloak-steve-nnoadmin.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/32-keycloak-davegetaccesstoen.png","path":"images/spring/spring-boot-with-keycloak/32-keycloak-davegetaccesstoen.png","modified":0,"renderable":0},{"_id":"source/images/spring/spring-boot-with-keycloak/33-keycloak-davecanaccessadminendpoint.png","path":"images/spring/spring-boot-with-keycloak/33-keycloak-davecanaccessadminendpoint.png","modified":0,"renderable":0},{"_id":"source/images/other/use-netlify-building-blog/01_netlify_official_website.png","path":"images/other/use-netlify-building-blog/01_netlify_official_website.png","modified":0,"renderable":0},{"_id":"source/images/other/use-netlify-building-blog/02_github_account_login_netlify.png","path":"images/other/use-netlify-building-blog/02_github_account_login_netlify.png","modified":0,"renderable":0},{"_id":"source/images/other/use-netlify-building-blog/netlify_logo_icon_169924.png","path":"images/other/use-netlify-building-blog/netlify_logo_icon_169924.png","modified":0,"renderable":0},{"_id":"source/images/other/use-netlify-building-blog/04-connect-github.png","path":"images/other/use-netlify-building-blog/04-connect-github.png","modified":0,"renderable":0},{"_id":"source/images/other/use-netlify-building-blog/05-pick-a-repo.png","path":"images/other/use-netlify-building-blog/05-pick-a-repo.png","modified":0,"renderable":0},{"_id":"source/images/other/use-netlify-building-blog/06-Basic-build-settings.png","path":"images/other/use-netlify-building-blog/06-Basic-build-settings.png","modified":0,"renderable":0},{"_id":"source/images/other/use-netlify-building-blog/07-deploy-complete.png","path":"images/other/use-netlify-building-blog/07-deploy-complete.png","modified":0,"renderable":0},{"_id":"source/images/other/use-netlify-building-blog/08-gandi-official-website.png","path":"images/other/use-netlify-building-blog/08-gandi-official-website.png","modified":0,"renderable":0},{"_id":"source/images/other/use-netlify-building-blog/09-buy-domain.png","path":"images/other/use-netlify-building-blog/09-buy-domain.png","modified":0,"renderable":0},{"_id":"source/images/other/use-netlify-building-blog/10-gandi-admin-console.png","path":"images/other/use-netlify-building-blog/10-gandi-admin-console.png","modified":0,"renderable":0},{"_id":"source/images/other/use-netlify-building-blog/11-domain-advance-settings.png","path":"images/other/use-netlify-building-blog/11-domain-advance-settings.png","modified":0,"renderable":0},{"_id":"source/images/other/use-netlify-building-blog/12-custom-domain.png","path":"images/other/use-netlify-building-blog/12-custom-domain.png","modified":0,"renderable":0},{"_id":"source/images/other/use-netlify-building-blog/13-add-custom-domain.png","path":"images/other/use-netlify-building-blog/13-add-custom-domain.png","modified":0,"renderable":0},{"_id":"source/images/other/use-netlify-building-blog/14-verify-domain.png","path":"images/other/use-netlify-building-blog/14-verify-domain.png","modified":0,"renderable":0},{"_id":"source/images/other/use-netlify-building-blog/15-netlify-dns-name-servers.png","path":"images/other/use-netlify-building-blog/15-netlify-dns-name-servers.png","modified":0,"renderable":0},{"_id":"source/images/other/use-netlify-building-blog/16-enter-name-servers.png","path":"images/other/use-netlify-building-blog/16-enter-name-servers.png","modified":0,"renderable":0},{"_id":"source/images/other/use-netlify-building-blog/17-settings-gandi-outside-name-server.png","path":"images/other/use-netlify-building-blog/17-settings-gandi-outside-name-server.png","modified":0,"renderable":0},{"_id":"source/images/other/use-netlify-building-blog/18-ssl-tls.png","path":"images/other/use-netlify-building-blog/18-ssl-tls.png","modified":0,"renderable":0},{"_id":"source/images/other/use-netlify-building-blog/19-finish-custom-domain.png","path":"images/other/use-netlify-building-blog/19-finish-custom-domain.png","modified":0,"renderable":0},{"_id":"source/images/other/use-netlify-building-blog/03_add_new_site.png","path":"images/other/use-netlify-building-blog/03_add_new_site.png","modified":0,"renderable":0},{"_id":"source/images/golang/grpc-icon-color.png","path":"images/golang/grpc-icon-color.png","modified":0,"renderable":0},{"_id":"source/images/golang/error/unwrap.png","path":"images/golang/error/unwrap.png","modified":0,"renderable":0},{"_id":"source/images/golang/error/wrap.png","path":"images/golang/error/wrap.png","modified":0,"renderable":0},{"_id":"source/images/golang/error/error-cover.jpeg","path":"images/golang/error/error-cover.jpeg","modified":0,"renderable":0},{"_id":"source/images/golang/goroutine.jpeg","path":"images/golang/goroutine.jpeg","modified":0,"renderable":0},{"_id":"source/images/golang/memory-model/single-goroutine.png","path":"images/golang/memory-model/single-goroutine.png","modified":0,"renderable":0},{"_id":"source/images/golang/memory-model/multi-goroutine.png","path":"images/golang/memory-model/multi-goroutine.png","modified":0,"renderable":0},{"_id":"source/images/golang/memory-model/sync.png","path":"images/golang/memory-model/sync.png","modified":0,"renderable":0},{"_id":"source/images/golang/memory-model/cpu-store-buffer.png","path":"images/golang/memory-model/cpu-store-buffer.png","modified":0,"renderable":0},{"_id":"source/images/java/concurrentcy/visibility-atomic-ordering/cpu-cache.png","path":"images/java/concurrentcy/visibility-atomic-ordering/cpu-cache.png","modified":0,"renderable":0},{"_id":"source/images/java/concurrentcy/visibility-atomic-ordering/order-problem.jpg","path":"images/java/concurrentcy/visibility-atomic-ordering/order-problem.jpg","modified":0,"renderable":0},{"_id":"source/images/java/concurrentcy/visibility-atomic-ordering/thread-switch.jpg","path":"images/java/concurrentcy/visibility-atomic-ordering/thread-switch.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"themes/icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639552552996},{"_id":"themes/icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639552552998},{"_id":"themes/icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639552552998},{"_id":"themes/icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639552552999},{"_id":"themes/icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639552552999},{"_id":"themes/icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639552552989},{"_id":"themes/icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639552552991},{"_id":"themes/icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639552552991},{"_id":"themes/icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639552552991},{"_id":"themes/icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639552552991},{"_id":"source/images/avatar.jpg","hash":"199db0477e358a122395a356428a9fed2930e49d","modified":1639561280176},{"_id":"source/images/favicon.ico","hash":"e1afe508699a6342ff66c31d01c8470571d7f7ee","modified":1639561198916},{"_id":"source/_posts/spring/keycloak-authorization-services.md","hash":"417903e46ed34fb325702a18d61569c1f776a063","modified":1645425300104},{"_id":"source/_posts/spring/spring-boot-with-keycloak.md","hash":"031a13e58a6cb4bc715610391f883ca82159ceef","modified":1645425300104},{"_id":"source/images/spring/keycloak-authorization-services/01-authorication-arch.png","hash":"c5fdd9b866a33a006e8c2b2d35e4aef26b52094c","modified":1639554344753},{"_id":"source/images/spring/keycloak-authorization-services/03-Permission-and-Policy-Management.png","hash":"068de29ee88c17434607a235bd611ba0af24a929","modified":1639554344759},{"_id":"source/images/spring/keycloak-authorization-services/04-Policy-Enforcement.png","hash":"1ef68257527a1b24036b789591ddcdf916422ce6","modified":1639554344762},{"_id":"source/images/spring/keycloak-authorization-services/05-add-realm.png","hash":"0dbd298c7c20c0edc2030515a1248ddac17f6114","modified":1639554344765},{"_id":"source/images/spring/keycloak-authorization-services/06-create-user.png","hash":"ea3053eed893bc77b17bda53ca8b0f1ce04211b9","modified":1639554344768},{"_id":"source/images/spring/keycloak-authorization-services/07-create-role-bank-teller.png","hash":"30968fb7a300b19d60a650824008cfceddb6e2b3","modified":1639554344770},{"_id":"source/images/spring/keycloak-authorization-services/02-Resource-Management.png","hash":"d91125b36a23d2acdd0ff7688625bf965cacdb35","modified":1639554344756},{"_id":"source/images/spring/keycloak-authorization-services/08-create-role-account-owner.png","hash":"b374c14fce4cd9ed515714214138fccc1934b774","modified":1639554344771},{"_id":"source/images/spring/keycloak-authorization-services/09-create-role-user.png","hash":"141b78e52ca5f2e1f8d5881b927622488c730820","modified":1639554344773},{"_id":"source/images/spring/keycloak-authorization-services/10-create-client.png","hash":"636901e58b6a2356de2b8e57cffef8d89a43282d","modified":1639554344774},{"_id":"source/images/spring/keycloak-authorization-services/12-client-authorization-setting.png","hash":"4b227aab737c051b38a31f67ad117970491abd47","modified":1639554344777},{"_id":"source/images/spring/keycloak-authorization-services/13-create-scope.png","hash":"669ab7374cb838afa552df75d853fb0612df78ad","modified":1639554344778},{"_id":"source/images/spring/keycloak-authorization-services/14-create-resource.png","hash":"f13854deec215dead58dfab0051a9085bf1efe82","modified":1639554344780},{"_id":"source/images/spring/keycloak-authorization-services/15-create-role-based-policy-1.png","hash":"f7411d9f1ae5ddc99f4593f3ee662d4b22a1929b","modified":1639554344781},{"_id":"source/images/spring/keycloak-authorization-services/16-create-role-based-policy-1.png","hash":"e0bfaef68943d58149899216c0b2d837f572c090","modified":1639554344782},{"_id":"source/images/spring/keycloak-authorization-services/11-setting-client.png","hash":"05935721b76232655cf7dccac2713a0f4fd51697","modified":1639554344776},{"_id":"source/images/spring/keycloak-authorization-services/17-create-resource-base-permission.png","hash":"fd48d49999ca5f6c923c5f1e57f5a167a0887d4b","modified":1639554344783},{"_id":"source/images/spring/keycloak-authorization-services/19-Evaluating-the-Resource-Based-permission-2.png","hash":"8bed2aa5b4bd07f4c9a601fa933b6eca444c73be","modified":1639554344785},{"_id":"source/images/spring/keycloak-authorization-services/18-Evaluating-the-Resource-Based-permission.png","hash":"b9590da71bd97de0756404f265b36b8168b4b329","modified":1639554344784},{"_id":"source/images/spring/keycloak-authorization-services/21-Evaluating-the-Resource-Based-permission-result-2.png","hash":"193dbc8f8f96faaee50e3103d074393e380943bc","modified":1639554344787},{"_id":"source/images/spring/keycloak-authorization-services/22-create-scope-based.png","hash":"be85d22d9c2d60eb4b92c0e6220f10507d199cfa","modified":1639554344788},{"_id":"source/images/spring/keycloak-authorization-services/23-Evaluatioin-new-change-1.png","hash":"20c4e9640910d17e072863efa708e806214ac833","modified":1639554344789},{"_id":"source/images/spring/keycloak-authorization-services/24-Evaluation-new-change-result-1.png","hash":"435d404644545c109358a25c50d58ca50e1b6313","modified":1639554344789},{"_id":"source/images/spring/keycloak-authorization-services/20-Evaluating-the-Resource-Based-permission-result-1.png","hash":"7efef4a73460f8b1f0d41f47ebf98291aeda5909","modified":1639554344786},{"_id":"source/images/spring/keycloak-authorization-services/25-Evaluation-new-changet-2.png","hash":"87907a05f037c9fd9cf98397ef2aea65f391ac55","modified":1639554344790},{"_id":"source/images/spring/keycloak-authorization-services/26-Evaluation-new-change-result-2.png","hash":"b6ee023d063d5c7818653bb192de8a7172c879c6","modified":1639554344791},{"_id":"source/images/spring/spring-boot-with-keycloak/02-init-admin-account.png","hash":"2f84e63e412d921455e7d4f08ffade84773525f9","modified":1639554344793},{"_id":"source/images/spring/keycloak-authorization-services/27-Evaluation-new-change-result-3.png","hash":"1e695fa8fde03c31bad77976f84ee0a6d38008b0","modified":1639554344791},{"_id":"source/images/spring/spring-boot-with-keycloak/03-admin-login.png","hash":"861c30b5c58cc907bd917b7bcf9ab91fac9d69a5","modified":1639554344794},{"_id":"source/images/spring/spring-boot-with-keycloak/01-keycloack-features.png","hash":"c87c809086941b4ba08d9764ad4d44f790c4ae9e","modified":1639554344793},{"_id":"source/images/spring/spring-boot-with-keycloak/04-master-realm-detail.png","hash":"d746b9219ed7394fca6bbc9e3609efcc8df333f0","modified":1639554344794},{"_id":"source/images/spring/spring-boot-with-keycloak/06-create-realm-in-menu.png","hash":"3fc9c97a19170496de0b162edf0b17ff0e04fc54","modified":1639554344796},{"_id":"source/images/spring/spring-boot-with-keycloak/07-create-realm.png","hash":"f0137f90da0a3540ca884a401d365f67f2e33854","modified":1639554344797},{"_id":"source/images/spring/spring-boot-with-keycloak/08-realm-detail.png","hash":"51a5ee14dddb331e30626d4e261c322310d94dfe","modified":1639554344797},{"_id":"source/images/spring/spring-boot-with-keycloak/05-master-realm-manage-other-realm.png","hash":"d23ef84ac6a73f50d781d3266bd59e35b0b98d8a","modified":1639554344795},{"_id":"source/images/spring/spring-boot-with-keycloak/09-role-page.png","hash":"d9c1b8a9535709ef8427f58fc7b05a2402643eaf","modified":1639554344798},{"_id":"source/images/spring/spring-boot-with-keycloak/10-create-spring-user-role.png","hash":"91082274a2a4174459471c5854d95af3708b2904","modified":1639554344798},{"_id":"source/images/spring/spring-boot-with-keycloak/11-user-page.png","hash":"935740950bb6f102c0e1cb372e9ebfa503e6eff4","modified":1639554344799},{"_id":"source/images/spring/spring-boot-with-keycloak/12-create-user.png","hash":"eb0e6c865ad9ae024a88ac75fb8e6f77050fb00a","modified":1639554344799},{"_id":"source/images/spring/spring-boot-with-keycloak/16-create-client.png","hash":"059b0a00d69776d7bce2a43cce6db3ea9fde1b9f","modified":1639554344801},{"_id":"source/images/spring/spring-boot-with-keycloak/13-user-set-password.png","hash":"f10c965a937c7723786f4391c617cd316b1cd6a6","modified":1639554344800},{"_id":"source/images/spring/spring-boot-with-keycloak/14-user-mapping-role.png","hash":"eb3329f4373459889d73d993c9b31064e87c86c9","modified":1639554344800},{"_id":"source/images/spring/spring-boot-with-keycloak/15-client-page.png","hash":"979ff455bf4b1939296e86e0b6be0154adacec06","modified":1639554344801},{"_id":"source/images/spring/spring-boot-with-keycloak/17-client-detail-settings.png","hash":"42dcb30c6a52ad931268ee9ae8a041d0286d1b48","modified":1639554344802},{"_id":"source/images/spring/spring-boot-with-keycloak/18-clientsecret.png","hash":"36230895215a22f807dc04f854f74327bd36353a","modified":1639554344802},{"_id":"source/images/spring/spring-boot-with-keycloak/21-keycloak-sessions.png","hash":"98961edc7c9c58eac155c314b22b79e2005af607","modified":1639554344804},{"_id":"source/images/spring/spring-boot-with-keycloak/22-keycloak-usersessions.png","hash":"b751fe4a9d1a2990f02de4d0dc4ce2c554231adb","modified":1639554344804},{"_id":"source/images/spring/spring-boot-with-keycloak/19-accesstoken-request.png","hash":"75a08ced44a1b04719a4e4634d9301182f964639","modified":1639554344802},{"_id":"source/images/spring/spring-boot-with-keycloak/23-Spring-Boot-Starter-Web.png","hash":"b2160057b6b9b2b2e6a3fc5bd7cc261278700e92","modified":1639554344805},{"_id":"source/images/spring/spring-boot-with-keycloak/26-keycloak-Hello-user.png","hash":"4e0e44b013dc8f3882c955248e28eaeff8a0e3ff","modified":1639554344807},{"_id":"source/images/spring/spring-boot-with-keycloak/28-keycloak-role-springadmin.png","hash":"333b88ed2adc6dbf819ff5ca16cc5cecba8875e0","modified":1639554344808},{"_id":"source/images/spring/spring-boot-with-keycloak/29-keycloak-userdave.png","hash":"0f3889b9615ec1c17a1cbafdc8c3d8cf24d9ea9b","modified":1639554344809},{"_id":"source/images/spring/spring-boot-with-keycloak/25-keycloak-accesstokeninbearertoken.png","hash":"2cb9082d964b89b1251e37823955b31243fa0f21","modified":1639554344807},{"_id":"source/images/spring/spring-boot-with-keycloak/30-keycloak-daverolemapping.png","hash":"74dbae4fbb906c9bcfad23b97d4aa85975931a33","modified":1639554344809},{"_id":"source/images/spring/spring-boot-with-keycloak/27-keycloak-console.png","hash":"a30aca4f7071dd50bad842173eafaeb75db312d5","modified":1639554344808},{"_id":"source/images/spring/spring-boot-with-keycloak/31-keycloak-steve-nnoadmin.png","hash":"9d3e05b550f2de53d254d1dc22295d24b0424224","modified":1639554344810},{"_id":"source/images/spring/spring-boot-with-keycloak/33-keycloak-davecanaccessadminendpoint.png","hash":"a33d99991da2cb77e57e675ef73ed929f2aecd33","modified":1639554344812},{"_id":"themes/icarus/.eslintrc.json","hash":"43c7740158c8690242720b4ff7fa11426fc20c79","modified":1639552552986},{"_id":"themes/icarus/.eslintignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1639552552986},{"_id":"themes/icarus/.gitignore","hash":"36084c0851a22bfd393933abb8e262562ffc6802","modified":1639552552988},{"_id":"themes/icarus/.npmignore","hash":"42242c8da7a020a3295e7dd3d18bf022cb08b661","modified":1639552552988},{"_id":"themes/icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":1639552552988},{"_id":"themes/icarus/package.json","hash":"eeefa2a465ff37e08499efb1d4f1c72517e5d103","modified":1640163615092},{"_id":"themes/icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":1639552552988},{"_id":"themes/icarus/.github/dependabot.yml","hash":"d532d0db30e42211f35823b9885f3ed1b2d51777","modified":1639552552987},{"_id":"themes/icarus/include/config.js","hash":"1ff0f174e9670074ad2bee890d5b6da486800c9a","modified":1639552552988},{"_id":"themes/icarus/README.md","hash":"32f9f4fc8cd7ec60b30544bd2e558b593519ae5d","modified":1639552552988},{"_id":"themes/icarus/include/dependency.js","hash":"d30dbcefd58619f6705d6369b644bc7ba44d2421","modified":1639552552988},{"_id":"themes/icarus/include/register.js","hash":"a974b56a1fbb254f1ae048cc2221363faaccec25","modified":1639552552989},{"_id":"themes/icarus/languages/de.yml","hash":"78421f09961ca0b24756a0688fb2cb2e2696e25f","modified":1639552552994},{"_id":"themes/icarus/languages/en.yml","hash":"3d674204d9f723c829226da745afddd180c1131d","modified":1639552552994},{"_id":"themes/icarus/.github/stale.yml","hash":"88c73f6216c5666d2f60b1e8fe690a3f6e561e42","modified":1639552552987},{"_id":"themes/icarus/languages/es.yml","hash":"38579b8fad4b6997362acc770615bcd85ff20f68","modified":1639552552994},{"_id":"themes/icarus/languages/fr.yml","hash":"06d5c819d6108a42b28cff7b52e5410d0bed55d1","modified":1639552552994},{"_id":"themes/icarus/languages/ja.yml","hash":"801d9930fef48d6a3f80470d5bed4f3eb78147e6","modified":1639552552994},{"_id":"themes/icarus/languages/id.yml","hash":"5e48b1d62378cadeb64b88349477726a5c1bae47","modified":1639552552994},{"_id":"themes/icarus/languages/ko.yml","hash":"e3374265377809c1518114cf352b595840c0b416","modified":1639552552994},{"_id":"themes/icarus/languages/pl.yml","hash":"2e7debb44cd91096f30efc87bf8d6b1d0d0214c9","modified":1639552552994},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"ee8f73350e4c6e2f63b7fc72b34472a6b1e21244","modified":1639552552994},{"_id":"themes/icarus/languages/tk.yml","hash":"ca583168bd2025124a1cd0e977da475d7a7496fd","modified":1639552552995},{"_id":"themes/icarus/languages/ru.yml","hash":"9d91358c2acbe7a0f2a25daf7f65b999ff32d068","modified":1639552552995},{"_id":"themes/icarus/languages/vn.yml","hash":"5f2fffa642110c81d8f529949711c9d19ad6bbbe","modified":1639552552995},{"_id":"themes/icarus/languages/tr.yml","hash":"dd0a7bfe14848d6e1aa229198fe1db03e08e305e","modified":1639552552995},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"02475ba14afc70dfeaf5678467cee307835e4efa","modified":1639552552995},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"a6826e0c8cdb9ad286324b682b466a9e2ad78e6f","modified":1639552552995},{"_id":"themes/icarus/layout/archive.jsx","hash":"05677e93d4a43f417dbbf0d63ca37a99e6349e3b","modified":1639552552995},{"_id":"themes/icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":1639552552996},{"_id":"themes/icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":1639552552996},{"_id":"themes/icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":1639552552998},{"_id":"themes/icarus/layout/layout.jsx","hash":"ac7c4e3465a116c7f05f8c2e09ee6d6b9467abf1","modified":1639552552998},{"_id":"themes/icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1639552552998},{"_id":"themes/icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1639552552998},{"_id":"themes/icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":1639552552999},{"_id":"themes/icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":1639552552999},{"_id":"themes/icarus/scripts/index.js","hash":"0c666db6fcb4ffc4d300f4e108c00ee42b1cbbe6","modified":1639552552999},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/Bug反馈.md","hash":"d801be6937df21e63113be8840b2e23c465db87b","modified":1639552552986},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/bug_report.md","hash":"5d3abdc1a2a79ef9822865184eced6e31066d8f6","modified":1639552552987},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/config.yml","hash":"b49270a202d839c298e584b5d017f56140c7e7a0","modified":1639552552987},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/feature_request.md","hash":"05313e241a3d43fdadb0f74390b562c07c25d4d0","modified":1639552552987},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/功能建议.md","hash":"c6f60f37e6cd0bc21a81b3b07f84e04e9e80fb57","modified":1639552552987},{"_id":"themes/icarus/.github/PULL_REQUEST_TEMPLATE/pull_request_template.md","hash":"e106fa240c24c8bfbdd623549651600c6d786c9c","modified":1639552552987},{"_id":"themes/icarus/.github/workflows/lint.yml","hash":"71f04b66e48f065285ba109939999876ef411598","modified":1639552552987},{"_id":"themes/icarus/.github/workflows/github-release.yml","hash":"48b6bd2cc567687a7b1648c55c8f9de9d44fa9e1","modified":1639552552987},{"_id":"themes/icarus/.github/workflows/npm-publish.yml","hash":"4eabc0c60cb7102fdd5e4b0fbd8c0ac4c17cc8d0","modified":1639552552987},{"_id":"themes/icarus/.github/workflows/test.yml","hash":"69046b3b5c3d12cdca26380b7458cebeb2546dae","modified":1639552552988},{"_id":"themes/icarus/include/migration/head.js","hash":"269ba172013cbd2f10b9bc51af0496628081329b","modified":1639552552989},{"_id":"themes/icarus/include/schema/config.json","hash":"ac633f9d349bca4f089d59d2c3738b57376f1b31","modified":1639552552991},{"_id":"themes/icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":1639552552989},{"_id":"themes/icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1639552552993},{"_id":"themes/icarus/include/migration/v2_v3.js","hash":"3ccb2d2ce11018bebd7172da66faecc3983bff00","modified":1639552552989},{"_id":"themes/icarus/include/style/article.styl","hash":"105c983871b6c9148d97a0f756886e56411572bd","modified":1639552552992},{"_id":"themes/icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":1639552552992},{"_id":"themes/icarus/include/style/codeblock.styl","hash":"30bee4cf6792e9665eb648cc20b352d9eaff1207","modified":1639552552992},{"_id":"themes/icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":1639552552992},{"_id":"themes/icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":1639552552992},{"_id":"themes/icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":1639552552992},{"_id":"themes/icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":1639552552992},{"_id":"themes/icarus/include/style/navbar.styl","hash":"ecc73c8ad504c0fa4bb910eb51500c14e0a8d662","modified":1639552552993},{"_id":"themes/icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":1639552552993},{"_id":"themes/icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":1639552552993},{"_id":"themes/icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":1639552552992},{"_id":"themes/icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":1639552552993},{"_id":"themes/icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":1639552552993},{"_id":"themes/icarus/include/style/plugin.styl","hash":"679b61b5fc5b3281735a21c37aeb64229d9c51ea","modified":1639552552993},{"_id":"themes/icarus/layout/common/article.jsx","hash":"e2765287c6bc6eb97975a1bb4e325b046e95b392","modified":1639552552996},{"_id":"themes/icarus/include/style/widget.styl","hash":"c746902251136544eb3fe523235b3183f4189460","modified":1639552552993},{"_id":"themes/icarus/layout/common/donates.jsx","hash":"889fb0a7ccc502f0a43b4a18eb330e351e50493c","modified":1639552552996},{"_id":"themes/icarus/layout/common/footer.jsx","hash":"baa8e40e036a3ec0114d96893b708435104b4ba9","modified":1639552552996},{"_id":"themes/icarus/layout/common/navbar.jsx","hash":"fcd9fd4624dee49207ef09ea2a1c63f524f3710c","modified":1639552552997},{"_id":"themes/icarus/layout/common/comment.jsx","hash":"427089c33002707b76e2f38709459a6824fd0f9b","modified":1639552552996},{"_id":"themes/icarus/layout/common/plugins.jsx","hash":"f6826c1a5f5f59f4a0aa00c63bdb0ad4ff4eab69","modified":1639552552997},{"_id":"themes/icarus/layout/common/scripts.jsx","hash":"0fe1fddab431fb9f63906d8c480d5cd6b33abc32","modified":1639552552997},{"_id":"themes/icarus/layout/common/head.jsx","hash":"2ec1f511f32e3a9c86d49f1338f57ae5ece18898","modified":1640163615091},{"_id":"themes/icarus/layout/common/share.jsx","hash":"c9fb0319ad5e5a10ad3636b26a6c2afed14c590f","modified":1639552552997},{"_id":"themes/icarus/layout/common/widgets.jsx","hash":"251263b97de12f2b8d1fce2514e83430f2515b94","modified":1639552552997},{"_id":"themes/icarus/layout/common/search.jsx","hash":"6f244a37293031670a2964fe424ecd062e591d7b","modified":1639552552997},{"_id":"themes/icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":1639552552998},{"_id":"themes/icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":1639552552998},{"_id":"themes/icarus/layout/widget/profile.jsx","hash":"0d3a7fd922c12cc45d2c8d26a8f4d3a9a6ed0ae0","modified":1639552552999},{"_id":"themes/icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":1639552553000},{"_id":"themes/icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":1639552553000},{"_id":"themes/icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":1639552553000},{"_id":"themes/icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1639552553000},{"_id":"themes/icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1639552553000},{"_id":"themes/icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1639552553000},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1639552553001},{"_id":"themes/icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1639552553001},{"_id":"themes/icarus/source/js/.eslintrc.json","hash":"6bf0641cb69dffac97f69baea192d7fa3ab612cb","modified":1639552553002},{"_id":"themes/icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1639552553001},{"_id":"themes/icarus/source/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1639552553002},{"_id":"themes/icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1639552553002},{"_id":"themes/icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1639552553002},{"_id":"themes/icarus/source/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1639552553002},{"_id":"themes/icarus/include/schema/common/article.json","hash":"e2502c39045c6a26ccd8e880858f93e78c7bda35","modified":1639552552989},{"_id":"themes/icarus/include/schema/common/comment.json","hash":"7d744391a8abee9a2c450b6fdd36a3866a488025","modified":1639552552989},{"_id":"themes/icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":1639552552989},{"_id":"themes/icarus/include/schema/common/footer.json","hash":"09d706cbb94d6da9a0d15c719ce7139325cae1c7","modified":1639552552990},{"_id":"themes/icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":1639552552990},{"_id":"themes/icarus/include/schema/common/navbar.json","hash":"6691e587284c4cf450e0288680d5ff0f3565f090","modified":1639552552990},{"_id":"themes/icarus/include/schema/common/plugins.json","hash":"6036a805749816416850d944f7d64aaae62e5e75","modified":1639552552990},{"_id":"themes/icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":1639552552990},{"_id":"themes/icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":1639552552990},{"_id":"themes/icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":1639552552990},{"_id":"themes/icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":1639552552990},{"_id":"themes/icarus/include/schema/common/widgets.json","hash":"cadd9dc942740ecd5037d3943e72f8b6a8399bbe","modified":1639552552990},{"_id":"themes/icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":1639552552991},{"_id":"themes/icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":1639552552991},{"_id":"themes/icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":1639552552991},{"_id":"source/images/spring/spring-boot-with-keycloak/20-accesstoken-response.png","hash":"de03ce2a41fe49f8b0e2994f0c9da66d99eb4c93","modified":1639554344803},{"_id":"source/images/spring/spring-boot-with-keycloak/24-keycloak-steven'stoken.png","hash":"94ebf70c25e81b4f6c5a3699b8500a1a33aebeb9","modified":1639554344806},{"_id":"source/images/spring/spring-boot-with-keycloak/32-keycloak-davegetaccesstoen.png","hash":"310158334ae666330113a3fd4a0f0d2a8ecfb501","modified":1639554344811},{"_id":"public/js/algolia.js","hash":"a8df0c0abeeb4ee1d2d720161f3aea7339380704","modified":1639563177538},{"_id":"public/js/google_cse.js","hash":"1a9881669dfdeb2b3214074eee0d3e01e52db2c4","modified":1639563177538},{"_id":"public/js/insight.js","hash":"86bbdb7305d9bf19ad62d2ca2cf169fc8d9f9d31","modified":1639563177538},{"_id":"public/js/toc.js","hash":"da6fb757a1b083b8ed138bf29aad3a7bf8ec4f11","modified":1639563177538},{"_id":"public/content.json","hash":"4f7e7282bb8c05899994251089bf8d7a1b5daa42","modified":1640162977399},{"_id":"public/manifest.json","hash":"22a746208e1b5ff8c14fa4c3a0f27e1ff851126c","modified":1639563177538},{"_id":"public/archives/index.html","hash":"721903a610fe30c2ab00f531b293581a29ba3aef","modified":1640162977399},{"_id":"public/archives/2021/index.html","hash":"21d52b8aab053b2b5df62a9bb2c75d54fba7d416","modified":1640162977399},{"_id":"public/archives/2021/01/index.html","hash":"b19a7bf04fb26fb0591dede9193d5e04ed8a6e82","modified":1640162977399},{"_id":"public/index.html","hash":"5a34035b39b91aa6c59691e56caaf500a785c904","modified":1640162977399},{"_id":"public/tags/keycloak/index.html","hash":"9018b92cf7806a448b49deea40b5f8ec46252444","modified":1640162977399},{"_id":"public/tags/spring/index.html","hash":"a5b21ce1db768ea928fd3f133b1fc056ddc3f07f","modified":1640162977399},{"_id":"public/categories/index.html","hash":"3bf3f4bfcd68d2933b3c949beaab29d776bf1d45","modified":1640162977399},{"_id":"public/tags/index.html","hash":"39a553633390e9b64aad5f17a032a3f18baf6021","modified":1640162977399},{"_id":"public/2021/01/11/spring/keycloak-authorization-services/index.html","hash":"7dc4ee639fc0fe10ca3f7d281a268e4bbafa1657","modified":1640162977399},{"_id":"public/2021/01/09/spring/spring-boot-with-keycloak/index.html","hash":"9f3e7c29ed455cd6bcfb92aaadb06bd8a0c435fc","modified":1640162977399},{"_id":"public/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1639563177538},{"_id":"public/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1639563177538},{"_id":"public/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1639563177538},{"_id":"public/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1639563177538},{"_id":"public/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1639563177538},{"_id":"public/images/favicon.ico","hash":"e1afe508699a6342ff66c31d01c8470571d7f7ee","modified":1639563177538},{"_id":"public/images/avatar.jpg","hash":"199db0477e358a122395a356428a9fed2930e49d","modified":1639563177538},{"_id":"public/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/04-Policy-Enforcement.png","hash":"1ef68257527a1b24036b789591ddcdf916422ce6","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/05-add-realm.png","hash":"0dbd298c7c20c0edc2030515a1248ddac17f6114","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/03-Permission-and-Policy-Management.png","hash":"068de29ee88c17434607a235bd611ba0af24a929","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/06-create-user.png","hash":"ea3053eed893bc77b17bda53ca8b0f1ce04211b9","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/01-authorication-arch.png","hash":"c5fdd9b866a33a006e8c2b2d35e4aef26b52094c","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/09-create-role-user.png","hash":"141b78e52ca5f2e1f8d5881b927622488c730820","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/08-create-role-account-owner.png","hash":"b374c14fce4cd9ed515714214138fccc1934b774","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/02-Resource-Management.png","hash":"d91125b36a23d2acdd0ff7688625bf965cacdb35","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/15-create-role-based-policy-1.png","hash":"f7411d9f1ae5ddc99f4593f3ee662d4b22a1929b","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/10-create-client.png","hash":"636901e58b6a2356de2b8e57cffef8d89a43282d","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/14-create-resource.png","hash":"f13854deec215dead58dfab0051a9085bf1efe82","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/11-setting-client.png","hash":"05935721b76232655cf7dccac2713a0f4fd51697","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/16-create-role-based-policy-1.png","hash":"e0bfaef68943d58149899216c0b2d837f572c090","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/13-create-scope.png","hash":"669ab7374cb838afa552df75d853fb0612df78ad","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/18-Evaluating-the-Resource-Based-permission.png","hash":"b9590da71bd97de0756404f265b36b8168b4b329","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/12-client-authorization-setting.png","hash":"4b227aab737c051b38a31f67ad117970491abd47","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/19-Evaluating-the-Resource-Based-permission-2.png","hash":"8bed2aa5b4bd07f4c9a601fa933b6eca444c73be","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/22-create-scope-based.png","hash":"be85d22d9c2d60eb4b92c0e6220f10507d199cfa","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/17-create-resource-base-permission.png","hash":"fd48d49999ca5f6c923c5f1e57f5a167a0887d4b","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/23-Evaluatioin-new-change-1.png","hash":"20c4e9640910d17e072863efa708e806214ac833","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/07-create-role-bank-teller.png","hash":"30968fb7a300b19d60a650824008cfceddb6e2b3","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/26-Evaluation-new-change-result-2.png","hash":"b6ee023d063d5c7818653bb192de8a7172c879c6","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/21-Evaluating-the-Resource-Based-permission-result-2.png","hash":"193dbc8f8f96faaee50e3103d074393e380943bc","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/25-Evaluation-new-changet-2.png","hash":"87907a05f037c9fd9cf98397ef2aea65f391ac55","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/20-Evaluating-the-Resource-Based-permission-result-1.png","hash":"7efef4a73460f8b1f0d41f47ebf98291aeda5909","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/24-Evaluation-new-change-result-1.png","hash":"435d404644545c109358a25c50d58ca50e1b6313","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/03-admin-login.png","hash":"861c30b5c58cc907bd917b7bcf9ab91fac9d69a5","modified":1639563177538},{"_id":"public/images/spring/keycloak-authorization-services/27-Evaluation-new-change-result-3.png","hash":"1e695fa8fde03c31bad77976f84ee0a6d38008b0","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/01-keycloack-features.png","hash":"c87c809086941b4ba08d9764ad4d44f790c4ae9e","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/06-create-realm-in-menu.png","hash":"3fc9c97a19170496de0b162edf0b17ff0e04fc54","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/05-master-realm-manage-other-realm.png","hash":"d23ef84ac6a73f50d781d3266bd59e35b0b98d8a","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/07-create-realm.png","hash":"f0137f90da0a3540ca884a401d365f67f2e33854","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/04-master-realm-detail.png","hash":"d746b9219ed7394fca6bbc9e3609efcc8df333f0","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/02-init-admin-account.png","hash":"2f84e63e412d921455e7d4f08ffade84773525f9","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/08-realm-detail.png","hash":"51a5ee14dddb331e30626d4e261c322310d94dfe","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/09-role-page.png","hash":"d9c1b8a9535709ef8427f58fc7b05a2402643eaf","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/10-create-spring-user-role.png","hash":"91082274a2a4174459471c5854d95af3708b2904","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/12-create-user.png","hash":"eb0e6c865ad9ae024a88ac75fb8e6f77050fb00a","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/13-user-set-password.png","hash":"f10c965a937c7723786f4391c617cd316b1cd6a6","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/14-user-mapping-role.png","hash":"eb3329f4373459889d73d993c9b31064e87c86c9","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/11-user-page.png","hash":"935740950bb6f102c0e1cb372e9ebfa503e6eff4","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/17-client-detail-settings.png","hash":"42dcb30c6a52ad931268ee9ae8a041d0286d1b48","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/16-create-client.png","hash":"059b0a00d69776d7bce2a43cce6db3ea9fde1b9f","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/19-accesstoken-request.png","hash":"75a08ced44a1b04719a4e4634d9301182f964639","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/21-keycloak-sessions.png","hash":"98961edc7c9c58eac155c314b22b79e2005af607","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/18-clientsecret.png","hash":"36230895215a22f807dc04f854f74327bd36353a","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/23-Spring-Boot-Starter-Web.png","hash":"b2160057b6b9b2b2e6a3fc5bd7cc261278700e92","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/22-keycloak-usersessions.png","hash":"b751fe4a9d1a2990f02de4d0dc4ce2c554231adb","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/15-client-page.png","hash":"979ff455bf4b1939296e86e0b6be0154adacec06","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/26-keycloak-Hello-user.png","hash":"4e0e44b013dc8f3882c955248e28eaeff8a0e3ff","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/25-keycloak-accesstokeninbearertoken.png","hash":"2cb9082d964b89b1251e37823955b31243fa0f21","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/28-keycloak-role-springadmin.png","hash":"333b88ed2adc6dbf819ff5ca16cc5cecba8875e0","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/27-keycloak-console.png","hash":"a30aca4f7071dd50bad842173eafaeb75db312d5","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/29-keycloak-userdave.png","hash":"0f3889b9615ec1c17a1cbafdc8c3d8cf24d9ea9b","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/30-keycloak-daverolemapping.png","hash":"74dbae4fbb906c9bcfad23b97d4aa85975931a33","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/31-keycloak-steve-nnoadmin.png","hash":"9d3e05b550f2de53d254d1dc22295d24b0424224","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/33-keycloak-davecanaccessadminendpoint.png","hash":"a33d99991da2cb77e57e675ef73ed929f2aecd33","modified":1639563177538},{"_id":"public/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1639563177538},{"_id":"public/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1639563177538},{"_id":"public/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1639563177538},{"_id":"public/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1639563177538},{"_id":"public/css/cyberpunk.css","hash":"073797b87e28376604d586c48beb66f6fe9cb504","modified":1639563177538},{"_id":"public/css/style.css","hash":"49786c0fefcaa20821d9853a4a6ca81904322793","modified":1639563177538},{"_id":"public/css/default.css","hash":"49786c0fefcaa20821d9853a4a6ca81904322793","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/20-accesstoken-response.png","hash":"de03ce2a41fe49f8b0e2994f0c9da66d99eb4c93","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/24-keycloak-steven'stoken.png","hash":"94ebf70c25e81b4f6c5a3699b8500a1a33aebeb9","modified":1639563177538},{"_id":"public/images/spring/spring-boot-with-keycloak/32-keycloak-davegetaccesstoen.png","hash":"310158334ae666330113a3fd4a0f0d2a8ecfb501","modified":1639563177538},{"_id":"source/_posts/other/use-netlify-building-blog.md","hash":"3f83c9adab1199a105f4dab967f340908798d949","modified":1645425300103},{"_id":"source/images/other/use-netlify-building-blog/01_netlify_official_website.png","hash":"8e3fc19b6640f775a57bc659c2cdd6021255f9fb","modified":1640075048142},{"_id":"source/images/other/use-netlify-building-blog/02_github_account_login_netlify.png","hash":"91a3d14ff2ecfeac1f8d48b88ac23bc6451ee8d7","modified":1640079715090},{"_id":"source/images/other/use-netlify-building-blog/03_add_new_site.PNG","hash":"80d1cbe71aeba61d47d2c0d42b09b611fd6ef1b0","modified":1640138387862},{"_id":"source/images/other/use-netlify-building-blog/netlify_logo_icon_169924.png","hash":"2048eec534c873adfd525cd7c3b0033062d99d55","modified":1640137505061},{"_id":"source/images/other/use-netlify-building-blog/03_add_new_site.png","hash":"80d1cbe71aeba61d47d2c0d42b09b611fd6ef1b0","modified":1640162827742},{"_id":"source/images/other/use-netlify-building-blog/04-connect-github.png","hash":"20de57a0dea35974817e8415519a51d6603459cd","modified":1640139080480},{"_id":"source/images/other/use-netlify-building-blog/06-Basic-build-settings.png","hash":"6704a7dacc628d868fea95d28311e8c98fa80456","modified":1640140487985},{"_id":"source/images/other/use-netlify-building-blog/05-pick-a-repo.png","hash":"5b1832b003266fb874a2101eb6029473e76b4f16","modified":1640139422439},{"_id":"source/images/other/use-netlify-building-blog/09-buy-domain.png","hash":"9664018247bf78ee8a42d09133dea65b0096d559","modified":1640158831163},{"_id":"source/images/other/use-netlify-building-blog/10-gandi-admin-console.png","hash":"4909d140021cbf5ec563be644c6a9e2645c36792","modified":1640159417806},{"_id":"source/images/other/use-netlify-building-blog/13-add-custom-domain.png","hash":"300ae3af1f8d342c8c370b76164aec69d99d6d83","modified":1640160695774},{"_id":"source/images/other/use-netlify-building-blog/14-verify-domain.png","hash":"b67fe3946f67b9db9590eb8af6f7156be4ada481","modified":1640160125910},{"_id":"source/images/other/use-netlify-building-blog/15-netlify-dns-name-servers.png","hash":"69ed2768b063febe5985760b22879048e6d5e9f9","modified":1640161149165},{"_id":"source/images/other/use-netlify-building-blog/17-settings-gandi-outside-name-server.png","hash":"ee1dba34a1f48ceab9f692afea70b6e238b03612","modified":1640161769580},{"_id":"source/images/other/use-netlify-building-blog/19-finish-custom-domain.png","hash":"c3e19e9d7b577332174a6a78bc1c5a8840778bda","modified":1640162274034},{"_id":"source/images/other/use-netlify-building-blog/07-deploy-complete.png","hash":"90aa177ec59eb4d6aa1fecb06e62371ef02da3f4","modified":1640141106420},{"_id":"source/images/other/use-netlify-building-blog/11-domain-advance-settings.png","hash":"547d80bd2e4b55804b455067dc2f60544247e986","modified":1640159568211},{"_id":"source/images/other/use-netlify-building-blog/12-custom-domain.png","hash":"72dabf8b58aa277168ac26cdf0c142b64ced8c56","modified":1640160416177},{"_id":"source/images/other/use-netlify-building-blog/18-ssl-tls.png","hash":"25240b8ffff17d69d3b738cd1caa4aeeb3b2f746","modified":1640162175949},{"_id":"source/images/other/use-netlify-building-blog/16-enter-name-servers.png","hash":"c448499eef385e40cb4faba221635c5205ca7382","modified":1640161623778},{"_id":"source/images/other/use-netlify-building-blog/08-gandi-official-website.png","hash":"ad94ab0ead5208c9c41e029f8234211a74d57c75","modified":1640158187054},{"_id":"public/archives/2021/12/index.html","hash":"46c800831e7b3dcdae7e1e5be72a89d350fc8e5e","modified":1640162977399},{"_id":"public/2021/12/21/other/use-netlify-building-blog/index.html","hash":"04391481617ae685bc5374cf98784bb126e6f9ad","modified":1640162977399},{"_id":"public/tags/other/index.html","hash":"8445f3ed55c06df5eefd7fa46a58747f9a635ea5","modified":1640162977399},{"_id":"public/images/other/use-netlify-building-blog/02_github_account_login_netlify.png","hash":"91a3d14ff2ecfeac1f8d48b88ac23bc6451ee8d7","modified":1640162977399},{"_id":"public/images/other/use-netlify-building-blog/04-connect-github.png","hash":"20de57a0dea35974817e8415519a51d6603459cd","modified":1640162977399},{"_id":"public/images/other/use-netlify-building-blog/netlify_logo_icon_169924.png","hash":"2048eec534c873adfd525cd7c3b0033062d99d55","modified":1640162977399},{"_id":"public/images/other/use-netlify-building-blog/06-Basic-build-settings.png","hash":"6704a7dacc628d868fea95d28311e8c98fa80456","modified":1640162977399},{"_id":"public/images/other/use-netlify-building-blog/05-pick-a-repo.png","hash":"5b1832b003266fb874a2101eb6029473e76b4f16","modified":1640162977399},{"_id":"public/images/other/use-netlify-building-blog/10-gandi-admin-console.png","hash":"4909d140021cbf5ec563be644c6a9e2645c36792","modified":1640162977399},{"_id":"public/images/other/use-netlify-building-blog/09-buy-domain.png","hash":"9664018247bf78ee8a42d09133dea65b0096d559","modified":1640162977399},{"_id":"public/images/other/use-netlify-building-blog/13-add-custom-domain.png","hash":"300ae3af1f8d342c8c370b76164aec69d99d6d83","modified":1640162977399},{"_id":"public/images/other/use-netlify-building-blog/14-verify-domain.png","hash":"b67fe3946f67b9db9590eb8af6f7156be4ada481","modified":1640162977399},{"_id":"public/images/other/use-netlify-building-blog/15-netlify-dns-name-servers.png","hash":"69ed2768b063febe5985760b22879048e6d5e9f9","modified":1640162977399},{"_id":"public/images/other/use-netlify-building-blog/17-settings-gandi-outside-name-server.png","hash":"ee1dba34a1f48ceab9f692afea70b6e238b03612","modified":1640162977399},{"_id":"public/images/other/use-netlify-building-blog/19-finish-custom-domain.png","hash":"c3e19e9d7b577332174a6a78bc1c5a8840778bda","modified":1640162977399},{"_id":"public/images/other/use-netlify-building-blog/03_add_new_site.png","hash":"80d1cbe71aeba61d47d2c0d42b09b611fd6ef1b0","modified":1640162977399},{"_id":"public/images/other/use-netlify-building-blog/07-deploy-complete.png","hash":"90aa177ec59eb4d6aa1fecb06e62371ef02da3f4","modified":1640162977399},{"_id":"public/images/other/use-netlify-building-blog/11-domain-advance-settings.png","hash":"547d80bd2e4b55804b455067dc2f60544247e986","modified":1640162977399},{"_id":"public/images/other/use-netlify-building-blog/12-custom-domain.png","hash":"72dabf8b58aa277168ac26cdf0c142b64ced8c56","modified":1640162977399},{"_id":"public/images/other/use-netlify-building-blog/16-enter-name-servers.png","hash":"c448499eef385e40cb4faba221635c5205ca7382","modified":1640162977399},{"_id":"public/images/other/use-netlify-building-blog/18-ssl-tls.png","hash":"25240b8ffff17d69d3b738cd1caa4aeeb3b2f746","modified":1640162977399},{"_id":"public/images/other/use-netlify-building-blog/08-gandi-official-website.png","hash":"ad94ab0ead5208c9c41e029f8234211a74d57c75","modified":1640162977399},{"_id":"public/images/other/use-netlify-building-blog/01_netlify_official_website.png","hash":"8e3fc19b6640f775a57bc659c2cdd6021255f9fb","modified":1640162977399},{"_id":"source/golang/grpc-1.md","hash":"bdcee969bfa81e15f63280bcf919f8566dfdddca","modified":1642055160840},{"_id":"source/_posts/golang/grpc-1.md","hash":"d173d7aa1fe3336a559bdbbb6d5acafb4ad97d23","modified":1645425300103},{"_id":"source/images/golang/grpc-icon-color.png","hash":"f34366cc734707a26949b131fcf1f002be52cc95","modified":1642063065023},{"_id":"source/_posts/golang/errors.md","hash":"ef9a59b066548b790d91e8ba00976db4e49766bf","modified":1645424284302},{"_id":"source/images/golang/error/unwrap.png","hash":"760743fc1aa6cd9b0faa36b00709f079883edda1","modified":1643275251040},{"_id":"source/images/golang/error/wrap.png","hash":"d73bcf521c2b0b25f92963f0bca8a569621655aa","modified":1643273833043},{"_id":"source/images/golang/error/error-cover.jpeg","hash":"5d7ffcda88a0fda0f9f87f8b9009eb23f03fe0ab","modified":1643313121375},{"_id":"source/_posts/golang/goroutine.md","hash":"d81ba78cb9e28dfc04c4f782a51bc79e50895b92","modified":1645425300102},{"_id":"source/images/golang/goroutine.jpeg","hash":"5987fa3acc8574d0158bbee0da3104ebebe6a9c7","modified":1644890882942},{"_id":"source/_posts/golang/memory-model.md","hash":"e805187e1fc6e9ffbe41211e98aa33fcda0aadfe","modified":1662277419090},{"_id":"source/images/golang/memory-model/mutil-goroutine.png","hash":"2f4e6ca6f42e6e94c72007ea8cd69dabcae4bad2","modified":1645586960129},{"_id":"source/images/golang/memory-model/single-goroutine.png","hash":"d18badfe9d7fd3bc403519d7ffb82f5ade5dfa54","modified":1645610491267},{"_id":"source/_posts/sql/postgresql-row-level-security.md","hash":"8a02994744c3fe4477b462abbe879553b0b8610b","modified":1647925436540},{"_id":"source/images/golang/memory-model/cpu-store-buffer.png","hash":"be90eef887977f71c2b5384ceca9fbe16a10b8c2","modified":1645610491266},{"_id":"source/images/golang/memory-model/multi-goroutine.png","hash":"2f4e6ca6f42e6e94c72007ea8cd69dabcae4bad2","modified":1645610491267},{"_id":"source/images/golang/memory-model/sync.png","hash":"944fbe5795808eb3bcde3de596607038b58518d9","modified":1645610491267},{"_id":"source/_posts/java/thread-core-question.md","hash":"a1cdb1c18c129f6bc1aed8c7c9b8af7db1f7c35f","modified":1662308543814},{"_id":"source/_posts/java/threadlocal.md","hash":"16ca4f8240635b20ee7fa5dc32ee50d9aee8a77e","modified":1661840717719},{"_id":"source/_posts/java/visibility-atomic-ordering.md","hash":"1163e7562f69c8a5702779a583784c458f99d2e0","modified":1662479179236},{"_id":"source/images/java/concurrentcy/visibility-atomic-ordering/order-problem.jpg","hash":"2b0f91d8ecc2dec8ef463f395d094ff0a13676ce","modified":1662478894378},{"_id":"source/images/java/concurrentcy/visibility-atomic-ordering/thread-switch.jpg","hash":"468face9f5332e3dcd94fe8ab6f75c43570e527c","modified":1662307866808},{"_id":"source/images/java/concurrentcy/visibility-atomic-ordering/cpu-cache.png","hash":"d9daa953b107d6d1f5fe1d35b71a5ef28019f0d0","modified":1662279138258}],"Category":[{"name":"學習","_id":"ckzwb55uj0000bvzehf0i5xdz"},{"name":"工作","_id":"ckzwb8jle0005bvzeeox99jmx"}],"Data":[],"Page":[],"Post":[{"title":"[Security]Keycloak授權服務","date":"2021-01-11T03:33:43.000Z","toc":true,"_content":"\n上一篇詳細介紹了如何在Spring boot中集成Keycloak來進行應用程式的認證，將認證與授權從業務抽離出來，減少了代碼的撰寫，但在實際的生產環境中，僅僅進行認證服務肯定是不夠的，還需要授權功能。這一篇文章將介紹keycloak對服務所支援的授權功能\n\n<!-- more -->\n\n## keycloak所支援的授權策略\n\nKeycloak支持細粒度的授權策略(authorization policies)，並可以對這些策略進一步組合，例如：\n\n+ **Attribute-based access control (ABAC)**: 基於屬性的安全控制\n+ **Role-based access control (RBAC)**: 基於角色的安全控制\n+ **User-based access control (UBAC)**: 基於用戶的安全控制\n+ **Context-based access control (CBAC)**: 基於上下文的安全控制\n+ **Rule-based access control**: 基於規則的安全控制\n  + Using JavaScript\n+ **Time-based access control**: 基于時間的安全控制\n+ **Support for custom access control mechanisms (ACMs) through a Policy Provider Service Provider Interface (SPI)**: 通過SPI自定義訪問控制策略(ACMs)\n\nKeycloak提供了創建受保護資源和範圍權限的必要方法，將這些權限(permissions)與授權策略(authorization policies)相關聯，並在應用程序和服務中實施授權決策。\n\n+ 對於基於`RESTful的資源服務器`，該信息通常是從安全令牌中獲得的，通常是在每次向服務器請求時作為承載令牌發送的。\n\n+ 對於`依賴會話來認證用戶的Web應用程序`，該信息通常存儲在用戶會話中，並針對每個請求從該會話中檢索。\n\n資源服務器通常執行的是基於`角色的訪問控制(RBAC)策略`，即檢查用戶所擁有的角色是否關聯了要訪問的資源。雖然這種方式非常有用，但是它們也有一些限制：\n\n+ 資源和角色緊密耦合，角色的更改（如添加、刪除或更改訪問上下文）可能影響多個資源。\n+ 基於RBAC的應用程序無法很好地響應安全性需求的調整。\n+ 項目規模擴大時，覆雜的角色管理會很困難而且容易出錯。\n+ 不夠靈活。角色並不能有效代表用戶身份，即缺乏上下文信息。客觀上來說被授予了角色的用戶，至少會擁有某些訪問權限。\n\n時至今日，我們需要考慮異構環境，即用戶分佈在不同區域，使用不同的本地策略，使用不同的設備以及對信息共享的需求很高，Keycloak授權服務可以幫助您提高應用程序和服務的授權能力通過提供：\n\n+ 不同的訪問控制機制以及細粒度的授權策略。\n+ 集中式的資源、權限以及策略管理。\n+ 集中式的策略決策。\n+ REST風格的授權服務。\n+ 授權工作流程和用戶訪問管理。\n+ 可作為快速響應您項目中安全需求的基礎設施。\n\n## Keycloak授權架構\n\n從設計的角度來看，授權服務基於一組定義良好的授權模式，它們提供以下功能:\n\n![keycloack提供的功能](/images/spring/keycloak-authorization-services/01-authorication-arch.png)\n\n+ **策略管理點(PAP)**\n提供基於Keycloak管理控制台的一組UI，以管理資源服務器，資源，範圍，權限和策略。通過使用[Protection API](https://www.keycloak.org/docs/latest/authorization_services/index.html#_service_protection_api)可以部分完成此操作\n+ **政策決策點(PDP)**\n提供一個可分配的策略決策點，指向授權請求發送到的位置，並根據請求的權限對策略進行相應的評估。有關更多信息，請參見[Obtaining Permissions](https://www.keycloak.org/docs/latest/authorization_services/index.html#_service_obtaining_permissions)。  \n+ **政策執行點(PEP)**\n提供針對不同環境的實現，以在資源服務器端實際執行授權決策。Keycloak提供了一些內置的[Policy Enforcer](https://www.keycloak.org/docs/latest/authorization_services/index.html#_enforcer_overview)。  \n+ **政策信息點(PIP)**\n基於Keycloak Authentication Server，您可以在評估授權策略時從身份和運行時環境中獲取屬性。\n\n## Keycloak授權流程\n\n主要步驟為三個流程，以了解如何使用Keycloak為應用程序啟用細粒度授權:\n\n+ **資源管理(Resource Management)**\n+ **權限和政策管理(Permission and Policy Management)**\n+ **政策執行(Policy Enforcement)**\n\n### 資源管理(Resource Management)\n\n首先需要指定Keycloak希望保護的內容，通常代表Web應用程序或一組一個或多個服務。使用Keycloak管理控制台管理資源服務器。在那裡，可以啟用任何已注冊的客戶端應用程序作為資源服務器，並開始管理要保護的資源和範圍。\n\n![資源管理](/images/spring/keycloak-authorization-services/02-Resource-Management.png)\n\n資源可以是網頁，RESTFul資源，文件系統中的文件，EJB等。它們可以表示一組資源(就像Java中的class一樣)，也可以表示單個特定資源。\n\n例如某個用戶能訪問或控制某個區域的設備，區域和設備等都可以看作是資源。範圍(scope)通常表示可以對資源執行的操作，但它們不限於此。還可以使用範圍來表示資源中的一個或多個屬性。\n\n### 權限和政策管理(Permission and Policy Management)\n\n定義資源服務器和要保護的所有資源後，必須設置權限(permissions)和政策(policies)。**(重要)**\n\n此過程涉及實際定義管理資源的安全性和訪問要求的所有必要步驟。政策定義了訪問或執行某些操作(資源或範圍)必須滿足的條件，此部份是通用的，可以重用來構建權限甚至更覆雜的策略。\n\nKeycloak提供了一些內建的政策，比如基於Role的，基於Group的，或者基於User的政策，涵蓋了最常見的訪問控制機制。您甚至可以根據使用JavaScript編寫的規則創建政策。\n\n![權限和政策管理](/images/spring/keycloak-authorization-services/03-Permission-and-Policy-Management.png)\n\n定義政策後，即可開始定義權限，權限又與要保護的資源相結合。此處指定要保護的內容(資源或範圍)以及授予或拒絕權限必須滿足的政策。\n\n後面會有詳細的例子介紹如何創建使用。\n\n### 政策執行(Policy Enforcement)\n\n**政策實施**涉及必要的步驟，以實際對資源服務器實施授權決策。\n\n這是通過在資源服務器上啟用能夠與授權服務器進行通信，請求授權數據並基於服務器返回的決策和權限來控制對受保護資源的訪問的政策服務器或PEP來實現的。\n\n![政策執行(Policy Enforcement)](/images/spring/keycloak-authorization-services/04-Policy-Enforcement.png)\n\nKeycloak提供了一些內置的[Policy Enforcer](https://www.keycloak.org/docs/latest/authorization_services/index.html#_enforcer_overview)實施，具體取決其運行的平台。\n\n## keycloak授權服務\n\nkeycloak授權服務由以下RESTFul端點組成:\n\n+ **令牌端點(Token Endpoint)**\n+ **資源管理端點(Resource Management Endpoint)**\n+ **權限管理端點(Permission Management Endpoint)**\n\n每個服務都提供一個特定的API，涵蓋授權過程中涉及的不同步驟。\n\n### 令牌端點(Token Endpoint)\n\n> 一般熟知的Oauth流程\n\nOAuth2客戶端(例如前端應用程序)可以使用令牌端點從服務器獲取訪問令牌，並使用這些相同的令牌來訪問受資源服務器保護的資源(例如後端服務)。\n\n以相同的方式，Keycloak授權服務提供OAuth2的擴展，以允許基於與所請求的資源或範圍相關聯的所有策略的處理來發出訪問令牌。\n\n這意味著資源服務器可以基於服務器授予的訪問令牌所擁有的權限來強制對其受保護資源的訪問。在Keycloak授權服務中，具有權限的訪問令牌稱為請求方令牌(Requesting Party Token)。\n\n### Protection API\n\nProtection API是一組符[UMA](https://docs.kantarainitiative.org/uma/wg/oauth-uma-federated-authz-2.0-09.html)的端點，為資源服務器提供操作，以幫助他們管理與之關聯的資源，範圍，權限和策略。只允許資源服務器訪問此API，這也需要uma_protection範圍。\n\nProtection API提供的操作可以分為兩大類：\n\n1. **資源管理(Resource Management)**\n     + 創建資源(Create Resource)\n     + 刪除資源(Delete Resource)\n     + 按ID查找(Find by Id)\n     + 詢問(Query)\n2. **權限管理端點(Permission Management)**\n     + 發行許可票(Issue Permission Tickets)\n\n> 默認情況下，遠程資源管理為啟用狀態。您可以使用Keycloak管理控制台進行更改，並且僅允許通過控制台進行資源管理。 \n\n## 實例演練\n\n以下是我們要設置的方案:\n\n1. 新建一個Realm: `authorization-demo`\n2. 在此Realm下，新建一個Client: `bank-client`\n3. 定義一個`/account/{id}`為該Client下的一個Resource\n4. 在`/account/{id}`這個Resource下，有此 `account::view` Scope\n5. 建立一個User: `bob`\n6. 建立三個角色: `bank_teller`、`account_owner`和`user`\n7. 我們將設置以下兩個**Role-base** policies:\n     + `bank_teller`跟`account_owner`有權訪問`/account/{id}` Resource\n     + `account_owner`有權使用`account:view`Scope\n     + `user` 無權訪問任何Resource或Scope\n8. 使用keycloak內建的`Evaluate`工具來測試授予或拒絕訪問權限。\n\n### 配置Keycloak\n\n基本配置內容可參閱[上篇文章](/2021/01/09/spring/spring-boot-with-keycloak)\n\n### 建立Realm\n\n1. 將鼠標停在左上`master`，然後單擊`Add Realm`按鈕。\n2. 輸入`authorization-demo`作為名稱。\n3. 點擊Create。\n4. 確認左上角Realm在authorization-demo而不是master領域。\n\n![建立Realm: authorization-demo](/images/spring/keycloak-authorization-services/05-add-realm.png)\n\n### 建立User\n\n1. 點擊左側的`Users`選單\n2. 點擊`Add User`按鈕\n3. 輸入`username`(例如`bob`)\n4. 確保`User Enabled`為開啟狀態\n5. 請點擊 `Save`\n\n![建立User: bob](/images/spring/keycloak-authorization-services/06-create-user.png)\n\n### 建立Roles\n\n1. 點擊左側的`Roles`選單\n2. 點擊`Add Role`\n3. 添加下列角色：`bank_teller`，`account_owner`和`user`\n\n![建立Role: bank_teier](/images/spring/keycloak-authorization-services/07-create-role-bank-teller.png)\n\n![建立Role: account_owner](/images/spring/keycloak-authorization-services/08-create-role-account-owner.png)\n\n![建立Role: user](/images/spring/keycloak-authorization-services/09-create-role-user.png)\n\n### 建立Client\n\n1. 點擊左側的`Clients`選單\n2. 點擊 `Create`\n3. `Client ID`欄位輸入`bank-api`\n4. `Root URL`欄位輸入`http://127.0.0.1:8000/bank-api`\n5. 點擊`Save`\n6. 確保`Client Protocol`是`openid-connect`\n7. 更改`Access Type`為`confidential`\n8. 更改`Authorization Enabled`為`On`\n9. 向下滾動並點擊`Save`。`Authorization`應會顯示在上方\n10. 點擊`Authorization`選項，然後再點擊`Settings`\n11. 確保將`Decision Strategy`設置為`Unanimous`\n    + 這是 Resource server 的 Decision Strategy (決策策略)\n\n![建立Client: bank-api](/images/spring/keycloak-authorization-services/10-create-client.png)\n\n![更改Client設定](/images/spring/keycloak-authorization-services/11-setting-client.png)\n\n![確保 Decision Strategy 為 Unanimous](/images/spring/keycloak-authorization-services/12-client-authorization-setting.png)\n\n### (補充) Decision Strategy\n\n> This configurations changes how the policy evaluation engine decides whether or not a resource or scope should be granted based on the outcome from all evaluated permissions. Affirmative means that at least one permission must evaluate to a positive decision in order grant access to a resource and its scopes. Unanimous means that all permissions must evaluate to a positive decision in order for the final decision to be also positive. As an example, if two permissions for a same resource or scope are in conflict (one of them is granting access and the other is denying access), the permission to the resource or scope will be granted if the choosen strategy is Affirmative. Otherwise, a single deny from any permission will also deny access to the resource or scope.\n\n### 建立自定義Scope\n\n1. 點擊`Authorization`標籤\n2. 點擊`Authorization Scopes` &rarr; `Create`彈出`Add Scope`頁面\n3. 輸入`account:view`名稱，然後按Save。\n\n![建立Scope: account:view](/images/spring/keycloak-authorization-services/13-create-scope.png)\n\n### 建立自定義Resouce\n\n1. 點擊`Authorization`標籤\n2. 點擊 `Resources`\n3. 點擊 `Create`\n4. `Name`和`Display name`輸入`View Account Resource`\n5. `URI`輸入`/account/{id}`\n6. 在`Scopes`輸入`account:view`\n7. 點擊`Save`\n\n![建立Resource: View Account Resource](/images/spring/keycloak-authorization-services/14-create-resource.png)\n\n更多內容可參閱[Create Resources](https://www.keycloak.org/docs/latest/authorization_services/#_resource_create)\n\n### 建立Policies(重要)\n\n#### Create Only Bank Teller and Account Owner Policy\n\n1. 在`Authorization`標籤下，點擊`Policies`\n2. 從`Create Policy`下拉選單中選擇`Role`\n3. 在`Name`輸入`Only Bank Teller and Account Owner Policy`\n4. 在`Realm Roles`選擇`bank_teller`和`account_owner`角色並加入\n5. 確保`Logic`設置為`Positive`\n6. 請點擊 `Save`\n\n![建立Role Policy: Only Bank Teller and Account Owner Policy](/images/spring/keycloak-authorization-services/15-create-role-based-policy-1.png)\n\n#### Create Only Account Owner Policy\n\n1. 再次點擊`Policies`\n2. 再次從`Create Policy`下拉選單中選擇`Role`\n3. 這次在`Name`輸入`Only Account Owner Policy`\n4. 這次在`Realm Roles`下選擇`account_owner`\n5. 確保`Logic`設置為`Positive`\n6. 請點擊 `Save`\n\n![建立Role Policy: Only Account Owner Policy](/images/spring/keycloak-authorization-services/16-create-role-based-policy-1.png)\n\n更多內容請參閱[Role-Based Policy](https://www.keycloak.org/docs/latest/authorization_services/#_policy_rbac)\n\n其他Policy可參閱[Managing Policies](https://www.keycloak.org/docs/latest/authorization_services/#_policy_overview)\n\n### 建立 Resource-Based Permission\n\n1. 再次在`Authorization`標籤下，點擊`Permissions`\n2. 選擇 `Resource-Based`\n3. `Name`欄位輸入`View Account Resource Permission`\n4. `Resources`欄位輸入`View Account Resource`\n5. `Apply Policy`下`Only Bank Teller and Account Owner Policy`\n6. 確保`Decision Strategy`設置為`Unanimous`\n7. 點擊`Save`\n\n![建立Resource-Based Permission: View Account Resource Permission](/images/spring/keycloak-authorization-services/17-create-resource-base-permission.png)\n\n### Evaluating the Resource-Based permission\n\n1. 再次在`Authorization`標籤下，選擇`Evaluate`\n2. 在`User`輸入`bob`\n3. 在`Roles`選擇`user`\n   + 我們在這將User與我們創建的Role做關聯。\n4. 在`Resources`下選擇`View Account Resource`，然後點擊`Add`\n5. 點擊`Evaluate`\n\n   ![使用Authorization裡的Evaluate測試權限設置是否生效](/images/spring/keycloak-authorization-services/18-Evaluating-the-Resource-Based-permission.png)\n\n6. 展開`View Account Resource with scopes [account:view]`以查看結果，應該看到`DENY`。\n\n   <!-- ![](/images/spring/keycloak-authorization-services/19-Evaluating-the-Resource-Based-permission-2.png) -->\n\n   ![Role: user得到DENY結果](/images/spring/keycloak-authorization-services/20-Evaluating-the-Resource-Based-permission-result-1.png)\n\n7. 此部份的驗證是對的，因為在上方我們建立的一個只允許兩個角色訪問該Resource: `Only Bank Teller and Account Owner Policy`Policy\n8. 點擊`Back`回到`Evaluate`頁面\n9. 將`bob`的角色更改為`account_owner`，然後點擊`Evaluate`。現在，應該看到結果為`PERMIT`。將角色更改為`bank_teller`，也是同樣結果。\n\n![Role: account_owner得到PERMIT結果](/images/spring/keycloak-authorization-services/21-Evaluating-the-Resource-Based-permission-result-2.png)\n\n更多內容請參閱[Evaluating and Testing Policies](https://www.keycloak.org/docs/latest/authorization_services/#_policy_evaluation_overview)\n\n### 建立 Scope-Based Permission\n\n1. 返回`Permissions`標籤\n2. 在`Create Permission`下拉選單中選擇`Scope-Based`\n3. `Name`輸入`View Account Scope Permission`\n4. `Scopes`輸入`account:view`\n5. `Apply Policy`輸入`Only Account Owner Policy`\n6. 確保`Decision Strategy`設置為`Unanimous`\n7. 點擊`Save`\n\n   ![建立Scope-Based Permission: View Account Scope Permission](/images/spring/keycloak-authorization-services/22-create-scope-based.png)\n\n更多內容請參閱[Creating Scope-Based Permissions](https://www.keycloak.org/docs/latest/authorization_services/index.html#_permission_create_scope)\n\n### Evaluating the Scope-Based permission\n\n1. 再次點擊`Evaluate`標籤\n2. 在`User`輸入`bob`\n3. 在`Roles`選擇`bank_teller`\n4. 在`Resources`下選擇`View Account Resource`，然後點擊`Add`\n5. 點擊`Evaluate`，得到`DENY`\n   + 因為設置了`bank_teller`只可以訪問`resource`但不能訪問`scope` \n   + 且Resource server的`Decision Strategy`設置為`Unanimous`，最後的決定是`DENY`。(訪問resource評估為true，但訪問scope評估為false，所以得到`DENY`)\n\n   ![測試Role: bank_teller權限](/images/spring/keycloak-authorization-services/23-Evaluatioin-new-change-1.png)\n\n   ![Role: bank_teller不能訪問Scope](/images/spring/keycloak-authorization-services/24-Evaluation-new-change-result-1.png)\n\n6. 回到`Authorization`下的`Settings`，然後將更`Decision Strategy`改為`Affirmative`，然後再次返回到步驟1-5。這次最終結果應該是`PERMIT`（其中一個權限為true，所以最終結果為true）。\n\n   ![修改Decision Strategy為Affirmative](/images/spring/keycloak-authorization-services/25-Evaluation-new-changet-2.png)\n\n   ![重新上述步驟1-5，得到PERMIT結果](/images/spring/keycloak-authorization-services/26-Evaluation-new-change-result-2.png)\n\n7. 為了完整起見，將resource server的`Decision Strategy`重新設置為`Unanimous`。重新實施步驟1至5，但這一次將角色設置為`account_owner`。鑑於`account_owner`可以同時訪問`resource`和`scope`，所以這次的結果`PERMIT`。\n\n![Role: account_owner可訪問Resource以及Scope](/images/spring/keycloak-authorization-services/27-Evaluation-new-change-result-3.png)\n\n## 結論\n\n說明authorization policies原理，以及透過實例來建制流程\n\n1. 先定義好scope\n2. 再建立resource，再把resource跟scope建立關聯\n3. 再建立policy(Role-Based、User-Based...)把resource與此policy關聯起來\n4. 再建立Resource-Based Permission or Scope-Based Permission。把 Policy與resource or scope關聯起來\n\n## 參考資料\n\n+ <https://www.keycloak.org/docs/latest/authorization_services/index.html>\n\n+ <https://stackoverflow.com/questions/42186537/resources-scopes-permissions-and-policies-in-keycloak>","source":"_posts/spring/keycloak-authorization-services.md","raw":"---\ntitle: '[Security]Keycloak授權服務'\ndate: 2021-01-11 11:33:43\ntags: keycloak\ncategories: 工作\ntoc: true\n---\n\n上一篇詳細介紹了如何在Spring boot中集成Keycloak來進行應用程式的認證，將認證與授權從業務抽離出來，減少了代碼的撰寫，但在實際的生產環境中，僅僅進行認證服務肯定是不夠的，還需要授權功能。這一篇文章將介紹keycloak對服務所支援的授權功能\n\n<!-- more -->\n\n## keycloak所支援的授權策略\n\nKeycloak支持細粒度的授權策略(authorization policies)，並可以對這些策略進一步組合，例如：\n\n+ **Attribute-based access control (ABAC)**: 基於屬性的安全控制\n+ **Role-based access control (RBAC)**: 基於角色的安全控制\n+ **User-based access control (UBAC)**: 基於用戶的安全控制\n+ **Context-based access control (CBAC)**: 基於上下文的安全控制\n+ **Rule-based access control**: 基於規則的安全控制\n  + Using JavaScript\n+ **Time-based access control**: 基于時間的安全控制\n+ **Support for custom access control mechanisms (ACMs) through a Policy Provider Service Provider Interface (SPI)**: 通過SPI自定義訪問控制策略(ACMs)\n\nKeycloak提供了創建受保護資源和範圍權限的必要方法，將這些權限(permissions)與授權策略(authorization policies)相關聯，並在應用程序和服務中實施授權決策。\n\n+ 對於基於`RESTful的資源服務器`，該信息通常是從安全令牌中獲得的，通常是在每次向服務器請求時作為承載令牌發送的。\n\n+ 對於`依賴會話來認證用戶的Web應用程序`，該信息通常存儲在用戶會話中，並針對每個請求從該會話中檢索。\n\n資源服務器通常執行的是基於`角色的訪問控制(RBAC)策略`，即檢查用戶所擁有的角色是否關聯了要訪問的資源。雖然這種方式非常有用，但是它們也有一些限制：\n\n+ 資源和角色緊密耦合，角色的更改（如添加、刪除或更改訪問上下文）可能影響多個資源。\n+ 基於RBAC的應用程序無法很好地響應安全性需求的調整。\n+ 項目規模擴大時，覆雜的角色管理會很困難而且容易出錯。\n+ 不夠靈活。角色並不能有效代表用戶身份，即缺乏上下文信息。客觀上來說被授予了角色的用戶，至少會擁有某些訪問權限。\n\n時至今日，我們需要考慮異構環境，即用戶分佈在不同區域，使用不同的本地策略，使用不同的設備以及對信息共享的需求很高，Keycloak授權服務可以幫助您提高應用程序和服務的授權能力通過提供：\n\n+ 不同的訪問控制機制以及細粒度的授權策略。\n+ 集中式的資源、權限以及策略管理。\n+ 集中式的策略決策。\n+ REST風格的授權服務。\n+ 授權工作流程和用戶訪問管理。\n+ 可作為快速響應您項目中安全需求的基礎設施。\n\n## Keycloak授權架構\n\n從設計的角度來看，授權服務基於一組定義良好的授權模式，它們提供以下功能:\n\n![keycloack提供的功能](/images/spring/keycloak-authorization-services/01-authorication-arch.png)\n\n+ **策略管理點(PAP)**\n提供基於Keycloak管理控制台的一組UI，以管理資源服務器，資源，範圍，權限和策略。通過使用[Protection API](https://www.keycloak.org/docs/latest/authorization_services/index.html#_service_protection_api)可以部分完成此操作\n+ **政策決策點(PDP)**\n提供一個可分配的策略決策點，指向授權請求發送到的位置，並根據請求的權限對策略進行相應的評估。有關更多信息，請參見[Obtaining Permissions](https://www.keycloak.org/docs/latest/authorization_services/index.html#_service_obtaining_permissions)。  \n+ **政策執行點(PEP)**\n提供針對不同環境的實現，以在資源服務器端實際執行授權決策。Keycloak提供了一些內置的[Policy Enforcer](https://www.keycloak.org/docs/latest/authorization_services/index.html#_enforcer_overview)。  \n+ **政策信息點(PIP)**\n基於Keycloak Authentication Server，您可以在評估授權策略時從身份和運行時環境中獲取屬性。\n\n## Keycloak授權流程\n\n主要步驟為三個流程，以了解如何使用Keycloak為應用程序啟用細粒度授權:\n\n+ **資源管理(Resource Management)**\n+ **權限和政策管理(Permission and Policy Management)**\n+ **政策執行(Policy Enforcement)**\n\n### 資源管理(Resource Management)\n\n首先需要指定Keycloak希望保護的內容，通常代表Web應用程序或一組一個或多個服務。使用Keycloak管理控制台管理資源服務器。在那裡，可以啟用任何已注冊的客戶端應用程序作為資源服務器，並開始管理要保護的資源和範圍。\n\n![資源管理](/images/spring/keycloak-authorization-services/02-Resource-Management.png)\n\n資源可以是網頁，RESTFul資源，文件系統中的文件，EJB等。它們可以表示一組資源(就像Java中的class一樣)，也可以表示單個特定資源。\n\n例如某個用戶能訪問或控制某個區域的設備，區域和設備等都可以看作是資源。範圍(scope)通常表示可以對資源執行的操作，但它們不限於此。還可以使用範圍來表示資源中的一個或多個屬性。\n\n### 權限和政策管理(Permission and Policy Management)\n\n定義資源服務器和要保護的所有資源後，必須設置權限(permissions)和政策(policies)。**(重要)**\n\n此過程涉及實際定義管理資源的安全性和訪問要求的所有必要步驟。政策定義了訪問或執行某些操作(資源或範圍)必須滿足的條件，此部份是通用的，可以重用來構建權限甚至更覆雜的策略。\n\nKeycloak提供了一些內建的政策，比如基於Role的，基於Group的，或者基於User的政策，涵蓋了最常見的訪問控制機制。您甚至可以根據使用JavaScript編寫的規則創建政策。\n\n![權限和政策管理](/images/spring/keycloak-authorization-services/03-Permission-and-Policy-Management.png)\n\n定義政策後，即可開始定義權限，權限又與要保護的資源相結合。此處指定要保護的內容(資源或範圍)以及授予或拒絕權限必須滿足的政策。\n\n後面會有詳細的例子介紹如何創建使用。\n\n### 政策執行(Policy Enforcement)\n\n**政策實施**涉及必要的步驟，以實際對資源服務器實施授權決策。\n\n這是通過在資源服務器上啟用能夠與授權服務器進行通信，請求授權數據並基於服務器返回的決策和權限來控制對受保護資源的訪問的政策服務器或PEP來實現的。\n\n![政策執行(Policy Enforcement)](/images/spring/keycloak-authorization-services/04-Policy-Enforcement.png)\n\nKeycloak提供了一些內置的[Policy Enforcer](https://www.keycloak.org/docs/latest/authorization_services/index.html#_enforcer_overview)實施，具體取決其運行的平台。\n\n## keycloak授權服務\n\nkeycloak授權服務由以下RESTFul端點組成:\n\n+ **令牌端點(Token Endpoint)**\n+ **資源管理端點(Resource Management Endpoint)**\n+ **權限管理端點(Permission Management Endpoint)**\n\n每個服務都提供一個特定的API，涵蓋授權過程中涉及的不同步驟。\n\n### 令牌端點(Token Endpoint)\n\n> 一般熟知的Oauth流程\n\nOAuth2客戶端(例如前端應用程序)可以使用令牌端點從服務器獲取訪問令牌，並使用這些相同的令牌來訪問受資源服務器保護的資源(例如後端服務)。\n\n以相同的方式，Keycloak授權服務提供OAuth2的擴展，以允許基於與所請求的資源或範圍相關聯的所有策略的處理來發出訪問令牌。\n\n這意味著資源服務器可以基於服務器授予的訪問令牌所擁有的權限來強制對其受保護資源的訪問。在Keycloak授權服務中，具有權限的訪問令牌稱為請求方令牌(Requesting Party Token)。\n\n### Protection API\n\nProtection API是一組符[UMA](https://docs.kantarainitiative.org/uma/wg/oauth-uma-federated-authz-2.0-09.html)的端點，為資源服務器提供操作，以幫助他們管理與之關聯的資源，範圍，權限和策略。只允許資源服務器訪問此API，這也需要uma_protection範圍。\n\nProtection API提供的操作可以分為兩大類：\n\n1. **資源管理(Resource Management)**\n     + 創建資源(Create Resource)\n     + 刪除資源(Delete Resource)\n     + 按ID查找(Find by Id)\n     + 詢問(Query)\n2. **權限管理端點(Permission Management)**\n     + 發行許可票(Issue Permission Tickets)\n\n> 默認情況下，遠程資源管理為啟用狀態。您可以使用Keycloak管理控制台進行更改，並且僅允許通過控制台進行資源管理。 \n\n## 實例演練\n\n以下是我們要設置的方案:\n\n1. 新建一個Realm: `authorization-demo`\n2. 在此Realm下，新建一個Client: `bank-client`\n3. 定義一個`/account/{id}`為該Client下的一個Resource\n4. 在`/account/{id}`這個Resource下，有此 `account::view` Scope\n5. 建立一個User: `bob`\n6. 建立三個角色: `bank_teller`、`account_owner`和`user`\n7. 我們將設置以下兩個**Role-base** policies:\n     + `bank_teller`跟`account_owner`有權訪問`/account/{id}` Resource\n     + `account_owner`有權使用`account:view`Scope\n     + `user` 無權訪問任何Resource或Scope\n8. 使用keycloak內建的`Evaluate`工具來測試授予或拒絕訪問權限。\n\n### 配置Keycloak\n\n基本配置內容可參閱[上篇文章](/2021/01/09/spring/spring-boot-with-keycloak)\n\n### 建立Realm\n\n1. 將鼠標停在左上`master`，然後單擊`Add Realm`按鈕。\n2. 輸入`authorization-demo`作為名稱。\n3. 點擊Create。\n4. 確認左上角Realm在authorization-demo而不是master領域。\n\n![建立Realm: authorization-demo](/images/spring/keycloak-authorization-services/05-add-realm.png)\n\n### 建立User\n\n1. 點擊左側的`Users`選單\n2. 點擊`Add User`按鈕\n3. 輸入`username`(例如`bob`)\n4. 確保`User Enabled`為開啟狀態\n5. 請點擊 `Save`\n\n![建立User: bob](/images/spring/keycloak-authorization-services/06-create-user.png)\n\n### 建立Roles\n\n1. 點擊左側的`Roles`選單\n2. 點擊`Add Role`\n3. 添加下列角色：`bank_teller`，`account_owner`和`user`\n\n![建立Role: bank_teier](/images/spring/keycloak-authorization-services/07-create-role-bank-teller.png)\n\n![建立Role: account_owner](/images/spring/keycloak-authorization-services/08-create-role-account-owner.png)\n\n![建立Role: user](/images/spring/keycloak-authorization-services/09-create-role-user.png)\n\n### 建立Client\n\n1. 點擊左側的`Clients`選單\n2. 點擊 `Create`\n3. `Client ID`欄位輸入`bank-api`\n4. `Root URL`欄位輸入`http://127.0.0.1:8000/bank-api`\n5. 點擊`Save`\n6. 確保`Client Protocol`是`openid-connect`\n7. 更改`Access Type`為`confidential`\n8. 更改`Authorization Enabled`為`On`\n9. 向下滾動並點擊`Save`。`Authorization`應會顯示在上方\n10. 點擊`Authorization`選項，然後再點擊`Settings`\n11. 確保將`Decision Strategy`設置為`Unanimous`\n    + 這是 Resource server 的 Decision Strategy (決策策略)\n\n![建立Client: bank-api](/images/spring/keycloak-authorization-services/10-create-client.png)\n\n![更改Client設定](/images/spring/keycloak-authorization-services/11-setting-client.png)\n\n![確保 Decision Strategy 為 Unanimous](/images/spring/keycloak-authorization-services/12-client-authorization-setting.png)\n\n### (補充) Decision Strategy\n\n> This configurations changes how the policy evaluation engine decides whether or not a resource or scope should be granted based on the outcome from all evaluated permissions. Affirmative means that at least one permission must evaluate to a positive decision in order grant access to a resource and its scopes. Unanimous means that all permissions must evaluate to a positive decision in order for the final decision to be also positive. As an example, if two permissions for a same resource or scope are in conflict (one of them is granting access and the other is denying access), the permission to the resource or scope will be granted if the choosen strategy is Affirmative. Otherwise, a single deny from any permission will also deny access to the resource or scope.\n\n### 建立自定義Scope\n\n1. 點擊`Authorization`標籤\n2. 點擊`Authorization Scopes` &rarr; `Create`彈出`Add Scope`頁面\n3. 輸入`account:view`名稱，然後按Save。\n\n![建立Scope: account:view](/images/spring/keycloak-authorization-services/13-create-scope.png)\n\n### 建立自定義Resouce\n\n1. 點擊`Authorization`標籤\n2. 點擊 `Resources`\n3. 點擊 `Create`\n4. `Name`和`Display name`輸入`View Account Resource`\n5. `URI`輸入`/account/{id}`\n6. 在`Scopes`輸入`account:view`\n7. 點擊`Save`\n\n![建立Resource: View Account Resource](/images/spring/keycloak-authorization-services/14-create-resource.png)\n\n更多內容可參閱[Create Resources](https://www.keycloak.org/docs/latest/authorization_services/#_resource_create)\n\n### 建立Policies(重要)\n\n#### Create Only Bank Teller and Account Owner Policy\n\n1. 在`Authorization`標籤下，點擊`Policies`\n2. 從`Create Policy`下拉選單中選擇`Role`\n3. 在`Name`輸入`Only Bank Teller and Account Owner Policy`\n4. 在`Realm Roles`選擇`bank_teller`和`account_owner`角色並加入\n5. 確保`Logic`設置為`Positive`\n6. 請點擊 `Save`\n\n![建立Role Policy: Only Bank Teller and Account Owner Policy](/images/spring/keycloak-authorization-services/15-create-role-based-policy-1.png)\n\n#### Create Only Account Owner Policy\n\n1. 再次點擊`Policies`\n2. 再次從`Create Policy`下拉選單中選擇`Role`\n3. 這次在`Name`輸入`Only Account Owner Policy`\n4. 這次在`Realm Roles`下選擇`account_owner`\n5. 確保`Logic`設置為`Positive`\n6. 請點擊 `Save`\n\n![建立Role Policy: Only Account Owner Policy](/images/spring/keycloak-authorization-services/16-create-role-based-policy-1.png)\n\n更多內容請參閱[Role-Based Policy](https://www.keycloak.org/docs/latest/authorization_services/#_policy_rbac)\n\n其他Policy可參閱[Managing Policies](https://www.keycloak.org/docs/latest/authorization_services/#_policy_overview)\n\n### 建立 Resource-Based Permission\n\n1. 再次在`Authorization`標籤下，點擊`Permissions`\n2. 選擇 `Resource-Based`\n3. `Name`欄位輸入`View Account Resource Permission`\n4. `Resources`欄位輸入`View Account Resource`\n5. `Apply Policy`下`Only Bank Teller and Account Owner Policy`\n6. 確保`Decision Strategy`設置為`Unanimous`\n7. 點擊`Save`\n\n![建立Resource-Based Permission: View Account Resource Permission](/images/spring/keycloak-authorization-services/17-create-resource-base-permission.png)\n\n### Evaluating the Resource-Based permission\n\n1. 再次在`Authorization`標籤下，選擇`Evaluate`\n2. 在`User`輸入`bob`\n3. 在`Roles`選擇`user`\n   + 我們在這將User與我們創建的Role做關聯。\n4. 在`Resources`下選擇`View Account Resource`，然後點擊`Add`\n5. 點擊`Evaluate`\n\n   ![使用Authorization裡的Evaluate測試權限設置是否生效](/images/spring/keycloak-authorization-services/18-Evaluating-the-Resource-Based-permission.png)\n\n6. 展開`View Account Resource with scopes [account:view]`以查看結果，應該看到`DENY`。\n\n   <!-- ![](/images/spring/keycloak-authorization-services/19-Evaluating-the-Resource-Based-permission-2.png) -->\n\n   ![Role: user得到DENY結果](/images/spring/keycloak-authorization-services/20-Evaluating-the-Resource-Based-permission-result-1.png)\n\n7. 此部份的驗證是對的，因為在上方我們建立的一個只允許兩個角色訪問該Resource: `Only Bank Teller and Account Owner Policy`Policy\n8. 點擊`Back`回到`Evaluate`頁面\n9. 將`bob`的角色更改為`account_owner`，然後點擊`Evaluate`。現在，應該看到結果為`PERMIT`。將角色更改為`bank_teller`，也是同樣結果。\n\n![Role: account_owner得到PERMIT結果](/images/spring/keycloak-authorization-services/21-Evaluating-the-Resource-Based-permission-result-2.png)\n\n更多內容請參閱[Evaluating and Testing Policies](https://www.keycloak.org/docs/latest/authorization_services/#_policy_evaluation_overview)\n\n### 建立 Scope-Based Permission\n\n1. 返回`Permissions`標籤\n2. 在`Create Permission`下拉選單中選擇`Scope-Based`\n3. `Name`輸入`View Account Scope Permission`\n4. `Scopes`輸入`account:view`\n5. `Apply Policy`輸入`Only Account Owner Policy`\n6. 確保`Decision Strategy`設置為`Unanimous`\n7. 點擊`Save`\n\n   ![建立Scope-Based Permission: View Account Scope Permission](/images/spring/keycloak-authorization-services/22-create-scope-based.png)\n\n更多內容請參閱[Creating Scope-Based Permissions](https://www.keycloak.org/docs/latest/authorization_services/index.html#_permission_create_scope)\n\n### Evaluating the Scope-Based permission\n\n1. 再次點擊`Evaluate`標籤\n2. 在`User`輸入`bob`\n3. 在`Roles`選擇`bank_teller`\n4. 在`Resources`下選擇`View Account Resource`，然後點擊`Add`\n5. 點擊`Evaluate`，得到`DENY`\n   + 因為設置了`bank_teller`只可以訪問`resource`但不能訪問`scope` \n   + 且Resource server的`Decision Strategy`設置為`Unanimous`，最後的決定是`DENY`。(訪問resource評估為true，但訪問scope評估為false，所以得到`DENY`)\n\n   ![測試Role: bank_teller權限](/images/spring/keycloak-authorization-services/23-Evaluatioin-new-change-1.png)\n\n   ![Role: bank_teller不能訪問Scope](/images/spring/keycloak-authorization-services/24-Evaluation-new-change-result-1.png)\n\n6. 回到`Authorization`下的`Settings`，然後將更`Decision Strategy`改為`Affirmative`，然後再次返回到步驟1-5。這次最終結果應該是`PERMIT`（其中一個權限為true，所以最終結果為true）。\n\n   ![修改Decision Strategy為Affirmative](/images/spring/keycloak-authorization-services/25-Evaluation-new-changet-2.png)\n\n   ![重新上述步驟1-5，得到PERMIT結果](/images/spring/keycloak-authorization-services/26-Evaluation-new-change-result-2.png)\n\n7. 為了完整起見，將resource server的`Decision Strategy`重新設置為`Unanimous`。重新實施步驟1至5，但這一次將角色設置為`account_owner`。鑑於`account_owner`可以同時訪問`resource`和`scope`，所以這次的結果`PERMIT`。\n\n![Role: account_owner可訪問Resource以及Scope](/images/spring/keycloak-authorization-services/27-Evaluation-new-change-result-3.png)\n\n## 結論\n\n說明authorization policies原理，以及透過實例來建制流程\n\n1. 先定義好scope\n2. 再建立resource，再把resource跟scope建立關聯\n3. 再建立policy(Role-Based、User-Based...)把resource與此policy關聯起來\n4. 再建立Resource-Based Permission or Scope-Based Permission。把 Policy與resource or scope關聯起來\n\n## 參考資料\n\n+ <https://www.keycloak.org/docs/latest/authorization_services/index.html>\n\n+ <https://stackoverflow.com/questions/42186537/resources-scopes-permissions-and-policies-in-keycloak>","slug":"spring/keycloak-authorization-services","published":1,"updated":"2022-02-21T06:35:00.104Z","_id":"ckx7dl13z0000tyzeglwx1ta3","comments":1,"layout":"post","photos":[],"link":"","content":"<p>上一篇詳細介紹了如何在Spring boot中集成Keycloak來進行應用程式的認證，將認證與授權從業務抽離出來，減少了代碼的撰寫，但在實際的生產環境中，僅僅進行認證服務肯定是不夠的，還需要授權功能。這一篇文章將介紹keycloak對服務所支援的授權功能</p>\n<span id=\"more\"></span>\n\n<h2 id=\"keycloak所支援的授權策略\"><a href=\"#keycloak所支援的授權策略\" class=\"headerlink\" title=\"keycloak所支援的授權策略\"></a>keycloak所支援的授權策略</h2><p>Keycloak支持細粒度的授權策略(authorization policies)，並可以對這些策略進一步組合，例如：</p>\n<ul>\n<li><strong>Attribute-based access control (ABAC)</strong>: 基於屬性的安全控制</li>\n<li><strong>Role-based access control (RBAC)</strong>: 基於角色的安全控制</li>\n<li><strong>User-based access control (UBAC)</strong>: 基於用戶的安全控制</li>\n<li><strong>Context-based access control (CBAC)</strong>: 基於上下文的安全控制</li>\n<li><strong>Rule-based access control</strong>: 基於規則的安全控制<ul>\n<li>Using JavaScript</li>\n</ul>\n</li>\n<li><strong>Time-based access control</strong>: 基于時間的安全控制</li>\n<li><strong>Support for custom access control mechanisms (ACMs) through a Policy Provider Service Provider Interface (SPI)</strong>: 通過SPI自定義訪問控制策略(ACMs)</li>\n</ul>\n<p>Keycloak提供了創建受保護資源和範圍權限的必要方法，將這些權限(permissions)與授權策略(authorization policies)相關聯，並在應用程序和服務中實施授權決策。</p>\n<ul>\n<li><p>對於基於<code>RESTful的資源服務器</code>，該信息通常是從安全令牌中獲得的，通常是在每次向服務器請求時作為承載令牌發送的。</p>\n</li>\n<li><p>對於<code>依賴會話來認證用戶的Web應用程序</code>，該信息通常存儲在用戶會話中，並針對每個請求從該會話中檢索。</p>\n</li>\n</ul>\n<p>資源服務器通常執行的是基於<code>角色的訪問控制(RBAC)策略</code>，即檢查用戶所擁有的角色是否關聯了要訪問的資源。雖然這種方式非常有用，但是它們也有一些限制：</p>\n<ul>\n<li>資源和角色緊密耦合，角色的更改（如添加、刪除或更改訪問上下文）可能影響多個資源。</li>\n<li>基於RBAC的應用程序無法很好地響應安全性需求的調整。</li>\n<li>項目規模擴大時，覆雜的角色管理會很困難而且容易出錯。</li>\n<li>不夠靈活。角色並不能有效代表用戶身份，即缺乏上下文信息。客觀上來說被授予了角色的用戶，至少會擁有某些訪問權限。</li>\n</ul>\n<p>時至今日，我們需要考慮異構環境，即用戶分佈在不同區域，使用不同的本地策略，使用不同的設備以及對信息共享的需求很高，Keycloak授權服務可以幫助您提高應用程序和服務的授權能力通過提供：</p>\n<ul>\n<li>不同的訪問控制機制以及細粒度的授權策略。</li>\n<li>集中式的資源、權限以及策略管理。</li>\n<li>集中式的策略決策。</li>\n<li>REST風格的授權服務。</li>\n<li>授權工作流程和用戶訪問管理。</li>\n<li>可作為快速響應您項目中安全需求的基礎設施。</li>\n</ul>\n<h2 id=\"Keycloak授權架構\"><a href=\"#Keycloak授權架構\" class=\"headerlink\" title=\"Keycloak授權架構\"></a>Keycloak授權架構</h2><p>從設計的角度來看，授權服務基於一組定義良好的授權模式，它們提供以下功能:</p>\n<p><img src=\"/images/spring/keycloak-authorization-services/01-authorication-arch.png\" alt=\"keycloack提供的功能\"></p>\n<ul>\n<li><strong>策略管理點(PAP)</strong><br>提供基於Keycloak管理控制台的一組UI，以管理資源服務器，資源，範圍，權限和策略。通過使用<a href=\"https://www.keycloak.org/docs/latest/authorization_services/index.html#_service_protection_api\">Protection API</a>可以部分完成此操作</li>\n<li><strong>政策決策點(PDP)</strong><br>提供一個可分配的策略決策點，指向授權請求發送到的位置，並根據請求的權限對策略進行相應的評估。有關更多信息，請參見<a href=\"https://www.keycloak.org/docs/latest/authorization_services/index.html#_service_obtaining_permissions\">Obtaining Permissions</a>。  </li>\n<li><strong>政策執行點(PEP)</strong><br>提供針對不同環境的實現，以在資源服務器端實際執行授權決策。Keycloak提供了一些內置的<a href=\"https://www.keycloak.org/docs/latest/authorization_services/index.html#_enforcer_overview\">Policy Enforcer</a>。  </li>\n<li><strong>政策信息點(PIP)</strong><br>基於Keycloak Authentication Server，您可以在評估授權策略時從身份和運行時環境中獲取屬性。</li>\n</ul>\n<h2 id=\"Keycloak授權流程\"><a href=\"#Keycloak授權流程\" class=\"headerlink\" title=\"Keycloak授權流程\"></a>Keycloak授權流程</h2><p>主要步驟為三個流程，以了解如何使用Keycloak為應用程序啟用細粒度授權:</p>\n<ul>\n<li><strong>資源管理(Resource Management)</strong></li>\n<li><strong>權限和政策管理(Permission and Policy Management)</strong></li>\n<li><strong>政策執行(Policy Enforcement)</strong></li>\n</ul>\n<h3 id=\"資源管理-Resource-Management\"><a href=\"#資源管理-Resource-Management\" class=\"headerlink\" title=\"資源管理(Resource Management)\"></a>資源管理(Resource Management)</h3><p>首先需要指定Keycloak希望保護的內容，通常代表Web應用程序或一組一個或多個服務。使用Keycloak管理控制台管理資源服務器。在那裡，可以啟用任何已注冊的客戶端應用程序作為資源服務器，並開始管理要保護的資源和範圍。</p>\n<p><img src=\"/images/spring/keycloak-authorization-services/02-Resource-Management.png\" alt=\"資源管理\"></p>\n<p>資源可以是網頁，RESTFul資源，文件系統中的文件，EJB等。它們可以表示一組資源(就像Java中的class一樣)，也可以表示單個特定資源。</p>\n<p>例如某個用戶能訪問或控制某個區域的設備，區域和設備等都可以看作是資源。範圍(scope)通常表示可以對資源執行的操作，但它們不限於此。還可以使用範圍來表示資源中的一個或多個屬性。</p>\n<h3 id=\"權限和政策管理-Permission-and-Policy-Management\"><a href=\"#權限和政策管理-Permission-and-Policy-Management\" class=\"headerlink\" title=\"權限和政策管理(Permission and Policy Management)\"></a>權限和政策管理(Permission and Policy Management)</h3><p>定義資源服務器和要保護的所有資源後，必須設置權限(permissions)和政策(policies)。**(重要)**</p>\n<p>此過程涉及實際定義管理資源的安全性和訪問要求的所有必要步驟。政策定義了訪問或執行某些操作(資源或範圍)必須滿足的條件，此部份是通用的，可以重用來構建權限甚至更覆雜的策略。</p>\n<p>Keycloak提供了一些內建的政策，比如基於Role的，基於Group的，或者基於User的政策，涵蓋了最常見的訪問控制機制。您甚至可以根據使用JavaScript編寫的規則創建政策。</p>\n<p><img src=\"/images/spring/keycloak-authorization-services/03-Permission-and-Policy-Management.png\" alt=\"權限和政策管理\"></p>\n<p>定義政策後，即可開始定義權限，權限又與要保護的資源相結合。此處指定要保護的內容(資源或範圍)以及授予或拒絕權限必須滿足的政策。</p>\n<p>後面會有詳細的例子介紹如何創建使用。</p>\n<h3 id=\"政策執行-Policy-Enforcement\"><a href=\"#政策執行-Policy-Enforcement\" class=\"headerlink\" title=\"政策執行(Policy Enforcement)\"></a>政策執行(Policy Enforcement)</h3><p><strong>政策實施</strong>涉及必要的步驟，以實際對資源服務器實施授權決策。</p>\n<p>這是通過在資源服務器上啟用能夠與授權服務器進行通信，請求授權數據並基於服務器返回的決策和權限來控制對受保護資源的訪問的政策服務器或PEP來實現的。</p>\n<p><img src=\"/images/spring/keycloak-authorization-services/04-Policy-Enforcement.png\" alt=\"政策執行(Policy Enforcement)\"></p>\n<p>Keycloak提供了一些內置的<a href=\"https://www.keycloak.org/docs/latest/authorization_services/index.html#_enforcer_overview\">Policy Enforcer</a>實施，具體取決其運行的平台。</p>\n<h2 id=\"keycloak授權服務\"><a href=\"#keycloak授權服務\" class=\"headerlink\" title=\"keycloak授權服務\"></a>keycloak授權服務</h2><p>keycloak授權服務由以下RESTFul端點組成:</p>\n<ul>\n<li><strong>令牌端點(Token Endpoint)</strong></li>\n<li><strong>資源管理端點(Resource Management Endpoint)</strong></li>\n<li><strong>權限管理端點(Permission Management Endpoint)</strong></li>\n</ul>\n<p>每個服務都提供一個特定的API，涵蓋授權過程中涉及的不同步驟。</p>\n<h3 id=\"令牌端點-Token-Endpoint\"><a href=\"#令牌端點-Token-Endpoint\" class=\"headerlink\" title=\"令牌端點(Token Endpoint)\"></a>令牌端點(Token Endpoint)</h3><blockquote>\n<p>一般熟知的Oauth流程</p>\n</blockquote>\n<p>OAuth2客戶端(例如前端應用程序)可以使用令牌端點從服務器獲取訪問令牌，並使用這些相同的令牌來訪問受資源服務器保護的資源(例如後端服務)。</p>\n<p>以相同的方式，Keycloak授權服務提供OAuth2的擴展，以允許基於與所請求的資源或範圍相關聯的所有策略的處理來發出訪問令牌。</p>\n<p>這意味著資源服務器可以基於服務器授予的訪問令牌所擁有的權限來強制對其受保護資源的訪問。在Keycloak授權服務中，具有權限的訪問令牌稱為請求方令牌(Requesting Party Token)。</p>\n<h3 id=\"Protection-API\"><a href=\"#Protection-API\" class=\"headerlink\" title=\"Protection API\"></a>Protection API</h3><p>Protection API是一組符<a href=\"https://docs.kantarainitiative.org/uma/wg/oauth-uma-federated-authz-2.0-09.html\">UMA</a>的端點，為資源服務器提供操作，以幫助他們管理與之關聯的資源，範圍，權限和策略。只允許資源服務器訪問此API，這也需要uma_protection範圍。</p>\n<p>Protection API提供的操作可以分為兩大類：</p>\n<ol>\n<li><strong>資源管理(Resource Management)</strong><ul>\n<li>創建資源(Create Resource)</li>\n<li>刪除資源(Delete Resource)</li>\n<li>按ID查找(Find by Id)</li>\n<li>詢問(Query)</li>\n</ul>\n</li>\n<li><strong>權限管理端點(Permission Management)</strong><ul>\n<li>發行許可票(Issue Permission Tickets)</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>默認情況下，遠程資源管理為啟用狀態。您可以使用Keycloak管理控制台進行更改，並且僅允許通過控制台進行資源管理。 </p>\n</blockquote>\n<h2 id=\"實例演練\"><a href=\"#實例演練\" class=\"headerlink\" title=\"實例演練\"></a>實例演練</h2><p>以下是我們要設置的方案:</p>\n<ol>\n<li>新建一個Realm: <code>authorization-demo</code></li>\n<li>在此Realm下，新建一個Client: <code>bank-client</code></li>\n<li>定義一個<code>/account/&#123;id&#125;</code>為該Client下的一個Resource</li>\n<li>在<code>/account/&#123;id&#125;</code>這個Resource下，有此 <code>account::view</code> Scope</li>\n<li>建立一個User: <code>bob</code></li>\n<li>建立三個角色: <code>bank_teller</code>、<code>account_owner</code>和<code>user</code></li>\n<li>我們將設置以下兩個<strong>Role-base</strong> policies:<ul>\n<li><code>bank_teller</code>跟<code>account_owner</code>有權訪問<code>/account/&#123;id&#125;</code> Resource</li>\n<li><code>account_owner</code>有權使用<code>account:view</code>Scope</li>\n<li><code>user</code> 無權訪問任何Resource或Scope</li>\n</ul>\n</li>\n<li>使用keycloak內建的<code>Evaluate</code>工具來測試授予或拒絕訪問權限。</li>\n</ol>\n<h3 id=\"配置Keycloak\"><a href=\"#配置Keycloak\" class=\"headerlink\" title=\"配置Keycloak\"></a>配置Keycloak</h3><p>基本配置內容可參閱<a href=\"/2021/01/09/spring/spring-boot-with-keycloak\">上篇文章</a></p>\n<h3 id=\"建立Realm\"><a href=\"#建立Realm\" class=\"headerlink\" title=\"建立Realm\"></a>建立Realm</h3><ol>\n<li>將鼠標停在左上<code>master</code>，然後單擊<code>Add Realm</code>按鈕。</li>\n<li>輸入<code>authorization-demo</code>作為名稱。</li>\n<li>點擊Create。</li>\n<li>確認左上角Realm在authorization-demo而不是master領域。</li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/05-add-realm.png\" alt=\"建立Realm: authorization-demo\"></p>\n<h3 id=\"建立User\"><a href=\"#建立User\" class=\"headerlink\" title=\"建立User\"></a>建立User</h3><ol>\n<li>點擊左側的<code>Users</code>選單</li>\n<li>點擊<code>Add User</code>按鈕</li>\n<li>輸入<code>username</code>(例如<code>bob</code>)</li>\n<li>確保<code>User Enabled</code>為開啟狀態</li>\n<li>請點擊 <code>Save</code></li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/06-create-user.png\" alt=\"建立User: bob\"></p>\n<h3 id=\"建立Roles\"><a href=\"#建立Roles\" class=\"headerlink\" title=\"建立Roles\"></a>建立Roles</h3><ol>\n<li>點擊左側的<code>Roles</code>選單</li>\n<li>點擊<code>Add Role</code></li>\n<li>添加下列角色：<code>bank_teller</code>，<code>account_owner</code>和<code>user</code></li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/07-create-role-bank-teller.png\" alt=\"建立Role: bank_teier\"></p>\n<p><img src=\"/images/spring/keycloak-authorization-services/08-create-role-account-owner.png\" alt=\"建立Role: account_owner\"></p>\n<p><img src=\"/images/spring/keycloak-authorization-services/09-create-role-user.png\" alt=\"建立Role: user\"></p>\n<h3 id=\"建立Client\"><a href=\"#建立Client\" class=\"headerlink\" title=\"建立Client\"></a>建立Client</h3><ol>\n<li>點擊左側的<code>Clients</code>選單</li>\n<li>點擊 <code>Create</code></li>\n<li><code>Client ID</code>欄位輸入<code>bank-api</code></li>\n<li><code>Root URL</code>欄位輸入<code>http://127.0.0.1:8000/bank-api</code></li>\n<li>點擊<code>Save</code></li>\n<li>確保<code>Client Protocol</code>是<code>openid-connect</code></li>\n<li>更改<code>Access Type</code>為<code>confidential</code></li>\n<li>更改<code>Authorization Enabled</code>為<code>On</code></li>\n<li>向下滾動並點擊<code>Save</code>。<code>Authorization</code>應會顯示在上方</li>\n<li>點擊<code>Authorization</code>選項，然後再點擊<code>Settings</code></li>\n<li>確保將<code>Decision Strategy</code>設置為<code>Unanimous</code><ul>\n<li>這是 Resource server 的 Decision Strategy (決策策略)</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/10-create-client.png\" alt=\"建立Client: bank-api\"></p>\n<p><img src=\"/images/spring/keycloak-authorization-services/11-setting-client.png\" alt=\"更改Client設定\"></p>\n<p><img src=\"/images/spring/keycloak-authorization-services/12-client-authorization-setting.png\" alt=\"確保 Decision Strategy 為 Unanimous\"></p>\n<h3 id=\"補充-Decision-Strategy\"><a href=\"#補充-Decision-Strategy\" class=\"headerlink\" title=\"(補充) Decision Strategy\"></a>(補充) Decision Strategy</h3><blockquote>\n<p>This configurations changes how the policy evaluation engine decides whether or not a resource or scope should be granted based on the outcome from all evaluated permissions. Affirmative means that at least one permission must evaluate to a positive decision in order grant access to a resource and its scopes. Unanimous means that all permissions must evaluate to a positive decision in order for the final decision to be also positive. As an example, if two permissions for a same resource or scope are in conflict (one of them is granting access and the other is denying access), the permission to the resource or scope will be granted if the choosen strategy is Affirmative. Otherwise, a single deny from any permission will also deny access to the resource or scope.</p>\n</blockquote>\n<h3 id=\"建立自定義Scope\"><a href=\"#建立自定義Scope\" class=\"headerlink\" title=\"建立自定義Scope\"></a>建立自定義Scope</h3><ol>\n<li>點擊<code>Authorization</code>標籤</li>\n<li>點擊<code>Authorization Scopes</code> &rarr; <code>Create</code>彈出<code>Add Scope</code>頁面</li>\n<li>輸入<code>account:view</code>名稱，然後按Save。</li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/13-create-scope.png\" alt=\"建立Scope: account:view\"></p>\n<h3 id=\"建立自定義Resouce\"><a href=\"#建立自定義Resouce\" class=\"headerlink\" title=\"建立自定義Resouce\"></a>建立自定義Resouce</h3><ol>\n<li>點擊<code>Authorization</code>標籤</li>\n<li>點擊 <code>Resources</code></li>\n<li>點擊 <code>Create</code></li>\n<li><code>Name</code>和<code>Display name</code>輸入<code>View Account Resource</code></li>\n<li><code>URI</code>輸入<code>/account/&#123;id&#125;</code></li>\n<li>在<code>Scopes</code>輸入<code>account:view</code></li>\n<li>點擊<code>Save</code></li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/14-create-resource.png\" alt=\"建立Resource: View Account Resource\"></p>\n<p>更多內容可參閱<a href=\"https://www.keycloak.org/docs/latest/authorization_services/#_resource_create\">Create Resources</a></p>\n<h3 id=\"建立Policies-重要\"><a href=\"#建立Policies-重要\" class=\"headerlink\" title=\"建立Policies(重要)\"></a>建立Policies(重要)</h3><h4 id=\"Create-Only-Bank-Teller-and-Account-Owner-Policy\"><a href=\"#Create-Only-Bank-Teller-and-Account-Owner-Policy\" class=\"headerlink\" title=\"Create Only Bank Teller and Account Owner Policy\"></a>Create Only Bank Teller and Account Owner Policy</h4><ol>\n<li>在<code>Authorization</code>標籤下，點擊<code>Policies</code></li>\n<li>從<code>Create Policy</code>下拉選單中選擇<code>Role</code></li>\n<li>在<code>Name</code>輸入<code>Only Bank Teller and Account Owner Policy</code></li>\n<li>在<code>Realm Roles</code>選擇<code>bank_teller</code>和<code>account_owner</code>角色並加入</li>\n<li>確保<code>Logic</code>設置為<code>Positive</code></li>\n<li>請點擊 <code>Save</code></li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/15-create-role-based-policy-1.png\" alt=\"建立Role Policy: Only Bank Teller and Account Owner Policy\"></p>\n<h4 id=\"Create-Only-Account-Owner-Policy\"><a href=\"#Create-Only-Account-Owner-Policy\" class=\"headerlink\" title=\"Create Only Account Owner Policy\"></a>Create Only Account Owner Policy</h4><ol>\n<li>再次點擊<code>Policies</code></li>\n<li>再次從<code>Create Policy</code>下拉選單中選擇<code>Role</code></li>\n<li>這次在<code>Name</code>輸入<code>Only Account Owner Policy</code></li>\n<li>這次在<code>Realm Roles</code>下選擇<code>account_owner</code></li>\n<li>確保<code>Logic</code>設置為<code>Positive</code></li>\n<li>請點擊 <code>Save</code></li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/16-create-role-based-policy-1.png\" alt=\"建立Role Policy: Only Account Owner Policy\"></p>\n<p>更多內容請參閱<a href=\"https://www.keycloak.org/docs/latest/authorization_services/#_policy_rbac\">Role-Based Policy</a></p>\n<p>其他Policy可參閱<a href=\"https://www.keycloak.org/docs/latest/authorization_services/#_policy_overview\">Managing Policies</a></p>\n<h3 id=\"建立-Resource-Based-Permission\"><a href=\"#建立-Resource-Based-Permission\" class=\"headerlink\" title=\"建立 Resource-Based Permission\"></a>建立 Resource-Based Permission</h3><ol>\n<li>再次在<code>Authorization</code>標籤下，點擊<code>Permissions</code></li>\n<li>選擇 <code>Resource-Based</code></li>\n<li><code>Name</code>欄位輸入<code>View Account Resource Permission</code></li>\n<li><code>Resources</code>欄位輸入<code>View Account Resource</code></li>\n<li><code>Apply Policy</code>下<code>Only Bank Teller and Account Owner Policy</code></li>\n<li>確保<code>Decision Strategy</code>設置為<code>Unanimous</code></li>\n<li>點擊<code>Save</code></li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/17-create-resource-base-permission.png\" alt=\"建立Resource-Based Permission: View Account Resource Permission\"></p>\n<h3 id=\"Evaluating-the-Resource-Based-permission\"><a href=\"#Evaluating-the-Resource-Based-permission\" class=\"headerlink\" title=\"Evaluating the Resource-Based permission\"></a>Evaluating the Resource-Based permission</h3><ol>\n<li><p>再次在<code>Authorization</code>標籤下，選擇<code>Evaluate</code></p>\n</li>\n<li><p>在<code>User</code>輸入<code>bob</code></p>\n</li>\n<li><p>在<code>Roles</code>選擇<code>user</code></p>\n<ul>\n<li>我們在這將User與我們創建的Role做關聯。</li>\n</ul>\n</li>\n<li><p>在<code>Resources</code>下選擇<code>View Account Resource</code>，然後點擊<code>Add</code></p>\n</li>\n<li><p>點擊<code>Evaluate</code></p>\n<p><img src=\"/images/spring/keycloak-authorization-services/18-Evaluating-the-Resource-Based-permission.png\" alt=\"使用Authorization裡的Evaluate測試權限設置是否生效\"></p>\n</li>\n<li><p>展開<code>View Account Resource with scopes [account:view]</code>以查看結果，應該看到<code>DENY</code>。</p>\n<!-- ![](/images/spring/keycloak-authorization-services/19-Evaluating-the-Resource-Based-permission-2.png) -->\n\n<p><img src=\"/images/spring/keycloak-authorization-services/20-Evaluating-the-Resource-Based-permission-result-1.png\" alt=\"Role: user得到DENY結果\"></p>\n</li>\n<li><p>此部份的驗證是對的，因為在上方我們建立的一個只允許兩個角色訪問該Resource: <code>Only Bank Teller and Account Owner Policy</code>Policy</p>\n</li>\n<li><p>點擊<code>Back</code>回到<code>Evaluate</code>頁面</p>\n</li>\n<li><p>將<code>bob</code>的角色更改為<code>account_owner</code>，然後點擊<code>Evaluate</code>。現在，應該看到結果為<code>PERMIT</code>。將角色更改為<code>bank_teller</code>，也是同樣結果。</p>\n</li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/21-Evaluating-the-Resource-Based-permission-result-2.png\" alt=\"Role: account_owner得到PERMIT結果\"></p>\n<p>更多內容請參閱<a href=\"https://www.keycloak.org/docs/latest/authorization_services/#_policy_evaluation_overview\">Evaluating and Testing Policies</a></p>\n<h3 id=\"建立-Scope-Based-Permission\"><a href=\"#建立-Scope-Based-Permission\" class=\"headerlink\" title=\"建立 Scope-Based Permission\"></a>建立 Scope-Based Permission</h3><ol>\n<li><p>返回<code>Permissions</code>標籤</p>\n</li>\n<li><p>在<code>Create Permission</code>下拉選單中選擇<code>Scope-Based</code></p>\n</li>\n<li><p><code>Name</code>輸入<code>View Account Scope Permission</code></p>\n</li>\n<li><p><code>Scopes</code>輸入<code>account:view</code></p>\n</li>\n<li><p><code>Apply Policy</code>輸入<code>Only Account Owner Policy</code></p>\n</li>\n<li><p>確保<code>Decision Strategy</code>設置為<code>Unanimous</code></p>\n</li>\n<li><p>點擊<code>Save</code></p>\n<p><img src=\"/images/spring/keycloak-authorization-services/22-create-scope-based.png\" alt=\"建立Scope-Based Permission: View Account Scope Permission\"></p>\n</li>\n</ol>\n<p>更多內容請參閱<a href=\"https://www.keycloak.org/docs/latest/authorization_services/index.html#_permission_create_scope\">Creating Scope-Based Permissions</a></p>\n<h3 id=\"Evaluating-the-Scope-Based-permission\"><a href=\"#Evaluating-the-Scope-Based-permission\" class=\"headerlink\" title=\"Evaluating the Scope-Based permission\"></a>Evaluating the Scope-Based permission</h3><ol>\n<li><p>再次點擊<code>Evaluate</code>標籤</p>\n</li>\n<li><p>在<code>User</code>輸入<code>bob</code></p>\n</li>\n<li><p>在<code>Roles</code>選擇<code>bank_teller</code></p>\n</li>\n<li><p>在<code>Resources</code>下選擇<code>View Account Resource</code>，然後點擊<code>Add</code></p>\n</li>\n<li><p>點擊<code>Evaluate</code>，得到<code>DENY</code></p>\n<ul>\n<li>因為設置了<code>bank_teller</code>只可以訪問<code>resource</code>但不能訪問<code>scope</code> </li>\n<li>且Resource server的<code>Decision Strategy</code>設置為<code>Unanimous</code>，最後的決定是<code>DENY</code>。(訪問resource評估為true，但訪問scope評估為false，所以得到<code>DENY</code>)</li>\n</ul>\n<p><img src=\"/images/spring/keycloak-authorization-services/23-Evaluatioin-new-change-1.png\" alt=\"測試Role: bank_teller權限\"></p>\n<p><img src=\"/images/spring/keycloak-authorization-services/24-Evaluation-new-change-result-1.png\" alt=\"Role: bank_teller不能訪問Scope\"></p>\n</li>\n<li><p>回到<code>Authorization</code>下的<code>Settings</code>，然後將更<code>Decision Strategy</code>改為<code>Affirmative</code>，然後再次返回到步驟1-5。這次最終結果應該是<code>PERMIT</code>（其中一個權限為true，所以最終結果為true）。</p>\n<p><img src=\"/images/spring/keycloak-authorization-services/25-Evaluation-new-changet-2.png\" alt=\"修改Decision Strategy為Affirmative\"></p>\n<p><img src=\"/images/spring/keycloak-authorization-services/26-Evaluation-new-change-result-2.png\" alt=\"重新上述步驟1-5，得到PERMIT結果\"></p>\n</li>\n<li><p>為了完整起見，將resource server的<code>Decision Strategy</code>重新設置為<code>Unanimous</code>。重新實施步驟1至5，但這一次將角色設置為<code>account_owner</code>。鑑於<code>account_owner</code>可以同時訪問<code>resource</code>和<code>scope</code>，所以這次的結果<code>PERMIT</code>。</p>\n</li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/27-Evaluation-new-change-result-3.png\" alt=\"Role: account_owner可訪問Resource以及Scope\"></p>\n<h2 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h2><p>說明authorization policies原理，以及透過實例來建制流程</p>\n<ol>\n<li>先定義好scope</li>\n<li>再建立resource，再把resource跟scope建立關聯</li>\n<li>再建立policy(Role-Based、User-Based…)把resource與此policy關聯起來</li>\n<li>再建立Resource-Based Permission or Scope-Based Permission。把 Policy與resource or scope關聯起來</li>\n</ol>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><p><a href=\"https://www.keycloak.org/docs/latest/authorization_services/index.html\">https://www.keycloak.org/docs/latest/authorization_services/index.html</a></p>\n</li>\n<li><p><a href=\"https://stackoverflow.com/questions/42186537/resources-scopes-permissions-and-policies-in-keycloak\">https://stackoverflow.com/questions/42186537/resources-scopes-permissions-and-policies-in-keycloak</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>上一篇詳細介紹了如何在Spring boot中集成Keycloak來進行應用程式的認證，將認證與授權從業務抽離出來，減少了代碼的撰寫，但在實際的生產環境中，僅僅進行認證服務肯定是不夠的，還需要授權功能。這一篇文章將介紹keycloak對服務所支援的授權功能</p>","more":"<h2 id=\"keycloak所支援的授權策略\"><a href=\"#keycloak所支援的授權策略\" class=\"headerlink\" title=\"keycloak所支援的授權策略\"></a>keycloak所支援的授權策略</h2><p>Keycloak支持細粒度的授權策略(authorization policies)，並可以對這些策略進一步組合，例如：</p>\n<ul>\n<li><strong>Attribute-based access control (ABAC)</strong>: 基於屬性的安全控制</li>\n<li><strong>Role-based access control (RBAC)</strong>: 基於角色的安全控制</li>\n<li><strong>User-based access control (UBAC)</strong>: 基於用戶的安全控制</li>\n<li><strong>Context-based access control (CBAC)</strong>: 基於上下文的安全控制</li>\n<li><strong>Rule-based access control</strong>: 基於規則的安全控制<ul>\n<li>Using JavaScript</li>\n</ul>\n</li>\n<li><strong>Time-based access control</strong>: 基于時間的安全控制</li>\n<li><strong>Support for custom access control mechanisms (ACMs) through a Policy Provider Service Provider Interface (SPI)</strong>: 通過SPI自定義訪問控制策略(ACMs)</li>\n</ul>\n<p>Keycloak提供了創建受保護資源和範圍權限的必要方法，將這些權限(permissions)與授權策略(authorization policies)相關聯，並在應用程序和服務中實施授權決策。</p>\n<ul>\n<li><p>對於基於<code>RESTful的資源服務器</code>，該信息通常是從安全令牌中獲得的，通常是在每次向服務器請求時作為承載令牌發送的。</p>\n</li>\n<li><p>對於<code>依賴會話來認證用戶的Web應用程序</code>，該信息通常存儲在用戶會話中，並針對每個請求從該會話中檢索。</p>\n</li>\n</ul>\n<p>資源服務器通常執行的是基於<code>角色的訪問控制(RBAC)策略</code>，即檢查用戶所擁有的角色是否關聯了要訪問的資源。雖然這種方式非常有用，但是它們也有一些限制：</p>\n<ul>\n<li>資源和角色緊密耦合，角色的更改（如添加、刪除或更改訪問上下文）可能影響多個資源。</li>\n<li>基於RBAC的應用程序無法很好地響應安全性需求的調整。</li>\n<li>項目規模擴大時，覆雜的角色管理會很困難而且容易出錯。</li>\n<li>不夠靈活。角色並不能有效代表用戶身份，即缺乏上下文信息。客觀上來說被授予了角色的用戶，至少會擁有某些訪問權限。</li>\n</ul>\n<p>時至今日，我們需要考慮異構環境，即用戶分佈在不同區域，使用不同的本地策略，使用不同的設備以及對信息共享的需求很高，Keycloak授權服務可以幫助您提高應用程序和服務的授權能力通過提供：</p>\n<ul>\n<li>不同的訪問控制機制以及細粒度的授權策略。</li>\n<li>集中式的資源、權限以及策略管理。</li>\n<li>集中式的策略決策。</li>\n<li>REST風格的授權服務。</li>\n<li>授權工作流程和用戶訪問管理。</li>\n<li>可作為快速響應您項目中安全需求的基礎設施。</li>\n</ul>\n<h2 id=\"Keycloak授權架構\"><a href=\"#Keycloak授權架構\" class=\"headerlink\" title=\"Keycloak授權架構\"></a>Keycloak授權架構</h2><p>從設計的角度來看，授權服務基於一組定義良好的授權模式，它們提供以下功能:</p>\n<p><img src=\"/images/spring/keycloak-authorization-services/01-authorication-arch.png\" alt=\"keycloack提供的功能\"></p>\n<ul>\n<li><strong>策略管理點(PAP)</strong><br>提供基於Keycloak管理控制台的一組UI，以管理資源服務器，資源，範圍，權限和策略。通過使用<a href=\"https://www.keycloak.org/docs/latest/authorization_services/index.html#_service_protection_api\">Protection API</a>可以部分完成此操作</li>\n<li><strong>政策決策點(PDP)</strong><br>提供一個可分配的策略決策點，指向授權請求發送到的位置，並根據請求的權限對策略進行相應的評估。有關更多信息，請參見<a href=\"https://www.keycloak.org/docs/latest/authorization_services/index.html#_service_obtaining_permissions\">Obtaining Permissions</a>。  </li>\n<li><strong>政策執行點(PEP)</strong><br>提供針對不同環境的實現，以在資源服務器端實際執行授權決策。Keycloak提供了一些內置的<a href=\"https://www.keycloak.org/docs/latest/authorization_services/index.html#_enforcer_overview\">Policy Enforcer</a>。  </li>\n<li><strong>政策信息點(PIP)</strong><br>基於Keycloak Authentication Server，您可以在評估授權策略時從身份和運行時環境中獲取屬性。</li>\n</ul>\n<h2 id=\"Keycloak授權流程\"><a href=\"#Keycloak授權流程\" class=\"headerlink\" title=\"Keycloak授權流程\"></a>Keycloak授權流程</h2><p>主要步驟為三個流程，以了解如何使用Keycloak為應用程序啟用細粒度授權:</p>\n<ul>\n<li><strong>資源管理(Resource Management)</strong></li>\n<li><strong>權限和政策管理(Permission and Policy Management)</strong></li>\n<li><strong>政策執行(Policy Enforcement)</strong></li>\n</ul>\n<h3 id=\"資源管理-Resource-Management\"><a href=\"#資源管理-Resource-Management\" class=\"headerlink\" title=\"資源管理(Resource Management)\"></a>資源管理(Resource Management)</h3><p>首先需要指定Keycloak希望保護的內容，通常代表Web應用程序或一組一個或多個服務。使用Keycloak管理控制台管理資源服務器。在那裡，可以啟用任何已注冊的客戶端應用程序作為資源服務器，並開始管理要保護的資源和範圍。</p>\n<p><img src=\"/images/spring/keycloak-authorization-services/02-Resource-Management.png\" alt=\"資源管理\"></p>\n<p>資源可以是網頁，RESTFul資源，文件系統中的文件，EJB等。它們可以表示一組資源(就像Java中的class一樣)，也可以表示單個特定資源。</p>\n<p>例如某個用戶能訪問或控制某個區域的設備，區域和設備等都可以看作是資源。範圍(scope)通常表示可以對資源執行的操作，但它們不限於此。還可以使用範圍來表示資源中的一個或多個屬性。</p>\n<h3 id=\"權限和政策管理-Permission-and-Policy-Management\"><a href=\"#權限和政策管理-Permission-and-Policy-Management\" class=\"headerlink\" title=\"權限和政策管理(Permission and Policy Management)\"></a>權限和政策管理(Permission and Policy Management)</h3><p>定義資源服務器和要保護的所有資源後，必須設置權限(permissions)和政策(policies)。**(重要)**</p>\n<p>此過程涉及實際定義管理資源的安全性和訪問要求的所有必要步驟。政策定義了訪問或執行某些操作(資源或範圍)必須滿足的條件，此部份是通用的，可以重用來構建權限甚至更覆雜的策略。</p>\n<p>Keycloak提供了一些內建的政策，比如基於Role的，基於Group的，或者基於User的政策，涵蓋了最常見的訪問控制機制。您甚至可以根據使用JavaScript編寫的規則創建政策。</p>\n<p><img src=\"/images/spring/keycloak-authorization-services/03-Permission-and-Policy-Management.png\" alt=\"權限和政策管理\"></p>\n<p>定義政策後，即可開始定義權限，權限又與要保護的資源相結合。此處指定要保護的內容(資源或範圍)以及授予或拒絕權限必須滿足的政策。</p>\n<p>後面會有詳細的例子介紹如何創建使用。</p>\n<h3 id=\"政策執行-Policy-Enforcement\"><a href=\"#政策執行-Policy-Enforcement\" class=\"headerlink\" title=\"政策執行(Policy Enforcement)\"></a>政策執行(Policy Enforcement)</h3><p><strong>政策實施</strong>涉及必要的步驟，以實際對資源服務器實施授權決策。</p>\n<p>這是通過在資源服務器上啟用能夠與授權服務器進行通信，請求授權數據並基於服務器返回的決策和權限來控制對受保護資源的訪問的政策服務器或PEP來實現的。</p>\n<p><img src=\"/images/spring/keycloak-authorization-services/04-Policy-Enforcement.png\" alt=\"政策執行(Policy Enforcement)\"></p>\n<p>Keycloak提供了一些內置的<a href=\"https://www.keycloak.org/docs/latest/authorization_services/index.html#_enforcer_overview\">Policy Enforcer</a>實施，具體取決其運行的平台。</p>\n<h2 id=\"keycloak授權服務\"><a href=\"#keycloak授權服務\" class=\"headerlink\" title=\"keycloak授權服務\"></a>keycloak授權服務</h2><p>keycloak授權服務由以下RESTFul端點組成:</p>\n<ul>\n<li><strong>令牌端點(Token Endpoint)</strong></li>\n<li><strong>資源管理端點(Resource Management Endpoint)</strong></li>\n<li><strong>權限管理端點(Permission Management Endpoint)</strong></li>\n</ul>\n<p>每個服務都提供一個特定的API，涵蓋授權過程中涉及的不同步驟。</p>\n<h3 id=\"令牌端點-Token-Endpoint\"><a href=\"#令牌端點-Token-Endpoint\" class=\"headerlink\" title=\"令牌端點(Token Endpoint)\"></a>令牌端點(Token Endpoint)</h3><blockquote>\n<p>一般熟知的Oauth流程</p>\n</blockquote>\n<p>OAuth2客戶端(例如前端應用程序)可以使用令牌端點從服務器獲取訪問令牌，並使用這些相同的令牌來訪問受資源服務器保護的資源(例如後端服務)。</p>\n<p>以相同的方式，Keycloak授權服務提供OAuth2的擴展，以允許基於與所請求的資源或範圍相關聯的所有策略的處理來發出訪問令牌。</p>\n<p>這意味著資源服務器可以基於服務器授予的訪問令牌所擁有的權限來強制對其受保護資源的訪問。在Keycloak授權服務中，具有權限的訪問令牌稱為請求方令牌(Requesting Party Token)。</p>\n<h3 id=\"Protection-API\"><a href=\"#Protection-API\" class=\"headerlink\" title=\"Protection API\"></a>Protection API</h3><p>Protection API是一組符<a href=\"https://docs.kantarainitiative.org/uma/wg/oauth-uma-federated-authz-2.0-09.html\">UMA</a>的端點，為資源服務器提供操作，以幫助他們管理與之關聯的資源，範圍，權限和策略。只允許資源服務器訪問此API，這也需要uma_protection範圍。</p>\n<p>Protection API提供的操作可以分為兩大類：</p>\n<ol>\n<li><strong>資源管理(Resource Management)</strong><ul>\n<li>創建資源(Create Resource)</li>\n<li>刪除資源(Delete Resource)</li>\n<li>按ID查找(Find by Id)</li>\n<li>詢問(Query)</li>\n</ul>\n</li>\n<li><strong>權限管理端點(Permission Management)</strong><ul>\n<li>發行許可票(Issue Permission Tickets)</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>默認情況下，遠程資源管理為啟用狀態。您可以使用Keycloak管理控制台進行更改，並且僅允許通過控制台進行資源管理。 </p>\n</blockquote>\n<h2 id=\"實例演練\"><a href=\"#實例演練\" class=\"headerlink\" title=\"實例演練\"></a>實例演練</h2><p>以下是我們要設置的方案:</p>\n<ol>\n<li>新建一個Realm: <code>authorization-demo</code></li>\n<li>在此Realm下，新建一個Client: <code>bank-client</code></li>\n<li>定義一個<code>/account/&#123;id&#125;</code>為該Client下的一個Resource</li>\n<li>在<code>/account/&#123;id&#125;</code>這個Resource下，有此 <code>account::view</code> Scope</li>\n<li>建立一個User: <code>bob</code></li>\n<li>建立三個角色: <code>bank_teller</code>、<code>account_owner</code>和<code>user</code></li>\n<li>我們將設置以下兩個<strong>Role-base</strong> policies:<ul>\n<li><code>bank_teller</code>跟<code>account_owner</code>有權訪問<code>/account/&#123;id&#125;</code> Resource</li>\n<li><code>account_owner</code>有權使用<code>account:view</code>Scope</li>\n<li><code>user</code> 無權訪問任何Resource或Scope</li>\n</ul>\n</li>\n<li>使用keycloak內建的<code>Evaluate</code>工具來測試授予或拒絕訪問權限。</li>\n</ol>\n<h3 id=\"配置Keycloak\"><a href=\"#配置Keycloak\" class=\"headerlink\" title=\"配置Keycloak\"></a>配置Keycloak</h3><p>基本配置內容可參閱<a href=\"/2021/01/09/spring/spring-boot-with-keycloak\">上篇文章</a></p>\n<h3 id=\"建立Realm\"><a href=\"#建立Realm\" class=\"headerlink\" title=\"建立Realm\"></a>建立Realm</h3><ol>\n<li>將鼠標停在左上<code>master</code>，然後單擊<code>Add Realm</code>按鈕。</li>\n<li>輸入<code>authorization-demo</code>作為名稱。</li>\n<li>點擊Create。</li>\n<li>確認左上角Realm在authorization-demo而不是master領域。</li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/05-add-realm.png\" alt=\"建立Realm: authorization-demo\"></p>\n<h3 id=\"建立User\"><a href=\"#建立User\" class=\"headerlink\" title=\"建立User\"></a>建立User</h3><ol>\n<li>點擊左側的<code>Users</code>選單</li>\n<li>點擊<code>Add User</code>按鈕</li>\n<li>輸入<code>username</code>(例如<code>bob</code>)</li>\n<li>確保<code>User Enabled</code>為開啟狀態</li>\n<li>請點擊 <code>Save</code></li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/06-create-user.png\" alt=\"建立User: bob\"></p>\n<h3 id=\"建立Roles\"><a href=\"#建立Roles\" class=\"headerlink\" title=\"建立Roles\"></a>建立Roles</h3><ol>\n<li>點擊左側的<code>Roles</code>選單</li>\n<li>點擊<code>Add Role</code></li>\n<li>添加下列角色：<code>bank_teller</code>，<code>account_owner</code>和<code>user</code></li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/07-create-role-bank-teller.png\" alt=\"建立Role: bank_teier\"></p>\n<p><img src=\"/images/spring/keycloak-authorization-services/08-create-role-account-owner.png\" alt=\"建立Role: account_owner\"></p>\n<p><img src=\"/images/spring/keycloak-authorization-services/09-create-role-user.png\" alt=\"建立Role: user\"></p>\n<h3 id=\"建立Client\"><a href=\"#建立Client\" class=\"headerlink\" title=\"建立Client\"></a>建立Client</h3><ol>\n<li>點擊左側的<code>Clients</code>選單</li>\n<li>點擊 <code>Create</code></li>\n<li><code>Client ID</code>欄位輸入<code>bank-api</code></li>\n<li><code>Root URL</code>欄位輸入<code>http://127.0.0.1:8000/bank-api</code></li>\n<li>點擊<code>Save</code></li>\n<li>確保<code>Client Protocol</code>是<code>openid-connect</code></li>\n<li>更改<code>Access Type</code>為<code>confidential</code></li>\n<li>更改<code>Authorization Enabled</code>為<code>On</code></li>\n<li>向下滾動並點擊<code>Save</code>。<code>Authorization</code>應會顯示在上方</li>\n<li>點擊<code>Authorization</code>選項，然後再點擊<code>Settings</code></li>\n<li>確保將<code>Decision Strategy</code>設置為<code>Unanimous</code><ul>\n<li>這是 Resource server 的 Decision Strategy (決策策略)</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/10-create-client.png\" alt=\"建立Client: bank-api\"></p>\n<p><img src=\"/images/spring/keycloak-authorization-services/11-setting-client.png\" alt=\"更改Client設定\"></p>\n<p><img src=\"/images/spring/keycloak-authorization-services/12-client-authorization-setting.png\" alt=\"確保 Decision Strategy 為 Unanimous\"></p>\n<h3 id=\"補充-Decision-Strategy\"><a href=\"#補充-Decision-Strategy\" class=\"headerlink\" title=\"(補充) Decision Strategy\"></a>(補充) Decision Strategy</h3><blockquote>\n<p>This configurations changes how the policy evaluation engine decides whether or not a resource or scope should be granted based on the outcome from all evaluated permissions. Affirmative means that at least one permission must evaluate to a positive decision in order grant access to a resource and its scopes. Unanimous means that all permissions must evaluate to a positive decision in order for the final decision to be also positive. As an example, if two permissions for a same resource or scope are in conflict (one of them is granting access and the other is denying access), the permission to the resource or scope will be granted if the choosen strategy is Affirmative. Otherwise, a single deny from any permission will also deny access to the resource or scope.</p>\n</blockquote>\n<h3 id=\"建立自定義Scope\"><a href=\"#建立自定義Scope\" class=\"headerlink\" title=\"建立自定義Scope\"></a>建立自定義Scope</h3><ol>\n<li>點擊<code>Authorization</code>標籤</li>\n<li>點擊<code>Authorization Scopes</code> &rarr; <code>Create</code>彈出<code>Add Scope</code>頁面</li>\n<li>輸入<code>account:view</code>名稱，然後按Save。</li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/13-create-scope.png\" alt=\"建立Scope: account:view\"></p>\n<h3 id=\"建立自定義Resouce\"><a href=\"#建立自定義Resouce\" class=\"headerlink\" title=\"建立自定義Resouce\"></a>建立自定義Resouce</h3><ol>\n<li>點擊<code>Authorization</code>標籤</li>\n<li>點擊 <code>Resources</code></li>\n<li>點擊 <code>Create</code></li>\n<li><code>Name</code>和<code>Display name</code>輸入<code>View Account Resource</code></li>\n<li><code>URI</code>輸入<code>/account/&#123;id&#125;</code></li>\n<li>在<code>Scopes</code>輸入<code>account:view</code></li>\n<li>點擊<code>Save</code></li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/14-create-resource.png\" alt=\"建立Resource: View Account Resource\"></p>\n<p>更多內容可參閱<a href=\"https://www.keycloak.org/docs/latest/authorization_services/#_resource_create\">Create Resources</a></p>\n<h3 id=\"建立Policies-重要\"><a href=\"#建立Policies-重要\" class=\"headerlink\" title=\"建立Policies(重要)\"></a>建立Policies(重要)</h3><h4 id=\"Create-Only-Bank-Teller-and-Account-Owner-Policy\"><a href=\"#Create-Only-Bank-Teller-and-Account-Owner-Policy\" class=\"headerlink\" title=\"Create Only Bank Teller and Account Owner Policy\"></a>Create Only Bank Teller and Account Owner Policy</h4><ol>\n<li>在<code>Authorization</code>標籤下，點擊<code>Policies</code></li>\n<li>從<code>Create Policy</code>下拉選單中選擇<code>Role</code></li>\n<li>在<code>Name</code>輸入<code>Only Bank Teller and Account Owner Policy</code></li>\n<li>在<code>Realm Roles</code>選擇<code>bank_teller</code>和<code>account_owner</code>角色並加入</li>\n<li>確保<code>Logic</code>設置為<code>Positive</code></li>\n<li>請點擊 <code>Save</code></li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/15-create-role-based-policy-1.png\" alt=\"建立Role Policy: Only Bank Teller and Account Owner Policy\"></p>\n<h4 id=\"Create-Only-Account-Owner-Policy\"><a href=\"#Create-Only-Account-Owner-Policy\" class=\"headerlink\" title=\"Create Only Account Owner Policy\"></a>Create Only Account Owner Policy</h4><ol>\n<li>再次點擊<code>Policies</code></li>\n<li>再次從<code>Create Policy</code>下拉選單中選擇<code>Role</code></li>\n<li>這次在<code>Name</code>輸入<code>Only Account Owner Policy</code></li>\n<li>這次在<code>Realm Roles</code>下選擇<code>account_owner</code></li>\n<li>確保<code>Logic</code>設置為<code>Positive</code></li>\n<li>請點擊 <code>Save</code></li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/16-create-role-based-policy-1.png\" alt=\"建立Role Policy: Only Account Owner Policy\"></p>\n<p>更多內容請參閱<a href=\"https://www.keycloak.org/docs/latest/authorization_services/#_policy_rbac\">Role-Based Policy</a></p>\n<p>其他Policy可參閱<a href=\"https://www.keycloak.org/docs/latest/authorization_services/#_policy_overview\">Managing Policies</a></p>\n<h3 id=\"建立-Resource-Based-Permission\"><a href=\"#建立-Resource-Based-Permission\" class=\"headerlink\" title=\"建立 Resource-Based Permission\"></a>建立 Resource-Based Permission</h3><ol>\n<li>再次在<code>Authorization</code>標籤下，點擊<code>Permissions</code></li>\n<li>選擇 <code>Resource-Based</code></li>\n<li><code>Name</code>欄位輸入<code>View Account Resource Permission</code></li>\n<li><code>Resources</code>欄位輸入<code>View Account Resource</code></li>\n<li><code>Apply Policy</code>下<code>Only Bank Teller and Account Owner Policy</code></li>\n<li>確保<code>Decision Strategy</code>設置為<code>Unanimous</code></li>\n<li>點擊<code>Save</code></li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/17-create-resource-base-permission.png\" alt=\"建立Resource-Based Permission: View Account Resource Permission\"></p>\n<h3 id=\"Evaluating-the-Resource-Based-permission\"><a href=\"#Evaluating-the-Resource-Based-permission\" class=\"headerlink\" title=\"Evaluating the Resource-Based permission\"></a>Evaluating the Resource-Based permission</h3><ol>\n<li><p>再次在<code>Authorization</code>標籤下，選擇<code>Evaluate</code></p>\n</li>\n<li><p>在<code>User</code>輸入<code>bob</code></p>\n</li>\n<li><p>在<code>Roles</code>選擇<code>user</code></p>\n<ul>\n<li>我們在這將User與我們創建的Role做關聯。</li>\n</ul>\n</li>\n<li><p>在<code>Resources</code>下選擇<code>View Account Resource</code>，然後點擊<code>Add</code></p>\n</li>\n<li><p>點擊<code>Evaluate</code></p>\n<p><img src=\"/images/spring/keycloak-authorization-services/18-Evaluating-the-Resource-Based-permission.png\" alt=\"使用Authorization裡的Evaluate測試權限設置是否生效\"></p>\n</li>\n<li><p>展開<code>View Account Resource with scopes [account:view]</code>以查看結果，應該看到<code>DENY</code>。</p>\n<!-- ![](/images/spring/keycloak-authorization-services/19-Evaluating-the-Resource-Based-permission-2.png) -->\n\n<p><img src=\"/images/spring/keycloak-authorization-services/20-Evaluating-the-Resource-Based-permission-result-1.png\" alt=\"Role: user得到DENY結果\"></p>\n</li>\n<li><p>此部份的驗證是對的，因為在上方我們建立的一個只允許兩個角色訪問該Resource: <code>Only Bank Teller and Account Owner Policy</code>Policy</p>\n</li>\n<li><p>點擊<code>Back</code>回到<code>Evaluate</code>頁面</p>\n</li>\n<li><p>將<code>bob</code>的角色更改為<code>account_owner</code>，然後點擊<code>Evaluate</code>。現在，應該看到結果為<code>PERMIT</code>。將角色更改為<code>bank_teller</code>，也是同樣結果。</p>\n</li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/21-Evaluating-the-Resource-Based-permission-result-2.png\" alt=\"Role: account_owner得到PERMIT結果\"></p>\n<p>更多內容請參閱<a href=\"https://www.keycloak.org/docs/latest/authorization_services/#_policy_evaluation_overview\">Evaluating and Testing Policies</a></p>\n<h3 id=\"建立-Scope-Based-Permission\"><a href=\"#建立-Scope-Based-Permission\" class=\"headerlink\" title=\"建立 Scope-Based Permission\"></a>建立 Scope-Based Permission</h3><ol>\n<li><p>返回<code>Permissions</code>標籤</p>\n</li>\n<li><p>在<code>Create Permission</code>下拉選單中選擇<code>Scope-Based</code></p>\n</li>\n<li><p><code>Name</code>輸入<code>View Account Scope Permission</code></p>\n</li>\n<li><p><code>Scopes</code>輸入<code>account:view</code></p>\n</li>\n<li><p><code>Apply Policy</code>輸入<code>Only Account Owner Policy</code></p>\n</li>\n<li><p>確保<code>Decision Strategy</code>設置為<code>Unanimous</code></p>\n</li>\n<li><p>點擊<code>Save</code></p>\n<p><img src=\"/images/spring/keycloak-authorization-services/22-create-scope-based.png\" alt=\"建立Scope-Based Permission: View Account Scope Permission\"></p>\n</li>\n</ol>\n<p>更多內容請參閱<a href=\"https://www.keycloak.org/docs/latest/authorization_services/index.html#_permission_create_scope\">Creating Scope-Based Permissions</a></p>\n<h3 id=\"Evaluating-the-Scope-Based-permission\"><a href=\"#Evaluating-the-Scope-Based-permission\" class=\"headerlink\" title=\"Evaluating the Scope-Based permission\"></a>Evaluating the Scope-Based permission</h3><ol>\n<li><p>再次點擊<code>Evaluate</code>標籤</p>\n</li>\n<li><p>在<code>User</code>輸入<code>bob</code></p>\n</li>\n<li><p>在<code>Roles</code>選擇<code>bank_teller</code></p>\n</li>\n<li><p>在<code>Resources</code>下選擇<code>View Account Resource</code>，然後點擊<code>Add</code></p>\n</li>\n<li><p>點擊<code>Evaluate</code>，得到<code>DENY</code></p>\n<ul>\n<li>因為設置了<code>bank_teller</code>只可以訪問<code>resource</code>但不能訪問<code>scope</code> </li>\n<li>且Resource server的<code>Decision Strategy</code>設置為<code>Unanimous</code>，最後的決定是<code>DENY</code>。(訪問resource評估為true，但訪問scope評估為false，所以得到<code>DENY</code>)</li>\n</ul>\n<p><img src=\"/images/spring/keycloak-authorization-services/23-Evaluatioin-new-change-1.png\" alt=\"測試Role: bank_teller權限\"></p>\n<p><img src=\"/images/spring/keycloak-authorization-services/24-Evaluation-new-change-result-1.png\" alt=\"Role: bank_teller不能訪問Scope\"></p>\n</li>\n<li><p>回到<code>Authorization</code>下的<code>Settings</code>，然後將更<code>Decision Strategy</code>改為<code>Affirmative</code>，然後再次返回到步驟1-5。這次最終結果應該是<code>PERMIT</code>（其中一個權限為true，所以最終結果為true）。</p>\n<p><img src=\"/images/spring/keycloak-authorization-services/25-Evaluation-new-changet-2.png\" alt=\"修改Decision Strategy為Affirmative\"></p>\n<p><img src=\"/images/spring/keycloak-authorization-services/26-Evaluation-new-change-result-2.png\" alt=\"重新上述步驟1-5，得到PERMIT結果\"></p>\n</li>\n<li><p>為了完整起見，將resource server的<code>Decision Strategy</code>重新設置為<code>Unanimous</code>。重新實施步驟1至5，但這一次將角色設置為<code>account_owner</code>。鑑於<code>account_owner</code>可以同時訪問<code>resource</code>和<code>scope</code>，所以這次的結果<code>PERMIT</code>。</p>\n</li>\n</ol>\n<p><img src=\"/images/spring/keycloak-authorization-services/27-Evaluation-new-change-result-3.png\" alt=\"Role: account_owner可訪問Resource以及Scope\"></p>\n<h2 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h2><p>說明authorization policies原理，以及透過實例來建制流程</p>\n<ol>\n<li>先定義好scope</li>\n<li>再建立resource，再把resource跟scope建立關聯</li>\n<li>再建立policy(Role-Based、User-Based…)把resource與此policy關聯起來</li>\n<li>再建立Resource-Based Permission or Scope-Based Permission。把 Policy與resource or scope關聯起來</li>\n</ol>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><p><a href=\"https://www.keycloak.org/docs/latest/authorization_services/index.html\">https://www.keycloak.org/docs/latest/authorization_services/index.html</a></p>\n</li>\n<li><p><a href=\"https://stackoverflow.com/questions/42186537/resources-scopes-permissions-and-policies-in-keycloak\">https://stackoverflow.com/questions/42186537/resources-scopes-permissions-and-policies-in-keycloak</a></p>\n</li>\n</ul>"},{"title":"[Security]使用Keycloak保護Spring Boot REST服務","date":"2021-01-09T08:33:29.000Z","toc":true,"_content":"\n對於任何應用程序，安全性始終是主要的跨領域關注點。傳統上，我們過去在整體後端服務中只有一個安全層來保護所有前端應用程序請求。隨著新興的微服務架構的發展，不再有單一的後端服務。前端應用程序調用多個後端服務，這些服務又可以調用其他服務。不再有可以處理身份驗證的單層。由於微服務都具有許多較小的服務，每個服務都處理一個不同的職責，因此安全性的明顯解決方案是身份驗證和授權服務。這是Keycloak進行救援的地方，因為它提供了保護微服務所需的功能。\n\n<!-- more -->\n\n## 什麼是Keycloak\n\nKeycloak是Red Hat贊助的開源身份和訪問管理（IAM）解決方案。它使我們能夠保護各種現代的前端應用程序和後端服務。Keycloak可以毫不費力地為我們的應用程序和服務添加身份驗證和授權。我們不需要處理用戶的存儲或身份驗證，因為所有這些都可以在Keycloak中直接使用。\n\nKeycloak提供的功能包括單點登錄（SSO），身份代理和社交登錄，用戶聯合，客戶端適配器，管理員和用戶帳戶管理控制台。\n\n![圖片來源: keycloack官網](/images/spring/spring-boot-with-keycloak/01-keycloack-features.png)\n\n除了這些基本功能，Keycloak在其他IAM解決方案中脫穎而出的原因還在於其可定制的網頁和電子郵件模板主題，以及可擴展的功能和領域。可定制的主題很重要，因為它們使開發人員可以定制面向最終用戶的網頁的外觀，以便可以將其與應用程序緊密集成。Keycloak還提供了擴展其核心功能和範圍的功能。這包括可能：\n\n+ 將自定義REST端點添加到Keycloak服務器\n+ 添加 Server Provider Interface(SPI)\n+ 將自定義 Java Persistence API(JPA)實體添加到Keycloak數據模型中\n\n## 設置Keycloak\n\n以下安裝並運行Keycloak服務器\n\n1. 先確保要運行的機器有OpenJDK1.8或更高的版本\n2. [Keycloak官方網站](https://www.keycloak.org/downloads.html)下載最新的Keycloak realease版本\n\n### windows\n\n```shell=\nbin\\standalone.bat\n```\n\n### linux\n\n```shell=\nbin/standalone.sh\n```\n\nKeycloak默認使用**H2資料庫**儲存數據，位於`standalone/data`目錄中。\n\n此資料庫並不適用於Production環境，Keycloak官方強烈建議我們將其替換為更利於Productio環境的外部數據庫，例如PostgreSQL。\n\n可以從[官方文檔](https://www.keycloak.org/docs/latest/server_installation/#_database)中獲取有關設置Keycloak數據庫的更多詳細信息。\n\n### 建立初始化Admin User\n\nKeycloak不附帶**初始admin**用戶，這意味著在開始使用Keycloak之前，您需要創建一個admin用戶。\n\n打開[http://localhost:8080/auth](http://localhost:8080/auth)並填寫創建初始管理表單，用戶名為admin，密碼為password。\n\n![建立keycloack管理員帳號密碼](/images/spring/spring-boot-with-keycloak/02-init-admin-account.png)\n\n單擊創建並進入**admin console**，然後使用剛剛創建的admin登錄。\n\n![使用管理員帳號密碼登入keycloack](/images/spring/spring-boot-with-keycloak/03-admin-login.png)\n\n登錄後Keycloak顯示的第一個屏幕是**Master Realm**詳細信息。\n\n![keycloak登入後畫面](/images/spring/spring-boot-with-keycloak/04-master-realm-detail.png)\n\n+ Keycloak中的**realm**就像一個容器，其中包含並隔離user、role、group和client的集合。\n+ Keycloak帶有一個預先創建的Master realm。\n+ 建議不要使用Master realm管理組織中user和applicatio管理\n+ 創建和管理其他realm，為admin保留對Master realm的使用。\n\n![keycloack realm管理](/images/spring/spring-boot-with-keycloak/05-master-realm-manage-other-realm.png)\n\n### 建立Realms\n\n我們將需要一個realm來管理我們的Spring Boot REST服務使用的user，role和client。\n\n因此，讓我們建立第一個realm。\n\n將鼠標懸停在左上角顯示\"Master\"的下拉菜單上，然後單擊\"Add realm\"按鈕。\n\n![左側菜單選取Realm Settings頁面](/images/spring/spring-boot-with-keycloak/06-create-realm-in-menu.png)\n\n我們將第一個realm命名為demo：\n\n![建立realm: demo](/images/spring/spring-boot-with-keycloak/07-create-realm.png)\n\n點擊create，將會被定向到創建的realm詳細信息頁面，可以在這進一步配置realm。\n\n![realm詳細信息頁面](/images/spring/spring-boot-with-keycloak/08-realm-detail.png)\n\n### 建立Roles\n\nrole對user進行分類。在應用程序中，**訪問資源的權限通常授予role而不是user**。\n\nAdmin、User和Manager都是組織中可能存在的典型角色。\n\n要建立role，請單擊左側的\"Roles\"，然後點擊頁面上的\"Add Role\"按鈕。\n\n![左側菜單選取Roles頁面](/images/spring/spring-boot-with-keycloak/09-role-page.png)\n\n我們將role命名為spring-user，然後點擊save。\n\n![建立role: spring-user](/images/spring/spring-boot-with-keycloak/10-create-spring-user-role.png)\n\n### 建立Users\n\n#### 建立User基本資料\n\n單擊左側的\"Users\"，然後點擊\"Add User\"按鈕。\n\n![左側菜單選取Users頁面](/images/spring/spring-boot-with-keycloak/11-user-page.png)\n\n將username填寫為Steven`(登入的account)`，將First Name填寫為Steven，並保留其他所有默認設置。\n\n確保\"User Enabled\"為\"on\"。點擊save建立第一個user\n\n![建立user: Steven](/images/spring/spring-boot-with-keycloak/12-create-user.png)\n\n#### 為User設置密碼\n\nSteven需要密碼才能登錄Keycloak，所以需要為Steven創建一個密碼。\n\n點擊\"Credentials\"標籤，然後在密碼和確認密碼輸入*mypassword*。\n\n且設置**Temporary**為**OFF**，以便在下次登錄時無需更改密碼。\n\n點擊\"Set Password\"以保存Steven的密碼憑證。\n\n![設定Steven登入密碼](/images/spring/spring-boot-with-keycloak/13-user-set-password.png)\n\n#### 分配Role給User\n\n將之前創建的role: `spring-user`分配給Steven。\n\n為此，請點擊\"Role Mappings\"選項，選擇spring-user角色，然後點擊\"Add Selected\"。\n\n![分配spring-user角色給Steven](/images/spring/spring-boot-with-keycloak/14-user-mapping-role.png)\n\n### 建立Clients\n\n#### Client基本資料建立\n\n> Clients are entities that will request the authentication of a user.\n\nClient有兩種形式。\n\n1. 第一種類型的Client是想要參與SSO的應用程式，這些Client只希望Keycloak為他們提供安全性。\n2. 另一種Client是請求訪問令牌的Client，以便它可以代表已認證的用戶調用其他服務。\n\n我們將創建一個Client用於保護我們的Spring Boot REST服務。\n\n點擊左側的\"**Clients**\"，然後點選\"**Create**\"。\n\n![左側菜單選取Clients頁面](/images/spring/spring-boot-with-keycloak/15-client-page.png)\n\n在表單中，將Client Id填寫為**spring-boot**，為Client Protocol選擇**OpenID Connect**，接著點選Save。\n\n![建立一個新的Client: spring-boot](/images/spring/spring-boot-with-keycloak/16-create-client.png)\n\n#### 更改Access Type及Authorization Enabled\n\n在Client的Settings頁面中，我們需要將**Access Type**更改為`confidential`，而不是默認的`public`(不需要Client Secret)。存檔之前，請打開\"**Authorization Enabled**\"開關。\n\n![修改Client Access Type為confidential](/images/spring/spring-boot-with-keycloak/17-client-detail-settings.png)\n\n#### Client Secret\n\n在Client的Credentials頁面中，先將Secret內容複製出來，下面內容會使用到\n\n![複製Client Secret](/images/spring/spring-boot-with-keycloak/18-clientsecret.png)\n\n### 拿取Access Token\n\nClient通過使用HTTP POST方法向Keycloak中的Token endpoint發出**Token交換請求**來請求安全令牌。\n\n```shell=\n/auth/realms/{realm}/protocol/openid-connect/token\n```\n\n+ Keycloak中的Token交換請求是[IETF](https://tools.ietf.org/html/rfc8693)上**OAuth 2.0Token交換**規範的寬鬆實現。\n+ **OpenID Connect** Token endpoint 上的簡單授予類型調用。\n+ Keycloak使用\"**application/x-www-form-urlencoded**\"格式和UTF-8字符編碼來接受HTTP請求實體中的參數。\n\n打開Postman，建立對`http://localhost:8080/auth/realms/demo/protocol/openid-connect/token` POST請求\n\n![使用client_id、client_secret、Steven帳密進行登入](/images/spring/spring-boot-with-keycloak/19-accesstoken-request.png)\n\n會收到帶有**Access Token**和**Refresh Token**以及其他附帶詳細信息的JSON Response。\n\n![Access Token 及 Refresh Token 的 Response 格式](/images/spring/spring-boot-with-keycloak/20-accesstoken-response.png)\n\n將接收到的Access Token作為Bearer Token放置在Authorization Header中，就可以在受到Keycloak安全保護的REST API進行請求:\n\n```shell=\nheaders: {\n     'Authorization': 'Bearer ' + {access_token}\n }\n```\n\n從Keycloak的**Admin console**中，進到spring-boot的Client詳細資訊，然後點選\"**Sessions**\"選項。您將看到Steven的登錄session。\n\n![登入的 Session](/images/spring/spring-boot-with-keycloak/21-keycloak-sessions.png)\n\n點擊Steve進到User詳細資訊，然後點選\"Sessions\"選項。在\"Sessions\"選項卡下，有一些選項可用於**註銷**特定會話或**註銷所有會話**。\n\n![Session詳細訊息](/images/spring/spring-boot-with-keycloak/22-keycloak-usersessions.png)\n\n我們已經配置了Keycloak並能夠通過Postman請求Access Token，下一步是創建**Spring Boot REST服務**並使用Keycloak保護它。\n\n## 建立一個Spring Boot應用程序\n\n使用[Spring Initializr](https://start.spring.io/)網站生成具有Spring Boot 2.x依賴項的項目。還需要Spring Boot Starter Web 模塊\n\n![初始化 spring boot 專案](/images/spring/spring-boot-with-keycloak/23-Spring-Boot-Starter-Web.png)\n\n接下來，創建一個@RestController MessagingRestController Class，該Class將getMessage()方法公開為/user/message上的HTTP GET請求。此方法將返回\"Hello, User\"字串。\n\n```java=\n@RestController\npublic class MessagingRestController {\n\n  @GetMapping(path = \"/user/message\")\n  public String getUserMessage() {\n    return \"Hello, User\";\n  }\n}\n```\n\napplication.yaml中配置server.port\n\n```yaml=\nserver:\n  port: 8000\n```\n\n現在我們的REST服務已經可以運行了，我們需要使用Keycloak保護它。\n\n## 使用Keycloak保護Spring Boot REST服務\n\n為了保護您的Spring Boot REST服務，必須將Spring Boot的**Keycloak Adpater**添加到服務中。\n\nbuild.gradle\n\n```groovy=\next {\n  set('keycloakVersion', '12.0.1')\n}\n\ndependencyManagement {\n  imports {\n    mavenBom \"org.keycloak.bom:keycloak-adapter-bom:${keycloakVersion}\"\n  }\n}\n\ndependencies {\n  implementation 'org.keycloak:keycloak-spring-boot-starter'\n}\n```\n\n接著將keycloak相關內容配置到application.yaml\n\n```yaml=\nkeycloak:\n  auth-server-url: http://localhost:8080/auth\n  realm: demo\n  resource: spring-boot\n  credentials:\n    secret: 86ef845e-735a-42aa-84c7-fac294c359ad\n  bearer-only: true\n```\n\n+ auth-server-url: Keycloak服務器的URL\n+ realm: 在keycloak所建立的realm\n+ resource: 在keycloak所建立的Client Id\n+ secret: 在keycloak所建立的Client Secret\n+ only-bearer-only: 必須為true，以便Adpater不會嘗試對用戶進行身份驗證，而僅驗證Access Token\n\n再讓我們為應用程式增加security-constraints`(安全性約束)`。此配置非常重要，因為Keycloak Adapter將根據我們的配置允許或拒絕對我們資源的訪問請求\n\n下列例子為: 確保對URL:/user/*的每個請求，僅在該請求的用戶是具有spring-user角色的已認證用戶時才被授權使用。\n\n```yaml=\nkeycloak:\n  security-constraints:\n    - auth-roles:\n      - spring-user\n      security-collections:\n      - name: \n        patterns:\n        - /user/*\n```\n\n在運行服務之前，讓我們打開Keycloak的DEBUG日誌記錄級別，以在console中查看更多詳細信息。\n\n```yaml=\nlogging:\n  level:\n    org.keycloak: TRACE\n```\n\n### Test HTTP GET User Message\n\n#### Role spring-user\n\n打開postman，URL輸入`http://localhost:8000/user/message`，HTTP Method為GET\n再點擊\"Authorization\"標籤，然後選擇Bearer Token，將之前如下圖示中response的access_token貼上Token欄位裡。\n\n1. 使用者Steven驗證\n\n   ![Steven帳號密碼登入](/images/spring/spring-boot-with-keycloak/24-keycloak-steven'stoken.png)\n\n2. 將上圖的access_token，貼入下圖Token欄位中\n\n   ![將Access Token貼到postman的Bearer Token](/images/spring/spring-boot-with-keycloak/25-keycloak-accesstokeninbearertoken.png)\n\n3. 點選\"Send\"過後，會收到 \"Hello, User\" response\n\n![Response](/images/spring/spring-boot-with-keycloak/26-keycloak-Hello-user.png)\n\n在IDE Console中，會看到keycloak日誌紀錄\n\n![IDE Console](/images/spring/spring-boot-with-keycloak/27-keycloak-console.png)\n\n#### Role spring-admin\n\n我們將使用新role和user對Keycloak進行更多配置，以演示我們為其他請求URL定義安全約束。\n\n回到keycloak admin console，建立一個新的Role: `spring-admin`\n\n![建立Role: spring-admin](/images/spring/spring-boot-with-keycloak/28-keycloak-role-springadmin.png)\n\n建立新的User: **Dave**並設置密碼，且授予**spring-admin**角色\n\n![建立User: Dave](/images/spring/spring-boot-with-keycloak/29-keycloak-userdave.png)\n\n![將 spring-admin 角色給予 Dave](/images/spring/spring-boot-with-keycloak/30-keycloak-daverolemapping.png)\n\n回到spring應用程式中，建立一個getAdminMessage endpoint\n\n```java=\n@GetMapping(path = \"/admin/message\")\npublic String getAdminMessage() {\n  return \"Hello, Admin\";\n}\n```\n\n最後，向我們的應用程序添加另一個安全約束，以授權具有spring-admin角色的用戶訪問URL /admin/*請求。\n\n```yaml=\nkeycloak:\n  security-constraints:\n    - auth-roles:\n        - spring-user\n      security-collections:\n        - name:\n          patterns:\n            - /user/*\n    - auth-roles:\n        - spring-admin\n      security-collections:\n        - name:\n          patterns:\n            - /user/*\n            - /admin/*\n```\n\n現在我們使用Steven的token對/admin/message進行請求\n\n此請求被拒絕，因為我們尚未授予spring-user角色訪問請求/admin/*的權限。\n![Role: spring-User 不能訪問 Role: spring-admin 頁面](/images/spring/spring-boot-with-keycloak/31-keycloak-steve-nnoadmin.png)\n\n讓我們換回用Dave的token，來對/admin/message進行請求，將能成功進行請求\n![Dave帳號密碼登入](/images/spring/spring-boot-with-keycloak/32-keycloak-davegetaccesstoen.png)\n\n![Role: spring-admin 可正常訪問 spring-admin 頁面](/images/spring/spring-boot-with-keycloak/33-keycloak-davecanaccessadminendpoint.png)\n\n## 結論\n\n+ 了解到Keycloak是一個現代的身份和訪問管理系統，提供了許多現成的功能。\n+ 還學習瞭如何使用realm、role、User和Client來設置Keycloak。\n+ 最後，我們學習如何配置Spring Boot REST服務以利用Keycloak認證和授權所有請求。\n\n## 參考資料\n\n+ <https://codeburst.io/securing-spring-boot-rest-services-using-keycloak-without-writing-code-7c47ab72fb9d>\n","source":"_posts/spring/spring-boot-with-keycloak.md","raw":"---\ntitle: '[Security]使用Keycloak保護Spring Boot REST服務'\ndate: 2021-01-09 16:33:29\ntags:\n  - spring\n  - keycloak\ncategories: 工作\ntoc: true\n---\n\n對於任何應用程序，安全性始終是主要的跨領域關注點。傳統上，我們過去在整體後端服務中只有一個安全層來保護所有前端應用程序請求。隨著新興的微服務架構的發展，不再有單一的後端服務。前端應用程序調用多個後端服務，這些服務又可以調用其他服務。不再有可以處理身份驗證的單層。由於微服務都具有許多較小的服務，每個服務都處理一個不同的職責，因此安全性的明顯解決方案是身份驗證和授權服務。這是Keycloak進行救援的地方，因為它提供了保護微服務所需的功能。\n\n<!-- more -->\n\n## 什麼是Keycloak\n\nKeycloak是Red Hat贊助的開源身份和訪問管理（IAM）解決方案。它使我們能夠保護各種現代的前端應用程序和後端服務。Keycloak可以毫不費力地為我們的應用程序和服務添加身份驗證和授權。我們不需要處理用戶的存儲或身份驗證，因為所有這些都可以在Keycloak中直接使用。\n\nKeycloak提供的功能包括單點登錄（SSO），身份代理和社交登錄，用戶聯合，客戶端適配器，管理員和用戶帳戶管理控制台。\n\n![圖片來源: keycloack官網](/images/spring/spring-boot-with-keycloak/01-keycloack-features.png)\n\n除了這些基本功能，Keycloak在其他IAM解決方案中脫穎而出的原因還在於其可定制的網頁和電子郵件模板主題，以及可擴展的功能和領域。可定制的主題很重要，因為它們使開發人員可以定制面向最終用戶的網頁的外觀，以便可以將其與應用程序緊密集成。Keycloak還提供了擴展其核心功能和範圍的功能。這包括可能：\n\n+ 將自定義REST端點添加到Keycloak服務器\n+ 添加 Server Provider Interface(SPI)\n+ 將自定義 Java Persistence API(JPA)實體添加到Keycloak數據模型中\n\n## 設置Keycloak\n\n以下安裝並運行Keycloak服務器\n\n1. 先確保要運行的機器有OpenJDK1.8或更高的版本\n2. [Keycloak官方網站](https://www.keycloak.org/downloads.html)下載最新的Keycloak realease版本\n\n### windows\n\n```shell=\nbin\\standalone.bat\n```\n\n### linux\n\n```shell=\nbin/standalone.sh\n```\n\nKeycloak默認使用**H2資料庫**儲存數據，位於`standalone/data`目錄中。\n\n此資料庫並不適用於Production環境，Keycloak官方強烈建議我們將其替換為更利於Productio環境的外部數據庫，例如PostgreSQL。\n\n可以從[官方文檔](https://www.keycloak.org/docs/latest/server_installation/#_database)中獲取有關設置Keycloak數據庫的更多詳細信息。\n\n### 建立初始化Admin User\n\nKeycloak不附帶**初始admin**用戶，這意味著在開始使用Keycloak之前，您需要創建一個admin用戶。\n\n打開[http://localhost:8080/auth](http://localhost:8080/auth)並填寫創建初始管理表單，用戶名為admin，密碼為password。\n\n![建立keycloack管理員帳號密碼](/images/spring/spring-boot-with-keycloak/02-init-admin-account.png)\n\n單擊創建並進入**admin console**，然後使用剛剛創建的admin登錄。\n\n![使用管理員帳號密碼登入keycloack](/images/spring/spring-boot-with-keycloak/03-admin-login.png)\n\n登錄後Keycloak顯示的第一個屏幕是**Master Realm**詳細信息。\n\n![keycloak登入後畫面](/images/spring/spring-boot-with-keycloak/04-master-realm-detail.png)\n\n+ Keycloak中的**realm**就像一個容器，其中包含並隔離user、role、group和client的集合。\n+ Keycloak帶有一個預先創建的Master realm。\n+ 建議不要使用Master realm管理組織中user和applicatio管理\n+ 創建和管理其他realm，為admin保留對Master realm的使用。\n\n![keycloack realm管理](/images/spring/spring-boot-with-keycloak/05-master-realm-manage-other-realm.png)\n\n### 建立Realms\n\n我們將需要一個realm來管理我們的Spring Boot REST服務使用的user，role和client。\n\n因此，讓我們建立第一個realm。\n\n將鼠標懸停在左上角顯示\"Master\"的下拉菜單上，然後單擊\"Add realm\"按鈕。\n\n![左側菜單選取Realm Settings頁面](/images/spring/spring-boot-with-keycloak/06-create-realm-in-menu.png)\n\n我們將第一個realm命名為demo：\n\n![建立realm: demo](/images/spring/spring-boot-with-keycloak/07-create-realm.png)\n\n點擊create，將會被定向到創建的realm詳細信息頁面，可以在這進一步配置realm。\n\n![realm詳細信息頁面](/images/spring/spring-boot-with-keycloak/08-realm-detail.png)\n\n### 建立Roles\n\nrole對user進行分類。在應用程序中，**訪問資源的權限通常授予role而不是user**。\n\nAdmin、User和Manager都是組織中可能存在的典型角色。\n\n要建立role，請單擊左側的\"Roles\"，然後點擊頁面上的\"Add Role\"按鈕。\n\n![左側菜單選取Roles頁面](/images/spring/spring-boot-with-keycloak/09-role-page.png)\n\n我們將role命名為spring-user，然後點擊save。\n\n![建立role: spring-user](/images/spring/spring-boot-with-keycloak/10-create-spring-user-role.png)\n\n### 建立Users\n\n#### 建立User基本資料\n\n單擊左側的\"Users\"，然後點擊\"Add User\"按鈕。\n\n![左側菜單選取Users頁面](/images/spring/spring-boot-with-keycloak/11-user-page.png)\n\n將username填寫為Steven`(登入的account)`，將First Name填寫為Steven，並保留其他所有默認設置。\n\n確保\"User Enabled\"為\"on\"。點擊save建立第一個user\n\n![建立user: Steven](/images/spring/spring-boot-with-keycloak/12-create-user.png)\n\n#### 為User設置密碼\n\nSteven需要密碼才能登錄Keycloak，所以需要為Steven創建一個密碼。\n\n點擊\"Credentials\"標籤，然後在密碼和確認密碼輸入*mypassword*。\n\n且設置**Temporary**為**OFF**，以便在下次登錄時無需更改密碼。\n\n點擊\"Set Password\"以保存Steven的密碼憑證。\n\n![設定Steven登入密碼](/images/spring/spring-boot-with-keycloak/13-user-set-password.png)\n\n#### 分配Role給User\n\n將之前創建的role: `spring-user`分配給Steven。\n\n為此，請點擊\"Role Mappings\"選項，選擇spring-user角色，然後點擊\"Add Selected\"。\n\n![分配spring-user角色給Steven](/images/spring/spring-boot-with-keycloak/14-user-mapping-role.png)\n\n### 建立Clients\n\n#### Client基本資料建立\n\n> Clients are entities that will request the authentication of a user.\n\nClient有兩種形式。\n\n1. 第一種類型的Client是想要參與SSO的應用程式，這些Client只希望Keycloak為他們提供安全性。\n2. 另一種Client是請求訪問令牌的Client，以便它可以代表已認證的用戶調用其他服務。\n\n我們將創建一個Client用於保護我們的Spring Boot REST服務。\n\n點擊左側的\"**Clients**\"，然後點選\"**Create**\"。\n\n![左側菜單選取Clients頁面](/images/spring/spring-boot-with-keycloak/15-client-page.png)\n\n在表單中，將Client Id填寫為**spring-boot**，為Client Protocol選擇**OpenID Connect**，接著點選Save。\n\n![建立一個新的Client: spring-boot](/images/spring/spring-boot-with-keycloak/16-create-client.png)\n\n#### 更改Access Type及Authorization Enabled\n\n在Client的Settings頁面中，我們需要將**Access Type**更改為`confidential`，而不是默認的`public`(不需要Client Secret)。存檔之前，請打開\"**Authorization Enabled**\"開關。\n\n![修改Client Access Type為confidential](/images/spring/spring-boot-with-keycloak/17-client-detail-settings.png)\n\n#### Client Secret\n\n在Client的Credentials頁面中，先將Secret內容複製出來，下面內容會使用到\n\n![複製Client Secret](/images/spring/spring-boot-with-keycloak/18-clientsecret.png)\n\n### 拿取Access Token\n\nClient通過使用HTTP POST方法向Keycloak中的Token endpoint發出**Token交換請求**來請求安全令牌。\n\n```shell=\n/auth/realms/{realm}/protocol/openid-connect/token\n```\n\n+ Keycloak中的Token交換請求是[IETF](https://tools.ietf.org/html/rfc8693)上**OAuth 2.0Token交換**規範的寬鬆實現。\n+ **OpenID Connect** Token endpoint 上的簡單授予類型調用。\n+ Keycloak使用\"**application/x-www-form-urlencoded**\"格式和UTF-8字符編碼來接受HTTP請求實體中的參數。\n\n打開Postman，建立對`http://localhost:8080/auth/realms/demo/protocol/openid-connect/token` POST請求\n\n![使用client_id、client_secret、Steven帳密進行登入](/images/spring/spring-boot-with-keycloak/19-accesstoken-request.png)\n\n會收到帶有**Access Token**和**Refresh Token**以及其他附帶詳細信息的JSON Response。\n\n![Access Token 及 Refresh Token 的 Response 格式](/images/spring/spring-boot-with-keycloak/20-accesstoken-response.png)\n\n將接收到的Access Token作為Bearer Token放置在Authorization Header中，就可以在受到Keycloak安全保護的REST API進行請求:\n\n```shell=\nheaders: {\n     'Authorization': 'Bearer ' + {access_token}\n }\n```\n\n從Keycloak的**Admin console**中，進到spring-boot的Client詳細資訊，然後點選\"**Sessions**\"選項。您將看到Steven的登錄session。\n\n![登入的 Session](/images/spring/spring-boot-with-keycloak/21-keycloak-sessions.png)\n\n點擊Steve進到User詳細資訊，然後點選\"Sessions\"選項。在\"Sessions\"選項卡下，有一些選項可用於**註銷**特定會話或**註銷所有會話**。\n\n![Session詳細訊息](/images/spring/spring-boot-with-keycloak/22-keycloak-usersessions.png)\n\n我們已經配置了Keycloak並能夠通過Postman請求Access Token，下一步是創建**Spring Boot REST服務**並使用Keycloak保護它。\n\n## 建立一個Spring Boot應用程序\n\n使用[Spring Initializr](https://start.spring.io/)網站生成具有Spring Boot 2.x依賴項的項目。還需要Spring Boot Starter Web 模塊\n\n![初始化 spring boot 專案](/images/spring/spring-boot-with-keycloak/23-Spring-Boot-Starter-Web.png)\n\n接下來，創建一個@RestController MessagingRestController Class，該Class將getMessage()方法公開為/user/message上的HTTP GET請求。此方法將返回\"Hello, User\"字串。\n\n```java=\n@RestController\npublic class MessagingRestController {\n\n  @GetMapping(path = \"/user/message\")\n  public String getUserMessage() {\n    return \"Hello, User\";\n  }\n}\n```\n\napplication.yaml中配置server.port\n\n```yaml=\nserver:\n  port: 8000\n```\n\n現在我們的REST服務已經可以運行了，我們需要使用Keycloak保護它。\n\n## 使用Keycloak保護Spring Boot REST服務\n\n為了保護您的Spring Boot REST服務，必須將Spring Boot的**Keycloak Adpater**添加到服務中。\n\nbuild.gradle\n\n```groovy=\next {\n  set('keycloakVersion', '12.0.1')\n}\n\ndependencyManagement {\n  imports {\n    mavenBom \"org.keycloak.bom:keycloak-adapter-bom:${keycloakVersion}\"\n  }\n}\n\ndependencies {\n  implementation 'org.keycloak:keycloak-spring-boot-starter'\n}\n```\n\n接著將keycloak相關內容配置到application.yaml\n\n```yaml=\nkeycloak:\n  auth-server-url: http://localhost:8080/auth\n  realm: demo\n  resource: spring-boot\n  credentials:\n    secret: 86ef845e-735a-42aa-84c7-fac294c359ad\n  bearer-only: true\n```\n\n+ auth-server-url: Keycloak服務器的URL\n+ realm: 在keycloak所建立的realm\n+ resource: 在keycloak所建立的Client Id\n+ secret: 在keycloak所建立的Client Secret\n+ only-bearer-only: 必須為true，以便Adpater不會嘗試對用戶進行身份驗證，而僅驗證Access Token\n\n再讓我們為應用程式增加security-constraints`(安全性約束)`。此配置非常重要，因為Keycloak Adapter將根據我們的配置允許或拒絕對我們資源的訪問請求\n\n下列例子為: 確保對URL:/user/*的每個請求，僅在該請求的用戶是具有spring-user角色的已認證用戶時才被授權使用。\n\n```yaml=\nkeycloak:\n  security-constraints:\n    - auth-roles:\n      - spring-user\n      security-collections:\n      - name: \n        patterns:\n        - /user/*\n```\n\n在運行服務之前，讓我們打開Keycloak的DEBUG日誌記錄級別，以在console中查看更多詳細信息。\n\n```yaml=\nlogging:\n  level:\n    org.keycloak: TRACE\n```\n\n### Test HTTP GET User Message\n\n#### Role spring-user\n\n打開postman，URL輸入`http://localhost:8000/user/message`，HTTP Method為GET\n再點擊\"Authorization\"標籤，然後選擇Bearer Token，將之前如下圖示中response的access_token貼上Token欄位裡。\n\n1. 使用者Steven驗證\n\n   ![Steven帳號密碼登入](/images/spring/spring-boot-with-keycloak/24-keycloak-steven'stoken.png)\n\n2. 將上圖的access_token，貼入下圖Token欄位中\n\n   ![將Access Token貼到postman的Bearer Token](/images/spring/spring-boot-with-keycloak/25-keycloak-accesstokeninbearertoken.png)\n\n3. 點選\"Send\"過後，會收到 \"Hello, User\" response\n\n![Response](/images/spring/spring-boot-with-keycloak/26-keycloak-Hello-user.png)\n\n在IDE Console中，會看到keycloak日誌紀錄\n\n![IDE Console](/images/spring/spring-boot-with-keycloak/27-keycloak-console.png)\n\n#### Role spring-admin\n\n我們將使用新role和user對Keycloak進行更多配置，以演示我們為其他請求URL定義安全約束。\n\n回到keycloak admin console，建立一個新的Role: `spring-admin`\n\n![建立Role: spring-admin](/images/spring/spring-boot-with-keycloak/28-keycloak-role-springadmin.png)\n\n建立新的User: **Dave**並設置密碼，且授予**spring-admin**角色\n\n![建立User: Dave](/images/spring/spring-boot-with-keycloak/29-keycloak-userdave.png)\n\n![將 spring-admin 角色給予 Dave](/images/spring/spring-boot-with-keycloak/30-keycloak-daverolemapping.png)\n\n回到spring應用程式中，建立一個getAdminMessage endpoint\n\n```java=\n@GetMapping(path = \"/admin/message\")\npublic String getAdminMessage() {\n  return \"Hello, Admin\";\n}\n```\n\n最後，向我們的應用程序添加另一個安全約束，以授權具有spring-admin角色的用戶訪問URL /admin/*請求。\n\n```yaml=\nkeycloak:\n  security-constraints:\n    - auth-roles:\n        - spring-user\n      security-collections:\n        - name:\n          patterns:\n            - /user/*\n    - auth-roles:\n        - spring-admin\n      security-collections:\n        - name:\n          patterns:\n            - /user/*\n            - /admin/*\n```\n\n現在我們使用Steven的token對/admin/message進行請求\n\n此請求被拒絕，因為我們尚未授予spring-user角色訪問請求/admin/*的權限。\n![Role: spring-User 不能訪問 Role: spring-admin 頁面](/images/spring/spring-boot-with-keycloak/31-keycloak-steve-nnoadmin.png)\n\n讓我們換回用Dave的token，來對/admin/message進行請求，將能成功進行請求\n![Dave帳號密碼登入](/images/spring/spring-boot-with-keycloak/32-keycloak-davegetaccesstoen.png)\n\n![Role: spring-admin 可正常訪問 spring-admin 頁面](/images/spring/spring-boot-with-keycloak/33-keycloak-davecanaccessadminendpoint.png)\n\n## 結論\n\n+ 了解到Keycloak是一個現代的身份和訪問管理系統，提供了許多現成的功能。\n+ 還學習瞭如何使用realm、role、User和Client來設置Keycloak。\n+ 最後，我們學習如何配置Spring Boot REST服務以利用Keycloak認證和授權所有請求。\n\n## 參考資料\n\n+ <https://codeburst.io/securing-spring-boot-rest-services-using-keycloak-without-writing-code-7c47ab72fb9d>\n","slug":"spring/spring-boot-with-keycloak","published":1,"updated":"2022-02-21T06:35:00.104Z","_id":"ckx7dl1440003tyze75t06rv9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>對於任何應用程序，安全性始終是主要的跨領域關注點。傳統上，我們過去在整體後端服務中只有一個安全層來保護所有前端應用程序請求。隨著新興的微服務架構的發展，不再有單一的後端服務。前端應用程序調用多個後端服務，這些服務又可以調用其他服務。不再有可以處理身份驗證的單層。由於微服務都具有許多較小的服務，每個服務都處理一個不同的職責，因此安全性的明顯解決方案是身份驗證和授權服務。這是Keycloak進行救援的地方，因為它提供了保護微服務所需的功能。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"什麼是Keycloak\"><a href=\"#什麼是Keycloak\" class=\"headerlink\" title=\"什麼是Keycloak\"></a>什麼是Keycloak</h2><p>Keycloak是Red Hat贊助的開源身份和訪問管理（IAM）解決方案。它使我們能夠保護各種現代的前端應用程序和後端服務。Keycloak可以毫不費力地為我們的應用程序和服務添加身份驗證和授權。我們不需要處理用戶的存儲或身份驗證，因為所有這些都可以在Keycloak中直接使用。</p>\n<p>Keycloak提供的功能包括單點登錄（SSO），身份代理和社交登錄，用戶聯合，客戶端適配器，管理員和用戶帳戶管理控制台。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/01-keycloack-features.png\" alt=\"圖片來源: keycloack官網\"></p>\n<p>除了這些基本功能，Keycloak在其他IAM解決方案中脫穎而出的原因還在於其可定制的網頁和電子郵件模板主題，以及可擴展的功能和領域。可定制的主題很重要，因為它們使開發人員可以定制面向最終用戶的網頁的外觀，以便可以將其與應用程序緊密集成。Keycloak還提供了擴展其核心功能和範圍的功能。這包括可能：</p>\n<ul>\n<li>將自定義REST端點添加到Keycloak服務器</li>\n<li>添加 Server Provider Interface(SPI)</li>\n<li>將自定義 Java Persistence API(JPA)實體添加到Keycloak數據模型中</li>\n</ul>\n<h2 id=\"設置Keycloak\"><a href=\"#設置Keycloak\" class=\"headerlink\" title=\"設置Keycloak\"></a>設置Keycloak</h2><p>以下安裝並運行Keycloak服務器</p>\n<ol>\n<li>先確保要運行的機器有OpenJDK1.8或更高的版本</li>\n<li><a href=\"https://www.keycloak.org/downloads.html\">Keycloak官方網站</a>下載最新的Keycloak realease版本</li>\n</ol>\n<h3 id=\"windows\"><a href=\"#windows\" class=\"headerlink\" title=\"windows\"></a>windows</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin\\standalone.bat</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"linux\"><a href=\"#linux\" class=\"headerlink\" title=\"linux\"></a>linux</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/standalone.sh</span><br></pre></td></tr></table></figure>\n\n<p>Keycloak默認使用<strong>H2資料庫</strong>儲存數據，位於<code>standalone/data</code>目錄中。</p>\n<p>此資料庫並不適用於Production環境，Keycloak官方強烈建議我們將其替換為更利於Productio環境的外部數據庫，例如PostgreSQL。</p>\n<p>可以從<a href=\"https://www.keycloak.org/docs/latest/server_installation/#_database\">官方文檔</a>中獲取有關設置Keycloak數據庫的更多詳細信息。</p>\n<h3 id=\"建立初始化Admin-User\"><a href=\"#建立初始化Admin-User\" class=\"headerlink\" title=\"建立初始化Admin User\"></a>建立初始化Admin User</h3><p>Keycloak不附帶<strong>初始admin</strong>用戶，這意味著在開始使用Keycloak之前，您需要創建一個admin用戶。</p>\n<p>打開<a href=\"http://localhost:8080/auth\">http://localhost:8080/auth</a>並填寫創建初始管理表單，用戶名為admin，密碼為password。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/02-init-admin-account.png\" alt=\"建立keycloack管理員帳號密碼\"></p>\n<p>單擊創建並進入<strong>admin console</strong>，然後使用剛剛創建的admin登錄。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/03-admin-login.png\" alt=\"使用管理員帳號密碼登入keycloack\"></p>\n<p>登錄後Keycloak顯示的第一個屏幕是<strong>Master Realm</strong>詳細信息。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/04-master-realm-detail.png\" alt=\"keycloak登入後畫面\"></p>\n<ul>\n<li>Keycloak中的<strong>realm</strong>就像一個容器，其中包含並隔離user、role、group和client的集合。</li>\n<li>Keycloak帶有一個預先創建的Master realm。</li>\n<li>建議不要使用Master realm管理組織中user和applicatio管理</li>\n<li>創建和管理其他realm，為admin保留對Master realm的使用。</li>\n</ul>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/05-master-realm-manage-other-realm.png\" alt=\"keycloack realm管理\"></p>\n<h3 id=\"建立Realms\"><a href=\"#建立Realms\" class=\"headerlink\" title=\"建立Realms\"></a>建立Realms</h3><p>我們將需要一個realm來管理我們的Spring Boot REST服務使用的user，role和client。</p>\n<p>因此，讓我們建立第一個realm。</p>\n<p>將鼠標懸停在左上角顯示”Master”的下拉菜單上，然後單擊”Add realm”按鈕。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/06-create-realm-in-menu.png\" alt=\"左側菜單選取Realm Settings頁面\"></p>\n<p>我們將第一個realm命名為demo：</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/07-create-realm.png\" alt=\"建立realm: demo\"></p>\n<p>點擊create，將會被定向到創建的realm詳細信息頁面，可以在這進一步配置realm。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/08-realm-detail.png\" alt=\"realm詳細信息頁面\"></p>\n<h3 id=\"建立Roles\"><a href=\"#建立Roles\" class=\"headerlink\" title=\"建立Roles\"></a>建立Roles</h3><p>role對user進行分類。在應用程序中，<strong>訪問資源的權限通常授予role而不是user</strong>。</p>\n<p>Admin、User和Manager都是組織中可能存在的典型角色。</p>\n<p>要建立role，請單擊左側的”Roles”，然後點擊頁面上的”Add Role”按鈕。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/09-role-page.png\" alt=\"左側菜單選取Roles頁面\"></p>\n<p>我們將role命名為spring-user，然後點擊save。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/10-create-spring-user-role.png\" alt=\"建立role: spring-user\"></p>\n<h3 id=\"建立Users\"><a href=\"#建立Users\" class=\"headerlink\" title=\"建立Users\"></a>建立Users</h3><h4 id=\"建立User基本資料\"><a href=\"#建立User基本資料\" class=\"headerlink\" title=\"建立User基本資料\"></a>建立User基本資料</h4><p>單擊左側的”Users”，然後點擊”Add User”按鈕。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/11-user-page.png\" alt=\"左側菜單選取Users頁面\"></p>\n<p>將username填寫為Steven<code>(登入的account)</code>，將First Name填寫為Steven，並保留其他所有默認設置。</p>\n<p>確保”User Enabled”為”on”。點擊save建立第一個user</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/12-create-user.png\" alt=\"建立user: Steven\"></p>\n<h4 id=\"為User設置密碼\"><a href=\"#為User設置密碼\" class=\"headerlink\" title=\"為User設置密碼\"></a>為User設置密碼</h4><p>Steven需要密碼才能登錄Keycloak，所以需要為Steven創建一個密碼。</p>\n<p>點擊”Credentials”標籤，然後在密碼和確認密碼輸入<em>mypassword</em>。</p>\n<p>且設置<strong>Temporary</strong>為<strong>OFF</strong>，以便在下次登錄時無需更改密碼。</p>\n<p>點擊”Set Password”以保存Steven的密碼憑證。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/13-user-set-password.png\" alt=\"設定Steven登入密碼\"></p>\n<h4 id=\"分配Role給User\"><a href=\"#分配Role給User\" class=\"headerlink\" title=\"分配Role給User\"></a>分配Role給User</h4><p>將之前創建的role: <code>spring-user</code>分配給Steven。</p>\n<p>為此，請點擊”Role Mappings”選項，選擇spring-user角色，然後點擊”Add Selected”。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/14-user-mapping-role.png\" alt=\"分配spring-user角色給Steven\"></p>\n<h3 id=\"建立Clients\"><a href=\"#建立Clients\" class=\"headerlink\" title=\"建立Clients\"></a>建立Clients</h3><h4 id=\"Client基本資料建立\"><a href=\"#Client基本資料建立\" class=\"headerlink\" title=\"Client基本資料建立\"></a>Client基本資料建立</h4><blockquote>\n<p>Clients are entities that will request the authentication of a user.</p>\n</blockquote>\n<p>Client有兩種形式。</p>\n<ol>\n<li>第一種類型的Client是想要參與SSO的應用程式，這些Client只希望Keycloak為他們提供安全性。</li>\n<li>另一種Client是請求訪問令牌的Client，以便它可以代表已認證的用戶調用其他服務。</li>\n</ol>\n<p>我們將創建一個Client用於保護我們的Spring Boot REST服務。</p>\n<p>點擊左側的”<strong>Clients</strong>“，然後點選”<strong>Create</strong>“。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/15-client-page.png\" alt=\"左側菜單選取Clients頁面\"></p>\n<p>在表單中，將Client Id填寫為<strong>spring-boot</strong>，為Client Protocol選擇<strong>OpenID Connect</strong>，接著點選Save。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/16-create-client.png\" alt=\"建立一個新的Client: spring-boot\"></p>\n<h4 id=\"更改Access-Type及Authorization-Enabled\"><a href=\"#更改Access-Type及Authorization-Enabled\" class=\"headerlink\" title=\"更改Access Type及Authorization Enabled\"></a>更改Access Type及Authorization Enabled</h4><p>在Client的Settings頁面中，我們需要將<strong>Access Type</strong>更改為<code>confidential</code>，而不是默認的<code>public</code>(不需要Client Secret)。存檔之前，請打開”<strong>Authorization Enabled</strong>“開關。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/17-client-detail-settings.png\" alt=\"修改Client Access Type為confidential\"></p>\n<h4 id=\"Client-Secret\"><a href=\"#Client-Secret\" class=\"headerlink\" title=\"Client Secret\"></a>Client Secret</h4><p>在Client的Credentials頁面中，先將Secret內容複製出來，下面內容會使用到</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/18-clientsecret.png\" alt=\"複製Client Secret\"></p>\n<h3 id=\"拿取Access-Token\"><a href=\"#拿取Access-Token\" class=\"headerlink\" title=\"拿取Access Token\"></a>拿取Access Token</h3><p>Client通過使用HTTP POST方法向Keycloak中的Token endpoint發出<strong>Token交換請求</strong>來請求安全令牌。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/auth/realms/&#123;realm&#125;/protocol/openid-connect/token</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Keycloak中的Token交換請求是<a href=\"https://tools.ietf.org/html/rfc8693\">IETF</a>上<strong>OAuth 2.0Token交換</strong>規範的寬鬆實現。</li>\n<li><strong>OpenID Connect</strong> Token endpoint 上的簡單授予類型調用。</li>\n<li>Keycloak使用”<strong>application/x-www-form-urlencoded</strong>“格式和UTF-8字符編碼來接受HTTP請求實體中的參數。</li>\n</ul>\n<p>打開Postman，建立對<code>http://localhost:8080/auth/realms/demo/protocol/openid-connect/token</code> POST請求</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/19-accesstoken-request.png\" alt=\"使用client_id、client_secret、Steven帳密進行登入\"></p>\n<p>會收到帶有<strong>Access Token</strong>和<strong>Refresh Token</strong>以及其他附帶詳細信息的JSON Response。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/20-accesstoken-response.png\" alt=\"Access Token 及 Refresh Token 的 Response 格式\"></p>\n<p>將接收到的Access Token作為Bearer Token放置在Authorization Header中，就可以在受到Keycloak安全保護的REST API進行請求:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">headers: &#123;</span><br><span class=\"line\">     &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + &#123;access_token&#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>從Keycloak的<strong>Admin console</strong>中，進到spring-boot的Client詳細資訊，然後點選”<strong>Sessions</strong>“選項。您將看到Steven的登錄session。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/21-keycloak-sessions.png\" alt=\"登入的 Session\"></p>\n<p>點擊Steve進到User詳細資訊，然後點選”Sessions”選項。在”Sessions”選項卡下，有一些選項可用於<strong>註銷</strong>特定會話或<strong>註銷所有會話</strong>。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/22-keycloak-usersessions.png\" alt=\"Session詳細訊息\"></p>\n<p>我們已經配置了Keycloak並能夠通過Postman請求Access Token，下一步是創建<strong>Spring Boot REST服務</strong>並使用Keycloak保護它。</p>\n<h2 id=\"建立一個Spring-Boot應用程序\"><a href=\"#建立一個Spring-Boot應用程序\" class=\"headerlink\" title=\"建立一個Spring Boot應用程序\"></a>建立一個Spring Boot應用程序</h2><p>使用<a href=\"https://start.spring.io/\">Spring Initializr</a>網站生成具有Spring Boot 2.x依賴項的項目。還需要Spring Boot Starter Web 模塊</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/23-Spring-Boot-Starter-Web.png\" alt=\"初始化 spring boot 專案\"></p>\n<p>接下來，創建一個@RestController MessagingRestController Class，該Class將getMessage()方法公開為/user/message上的HTTP GET請求。此方法將返回”Hello, User”字串。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessagingRestController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@GetMapping(path = &quot;/user/message&quot;)</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUserMessage</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, User&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>application.yaml中配置server.port</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\">  <span class=\"attr\">port:</span> <span class=\"number\">8000</span></span><br></pre></td></tr></table></figure>\n\n<p>現在我們的REST服務已經可以運行了，我們需要使用Keycloak保護它。</p>\n<h2 id=\"使用Keycloak保護Spring-Boot-REST服務\"><a href=\"#使用Keycloak保護Spring-Boot-REST服務\" class=\"headerlink\" title=\"使用Keycloak保護Spring Boot REST服務\"></a>使用Keycloak保護Spring Boot REST服務</h2><p>為了保護您的Spring Boot REST服務，必須將Spring Boot的<strong>Keycloak Adpater</strong>添加到服務中。</p>\n<p>build.gradle</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ext &#123;</span><br><span class=\"line\">  set(<span class=\"string\">&#x27;keycloakVersion&#x27;</span>, <span class=\"string\">&#x27;12.0.1&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencyManagement &#123;</span><br><span class=\"line\">  imports &#123;</span><br><span class=\"line\">    mavenBom <span class=\"string\">&quot;org.keycloak.bom:keycloak-adapter-bom:$&#123;keycloakVersion&#125;&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  implementation <span class=\"string\">&#x27;org.keycloak:keycloak-spring-boot-starter&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接著將keycloak相關內容配置到application.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">keycloak:</span></span><br><span class=\"line\">  <span class=\"attr\">auth-server-url:</span> <span class=\"string\">http://localhost:8080/auth</span></span><br><span class=\"line\">  <span class=\"attr\">realm:</span> <span class=\"string\">demo</span></span><br><span class=\"line\">  <span class=\"attr\">resource:</span> <span class=\"string\">spring-boot</span></span><br><span class=\"line\">  <span class=\"attr\">credentials:</span></span><br><span class=\"line\">    <span class=\"attr\">secret:</span> <span class=\"string\">86ef845e-735a-42aa-84c7-fac294c359ad</span></span><br><span class=\"line\">  <span class=\"attr\">bearer-only:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>auth-server-url: Keycloak服務器的URL</li>\n<li>realm: 在keycloak所建立的realm</li>\n<li>resource: 在keycloak所建立的Client Id</li>\n<li>secret: 在keycloak所建立的Client Secret</li>\n<li>only-bearer-only: 必須為true，以便Adpater不會嘗試對用戶進行身份驗證，而僅驗證Access Token</li>\n</ul>\n<p>再讓我們為應用程式增加security-constraints<code>(安全性約束)</code>。此配置非常重要，因為Keycloak Adapter將根據我們的配置允許或拒絕對我們資源的訪問請求</p>\n<p>下列例子為: 確保對URL:/user/*的每個請求，僅在該請求的用戶是具有spring-user角色的已認證用戶時才被授權使用。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">keycloak:</span></span><br><span class=\"line\">  <span class=\"attr\">security-constraints:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">auth-roles:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">spring-user</span></span><br><span class=\"line\">      <span class=\"attr\">security-collections:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> </span><br><span class=\"line\">        <span class=\"attr\">patterns:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">/user/*</span></span><br></pre></td></tr></table></figure>\n\n<p>在運行服務之前，讓我們打開Keycloak的DEBUG日誌記錄級別，以在console中查看更多詳細信息。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">logging:</span></span><br><span class=\"line\">  <span class=\"attr\">level:</span></span><br><span class=\"line\">    <span class=\"attr\">org.keycloak:</span> <span class=\"string\">TRACE</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Test-HTTP-GET-User-Message\"><a href=\"#Test-HTTP-GET-User-Message\" class=\"headerlink\" title=\"Test HTTP GET User Message\"></a>Test HTTP GET User Message</h3><h4 id=\"Role-spring-user\"><a href=\"#Role-spring-user\" class=\"headerlink\" title=\"Role spring-user\"></a>Role spring-user</h4><p>打開postman，URL輸入<code>http://localhost:8000/user/message</code>，HTTP Method為GET<br>再點擊”Authorization”標籤，然後選擇Bearer Token，將之前如下圖示中response的access_token貼上Token欄位裡。</p>\n<ol>\n<li><p>使用者Steven驗證</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/24-keycloak-steven'stoken.png\" alt=\"Steven帳號密碼登入\"></p>\n</li>\n<li><p>將上圖的access_token，貼入下圖Token欄位中</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/25-keycloak-accesstokeninbearertoken.png\" alt=\"將Access Token貼到postman的Bearer Token\"></p>\n</li>\n<li><p>點選”Send”過後，會收到 “Hello, User” response</p>\n</li>\n</ol>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/26-keycloak-Hello-user.png\" alt=\"Response\"></p>\n<p>在IDE Console中，會看到keycloak日誌紀錄</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/27-keycloak-console.png\" alt=\"IDE Console\"></p>\n<h4 id=\"Role-spring-admin\"><a href=\"#Role-spring-admin\" class=\"headerlink\" title=\"Role spring-admin\"></a>Role spring-admin</h4><p>我們將使用新role和user對Keycloak進行更多配置，以演示我們為其他請求URL定義安全約束。</p>\n<p>回到keycloak admin console，建立一個新的Role: <code>spring-admin</code></p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/28-keycloak-role-springadmin.png\" alt=\"建立Role: spring-admin\"></p>\n<p>建立新的User: <strong>Dave</strong>並設置密碼，且授予<strong>spring-admin</strong>角色</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/29-keycloak-userdave.png\" alt=\"建立User: Dave\"></p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/30-keycloak-daverolemapping.png\" alt=\"將 spring-admin 角色給予 Dave\"></p>\n<p>回到spring應用程式中，建立一個getAdminMessage endpoint</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(path = &quot;/admin/message&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getAdminMessage</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, Admin&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最後，向我們的應用程序添加另一個安全約束，以授權具有spring-admin角色的用戶訪問URL /admin/*請求。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">keycloak:</span></span><br><span class=\"line\">  <span class=\"attr\">security-constraints:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">auth-roles:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">spring-user</span></span><br><span class=\"line\">      <span class=\"attr\">security-collections:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span></span><br><span class=\"line\">          <span class=\"attr\">patterns:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"string\">/user/*</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">auth-roles:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">spring-admin</span></span><br><span class=\"line\">      <span class=\"attr\">security-collections:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span></span><br><span class=\"line\">          <span class=\"attr\">patterns:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"string\">/user/*</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"string\">/admin/*</span></span><br></pre></td></tr></table></figure>\n\n<p>現在我們使用Steven的token對/admin/message進行請求</p>\n<p>此請求被拒絕，因為我們尚未授予spring-user角色訪問請求/admin/*的權限。<br><img src=\"/images/spring/spring-boot-with-keycloak/31-keycloak-steve-nnoadmin.png\" alt=\"Role: spring-User 不能訪問 Role: spring-admin 頁面\"></p>\n<p>讓我們換回用Dave的token，來對/admin/message進行請求，將能成功進行請求<br><img src=\"/images/spring/spring-boot-with-keycloak/32-keycloak-davegetaccesstoen.png\" alt=\"Dave帳號密碼登入\"></p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/33-keycloak-davecanaccessadminendpoint.png\" alt=\"Role: spring-admin 可正常訪問 spring-admin 頁面\"></p>\n<h2 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h2><ul>\n<li>了解到Keycloak是一個現代的身份和訪問管理系統，提供了許多現成的功能。</li>\n<li>還學習瞭如何使用realm、role、User和Client來設置Keycloak。</li>\n<li>最後，我們學習如何配置Spring Boot REST服務以利用Keycloak認證和授權所有請求。</li>\n</ul>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://codeburst.io/securing-spring-boot-rest-services-using-keycloak-without-writing-code-7c47ab72fb9d\">https://codeburst.io/securing-spring-boot-rest-services-using-keycloak-without-writing-code-7c47ab72fb9d</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>對於任何應用程序，安全性始終是主要的跨領域關注點。傳統上，我們過去在整體後端服務中只有一個安全層來保護所有前端應用程序請求。隨著新興的微服務架構的發展，不再有單一的後端服務。前端應用程序調用多個後端服務，這些服務又可以調用其他服務。不再有可以處理身份驗證的單層。由於微服務都具有許多較小的服務，每個服務都處理一個不同的職責，因此安全性的明顯解決方案是身份驗證和授權服務。這是Keycloak進行救援的地方，因為它提供了保護微服務所需的功能。</p>","more":"<h2 id=\"什麼是Keycloak\"><a href=\"#什麼是Keycloak\" class=\"headerlink\" title=\"什麼是Keycloak\"></a>什麼是Keycloak</h2><p>Keycloak是Red Hat贊助的開源身份和訪問管理（IAM）解決方案。它使我們能夠保護各種現代的前端應用程序和後端服務。Keycloak可以毫不費力地為我們的應用程序和服務添加身份驗證和授權。我們不需要處理用戶的存儲或身份驗證，因為所有這些都可以在Keycloak中直接使用。</p>\n<p>Keycloak提供的功能包括單點登錄（SSO），身份代理和社交登錄，用戶聯合，客戶端適配器，管理員和用戶帳戶管理控制台。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/01-keycloack-features.png\" alt=\"圖片來源: keycloack官網\"></p>\n<p>除了這些基本功能，Keycloak在其他IAM解決方案中脫穎而出的原因還在於其可定制的網頁和電子郵件模板主題，以及可擴展的功能和領域。可定制的主題很重要，因為它們使開發人員可以定制面向最終用戶的網頁的外觀，以便可以將其與應用程序緊密集成。Keycloak還提供了擴展其核心功能和範圍的功能。這包括可能：</p>\n<ul>\n<li>將自定義REST端點添加到Keycloak服務器</li>\n<li>添加 Server Provider Interface(SPI)</li>\n<li>將自定義 Java Persistence API(JPA)實體添加到Keycloak數據模型中</li>\n</ul>\n<h2 id=\"設置Keycloak\"><a href=\"#設置Keycloak\" class=\"headerlink\" title=\"設置Keycloak\"></a>設置Keycloak</h2><p>以下安裝並運行Keycloak服務器</p>\n<ol>\n<li>先確保要運行的機器有OpenJDK1.8或更高的版本</li>\n<li><a href=\"https://www.keycloak.org/downloads.html\">Keycloak官方網站</a>下載最新的Keycloak realease版本</li>\n</ol>\n<h3 id=\"windows\"><a href=\"#windows\" class=\"headerlink\" title=\"windows\"></a>windows</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin\\standalone.bat</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"linux\"><a href=\"#linux\" class=\"headerlink\" title=\"linux\"></a>linux</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/standalone.sh</span><br></pre></td></tr></table></figure>\n\n<p>Keycloak默認使用<strong>H2資料庫</strong>儲存數據，位於<code>standalone/data</code>目錄中。</p>\n<p>此資料庫並不適用於Production環境，Keycloak官方強烈建議我們將其替換為更利於Productio環境的外部數據庫，例如PostgreSQL。</p>\n<p>可以從<a href=\"https://www.keycloak.org/docs/latest/server_installation/#_database\">官方文檔</a>中獲取有關設置Keycloak數據庫的更多詳細信息。</p>\n<h3 id=\"建立初始化Admin-User\"><a href=\"#建立初始化Admin-User\" class=\"headerlink\" title=\"建立初始化Admin User\"></a>建立初始化Admin User</h3><p>Keycloak不附帶<strong>初始admin</strong>用戶，這意味著在開始使用Keycloak之前，您需要創建一個admin用戶。</p>\n<p>打開<a href=\"http://localhost:8080/auth\">http://localhost:8080/auth</a>並填寫創建初始管理表單，用戶名為admin，密碼為password。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/02-init-admin-account.png\" alt=\"建立keycloack管理員帳號密碼\"></p>\n<p>單擊創建並進入<strong>admin console</strong>，然後使用剛剛創建的admin登錄。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/03-admin-login.png\" alt=\"使用管理員帳號密碼登入keycloack\"></p>\n<p>登錄後Keycloak顯示的第一個屏幕是<strong>Master Realm</strong>詳細信息。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/04-master-realm-detail.png\" alt=\"keycloak登入後畫面\"></p>\n<ul>\n<li>Keycloak中的<strong>realm</strong>就像一個容器，其中包含並隔離user、role、group和client的集合。</li>\n<li>Keycloak帶有一個預先創建的Master realm。</li>\n<li>建議不要使用Master realm管理組織中user和applicatio管理</li>\n<li>創建和管理其他realm，為admin保留對Master realm的使用。</li>\n</ul>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/05-master-realm-manage-other-realm.png\" alt=\"keycloack realm管理\"></p>\n<h3 id=\"建立Realms\"><a href=\"#建立Realms\" class=\"headerlink\" title=\"建立Realms\"></a>建立Realms</h3><p>我們將需要一個realm來管理我們的Spring Boot REST服務使用的user，role和client。</p>\n<p>因此，讓我們建立第一個realm。</p>\n<p>將鼠標懸停在左上角顯示”Master”的下拉菜單上，然後單擊”Add realm”按鈕。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/06-create-realm-in-menu.png\" alt=\"左側菜單選取Realm Settings頁面\"></p>\n<p>我們將第一個realm命名為demo：</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/07-create-realm.png\" alt=\"建立realm: demo\"></p>\n<p>點擊create，將會被定向到創建的realm詳細信息頁面，可以在這進一步配置realm。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/08-realm-detail.png\" alt=\"realm詳細信息頁面\"></p>\n<h3 id=\"建立Roles\"><a href=\"#建立Roles\" class=\"headerlink\" title=\"建立Roles\"></a>建立Roles</h3><p>role對user進行分類。在應用程序中，<strong>訪問資源的權限通常授予role而不是user</strong>。</p>\n<p>Admin、User和Manager都是組織中可能存在的典型角色。</p>\n<p>要建立role，請單擊左側的”Roles”，然後點擊頁面上的”Add Role”按鈕。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/09-role-page.png\" alt=\"左側菜單選取Roles頁面\"></p>\n<p>我們將role命名為spring-user，然後點擊save。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/10-create-spring-user-role.png\" alt=\"建立role: spring-user\"></p>\n<h3 id=\"建立Users\"><a href=\"#建立Users\" class=\"headerlink\" title=\"建立Users\"></a>建立Users</h3><h4 id=\"建立User基本資料\"><a href=\"#建立User基本資料\" class=\"headerlink\" title=\"建立User基本資料\"></a>建立User基本資料</h4><p>單擊左側的”Users”，然後點擊”Add User”按鈕。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/11-user-page.png\" alt=\"左側菜單選取Users頁面\"></p>\n<p>將username填寫為Steven<code>(登入的account)</code>，將First Name填寫為Steven，並保留其他所有默認設置。</p>\n<p>確保”User Enabled”為”on”。點擊save建立第一個user</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/12-create-user.png\" alt=\"建立user: Steven\"></p>\n<h4 id=\"為User設置密碼\"><a href=\"#為User設置密碼\" class=\"headerlink\" title=\"為User設置密碼\"></a>為User設置密碼</h4><p>Steven需要密碼才能登錄Keycloak，所以需要為Steven創建一個密碼。</p>\n<p>點擊”Credentials”標籤，然後在密碼和確認密碼輸入<em>mypassword</em>。</p>\n<p>且設置<strong>Temporary</strong>為<strong>OFF</strong>，以便在下次登錄時無需更改密碼。</p>\n<p>點擊”Set Password”以保存Steven的密碼憑證。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/13-user-set-password.png\" alt=\"設定Steven登入密碼\"></p>\n<h4 id=\"分配Role給User\"><a href=\"#分配Role給User\" class=\"headerlink\" title=\"分配Role給User\"></a>分配Role給User</h4><p>將之前創建的role: <code>spring-user</code>分配給Steven。</p>\n<p>為此，請點擊”Role Mappings”選項，選擇spring-user角色，然後點擊”Add Selected”。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/14-user-mapping-role.png\" alt=\"分配spring-user角色給Steven\"></p>\n<h3 id=\"建立Clients\"><a href=\"#建立Clients\" class=\"headerlink\" title=\"建立Clients\"></a>建立Clients</h3><h4 id=\"Client基本資料建立\"><a href=\"#Client基本資料建立\" class=\"headerlink\" title=\"Client基本資料建立\"></a>Client基本資料建立</h4><blockquote>\n<p>Clients are entities that will request the authentication of a user.</p>\n</blockquote>\n<p>Client有兩種形式。</p>\n<ol>\n<li>第一種類型的Client是想要參與SSO的應用程式，這些Client只希望Keycloak為他們提供安全性。</li>\n<li>另一種Client是請求訪問令牌的Client，以便它可以代表已認證的用戶調用其他服務。</li>\n</ol>\n<p>我們將創建一個Client用於保護我們的Spring Boot REST服務。</p>\n<p>點擊左側的”<strong>Clients</strong>“，然後點選”<strong>Create</strong>“。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/15-client-page.png\" alt=\"左側菜單選取Clients頁面\"></p>\n<p>在表單中，將Client Id填寫為<strong>spring-boot</strong>，為Client Protocol選擇<strong>OpenID Connect</strong>，接著點選Save。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/16-create-client.png\" alt=\"建立一個新的Client: spring-boot\"></p>\n<h4 id=\"更改Access-Type及Authorization-Enabled\"><a href=\"#更改Access-Type及Authorization-Enabled\" class=\"headerlink\" title=\"更改Access Type及Authorization Enabled\"></a>更改Access Type及Authorization Enabled</h4><p>在Client的Settings頁面中，我們需要將<strong>Access Type</strong>更改為<code>confidential</code>，而不是默認的<code>public</code>(不需要Client Secret)。存檔之前，請打開”<strong>Authorization Enabled</strong>“開關。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/17-client-detail-settings.png\" alt=\"修改Client Access Type為confidential\"></p>\n<h4 id=\"Client-Secret\"><a href=\"#Client-Secret\" class=\"headerlink\" title=\"Client Secret\"></a>Client Secret</h4><p>在Client的Credentials頁面中，先將Secret內容複製出來，下面內容會使用到</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/18-clientsecret.png\" alt=\"複製Client Secret\"></p>\n<h3 id=\"拿取Access-Token\"><a href=\"#拿取Access-Token\" class=\"headerlink\" title=\"拿取Access Token\"></a>拿取Access Token</h3><p>Client通過使用HTTP POST方法向Keycloak中的Token endpoint發出<strong>Token交換請求</strong>來請求安全令牌。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/auth/realms/&#123;realm&#125;/protocol/openid-connect/token</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Keycloak中的Token交換請求是<a href=\"https://tools.ietf.org/html/rfc8693\">IETF</a>上<strong>OAuth 2.0Token交換</strong>規範的寬鬆實現。</li>\n<li><strong>OpenID Connect</strong> Token endpoint 上的簡單授予類型調用。</li>\n<li>Keycloak使用”<strong>application/x-www-form-urlencoded</strong>“格式和UTF-8字符編碼來接受HTTP請求實體中的參數。</li>\n</ul>\n<p>打開Postman，建立對<code>http://localhost:8080/auth/realms/demo/protocol/openid-connect/token</code> POST請求</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/19-accesstoken-request.png\" alt=\"使用client_id、client_secret、Steven帳密進行登入\"></p>\n<p>會收到帶有<strong>Access Token</strong>和<strong>Refresh Token</strong>以及其他附帶詳細信息的JSON Response。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/20-accesstoken-response.png\" alt=\"Access Token 及 Refresh Token 的 Response 格式\"></p>\n<p>將接收到的Access Token作為Bearer Token放置在Authorization Header中，就可以在受到Keycloak安全保護的REST API進行請求:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">headers: &#123;</span><br><span class=\"line\">     &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + &#123;access_token&#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>從Keycloak的<strong>Admin console</strong>中，進到spring-boot的Client詳細資訊，然後點選”<strong>Sessions</strong>“選項。您將看到Steven的登錄session。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/21-keycloak-sessions.png\" alt=\"登入的 Session\"></p>\n<p>點擊Steve進到User詳細資訊，然後點選”Sessions”選項。在”Sessions”選項卡下，有一些選項可用於<strong>註銷</strong>特定會話或<strong>註銷所有會話</strong>。</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/22-keycloak-usersessions.png\" alt=\"Session詳細訊息\"></p>\n<p>我們已經配置了Keycloak並能夠通過Postman請求Access Token，下一步是創建<strong>Spring Boot REST服務</strong>並使用Keycloak保護它。</p>\n<h2 id=\"建立一個Spring-Boot應用程序\"><a href=\"#建立一個Spring-Boot應用程序\" class=\"headerlink\" title=\"建立一個Spring Boot應用程序\"></a>建立一個Spring Boot應用程序</h2><p>使用<a href=\"https://start.spring.io/\">Spring Initializr</a>網站生成具有Spring Boot 2.x依賴項的項目。還需要Spring Boot Starter Web 模塊</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/23-Spring-Boot-Starter-Web.png\" alt=\"初始化 spring boot 專案\"></p>\n<p>接下來，創建一個@RestController MessagingRestController Class，該Class將getMessage()方法公開為/user/message上的HTTP GET請求。此方法將返回”Hello, User”字串。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessagingRestController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@GetMapping(path = &quot;/user/message&quot;)</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUserMessage</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, User&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>application.yaml中配置server.port</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\">  <span class=\"attr\">port:</span> <span class=\"number\">8000</span></span><br></pre></td></tr></table></figure>\n\n<p>現在我們的REST服務已經可以運行了，我們需要使用Keycloak保護它。</p>\n<h2 id=\"使用Keycloak保護Spring-Boot-REST服務\"><a href=\"#使用Keycloak保護Spring-Boot-REST服務\" class=\"headerlink\" title=\"使用Keycloak保護Spring Boot REST服務\"></a>使用Keycloak保護Spring Boot REST服務</h2><p>為了保護您的Spring Boot REST服務，必須將Spring Boot的<strong>Keycloak Adpater</strong>添加到服務中。</p>\n<p>build.gradle</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ext &#123;</span><br><span class=\"line\">  set(<span class=\"string\">&#x27;keycloakVersion&#x27;</span>, <span class=\"string\">&#x27;12.0.1&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencyManagement &#123;</span><br><span class=\"line\">  imports &#123;</span><br><span class=\"line\">    mavenBom <span class=\"string\">&quot;org.keycloak.bom:keycloak-adapter-bom:$&#123;keycloakVersion&#125;&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  implementation <span class=\"string\">&#x27;org.keycloak:keycloak-spring-boot-starter&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接著將keycloak相關內容配置到application.yaml</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">keycloak:</span></span><br><span class=\"line\">  <span class=\"attr\">auth-server-url:</span> <span class=\"string\">http://localhost:8080/auth</span></span><br><span class=\"line\">  <span class=\"attr\">realm:</span> <span class=\"string\">demo</span></span><br><span class=\"line\">  <span class=\"attr\">resource:</span> <span class=\"string\">spring-boot</span></span><br><span class=\"line\">  <span class=\"attr\">credentials:</span></span><br><span class=\"line\">    <span class=\"attr\">secret:</span> <span class=\"string\">86ef845e-735a-42aa-84c7-fac294c359ad</span></span><br><span class=\"line\">  <span class=\"attr\">bearer-only:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>auth-server-url: Keycloak服務器的URL</li>\n<li>realm: 在keycloak所建立的realm</li>\n<li>resource: 在keycloak所建立的Client Id</li>\n<li>secret: 在keycloak所建立的Client Secret</li>\n<li>only-bearer-only: 必須為true，以便Adpater不會嘗試對用戶進行身份驗證，而僅驗證Access Token</li>\n</ul>\n<p>再讓我們為應用程式增加security-constraints<code>(安全性約束)</code>。此配置非常重要，因為Keycloak Adapter將根據我們的配置允許或拒絕對我們資源的訪問請求</p>\n<p>下列例子為: 確保對URL:/user/*的每個請求，僅在該請求的用戶是具有spring-user角色的已認證用戶時才被授權使用。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">keycloak:</span></span><br><span class=\"line\">  <span class=\"attr\">security-constraints:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">auth-roles:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">spring-user</span></span><br><span class=\"line\">      <span class=\"attr\">security-collections:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> </span><br><span class=\"line\">        <span class=\"attr\">patterns:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">/user/*</span></span><br></pre></td></tr></table></figure>\n\n<p>在運行服務之前，讓我們打開Keycloak的DEBUG日誌記錄級別，以在console中查看更多詳細信息。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">logging:</span></span><br><span class=\"line\">  <span class=\"attr\">level:</span></span><br><span class=\"line\">    <span class=\"attr\">org.keycloak:</span> <span class=\"string\">TRACE</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Test-HTTP-GET-User-Message\"><a href=\"#Test-HTTP-GET-User-Message\" class=\"headerlink\" title=\"Test HTTP GET User Message\"></a>Test HTTP GET User Message</h3><h4 id=\"Role-spring-user\"><a href=\"#Role-spring-user\" class=\"headerlink\" title=\"Role spring-user\"></a>Role spring-user</h4><p>打開postman，URL輸入<code>http://localhost:8000/user/message</code>，HTTP Method為GET<br>再點擊”Authorization”標籤，然後選擇Bearer Token，將之前如下圖示中response的access_token貼上Token欄位裡。</p>\n<ol>\n<li><p>使用者Steven驗證</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/24-keycloak-steven'stoken.png\" alt=\"Steven帳號密碼登入\"></p>\n</li>\n<li><p>將上圖的access_token，貼入下圖Token欄位中</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/25-keycloak-accesstokeninbearertoken.png\" alt=\"將Access Token貼到postman的Bearer Token\"></p>\n</li>\n<li><p>點選”Send”過後，會收到 “Hello, User” response</p>\n</li>\n</ol>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/26-keycloak-Hello-user.png\" alt=\"Response\"></p>\n<p>在IDE Console中，會看到keycloak日誌紀錄</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/27-keycloak-console.png\" alt=\"IDE Console\"></p>\n<h4 id=\"Role-spring-admin\"><a href=\"#Role-spring-admin\" class=\"headerlink\" title=\"Role spring-admin\"></a>Role spring-admin</h4><p>我們將使用新role和user對Keycloak進行更多配置，以演示我們為其他請求URL定義安全約束。</p>\n<p>回到keycloak admin console，建立一個新的Role: <code>spring-admin</code></p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/28-keycloak-role-springadmin.png\" alt=\"建立Role: spring-admin\"></p>\n<p>建立新的User: <strong>Dave</strong>並設置密碼，且授予<strong>spring-admin</strong>角色</p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/29-keycloak-userdave.png\" alt=\"建立User: Dave\"></p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/30-keycloak-daverolemapping.png\" alt=\"將 spring-admin 角色給予 Dave\"></p>\n<p>回到spring應用程式中，建立一個getAdminMessage endpoint</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(path = &quot;/admin/message&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getAdminMessage</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, Admin&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最後，向我們的應用程序添加另一個安全約束，以授權具有spring-admin角色的用戶訪問URL /admin/*請求。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">keycloak:</span></span><br><span class=\"line\">  <span class=\"attr\">security-constraints:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">auth-roles:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">spring-user</span></span><br><span class=\"line\">      <span class=\"attr\">security-collections:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span></span><br><span class=\"line\">          <span class=\"attr\">patterns:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"string\">/user/*</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">auth-roles:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">spring-admin</span></span><br><span class=\"line\">      <span class=\"attr\">security-collections:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span></span><br><span class=\"line\">          <span class=\"attr\">patterns:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"string\">/user/*</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"string\">/admin/*</span></span><br></pre></td></tr></table></figure>\n\n<p>現在我們使用Steven的token對/admin/message進行請求</p>\n<p>此請求被拒絕，因為我們尚未授予spring-user角色訪問請求/admin/*的權限。<br><img src=\"/images/spring/spring-boot-with-keycloak/31-keycloak-steve-nnoadmin.png\" alt=\"Role: spring-User 不能訪問 Role: spring-admin 頁面\"></p>\n<p>讓我們換回用Dave的token，來對/admin/message進行請求，將能成功進行請求<br><img src=\"/images/spring/spring-boot-with-keycloak/32-keycloak-davegetaccesstoen.png\" alt=\"Dave帳號密碼登入\"></p>\n<p><img src=\"/images/spring/spring-boot-with-keycloak/33-keycloak-davecanaccessadminendpoint.png\" alt=\"Role: spring-admin 可正常訪問 spring-admin 頁面\"></p>\n<h2 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h2><ul>\n<li>了解到Keycloak是一個現代的身份和訪問管理系統，提供了許多現成的功能。</li>\n<li>還學習瞭如何使用realm、role、User和Client來設置Keycloak。</li>\n<li>最後，我們學習如何配置Spring Boot REST服務以利用Keycloak認證和授權所有請求。</li>\n</ul>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://codeburst.io/securing-spring-boot-rest-services-using-keycloak-without-writing-code-7c47ab72fb9d\">https://codeburst.io/securing-spring-boot-rest-services-using-keycloak-without-writing-code-7c47ab72fb9d</a></li>\n</ul>"},{"title":"[Other] 利用Netlify架設Blog","date":"2021-12-21T08:26:01.000Z","toc":true,"cover":"/images/other/use-netlify-building-blog/netlify_logo_icon_169924.png","_content":"\n當Blog開發好時，需要架設在一個可以託管靜態網頁的網站上，常見的服務有Netlify、Heroku、GitHub Page、GitLab Page、FireBase、S3...等服務。\n\n最後選擇了Netlify，主要是對我這種免費仔跟懶人很便利(:laughing:)，讓我們一起來看看如何在Netlify有什麼方便的服務幫助我們架設Blog吧！\n\n<!-- more -->\n\n## Netlify提供了什麼服務\n\n![Netlify官網](/images/other/use-netlify-building-blog/01_netlify_official_website.png)\n\n+ Netlify官網: <https://www.netlify.com/>\n+ 託管靜態網頁\n+ 可以直接連結你的GitHub or GitLab repo\n+ 自動建構、部屬靜態網頁\n\n## 將靜態網頁部屬到Netlify\n\n### 登入Netlify\n\n![使用GitHub帳號登入Netlify](/images/other/use-netlify-building-blog/02_github_account_login_netlify.png)\n\nNetlify提供許多登入方式(如上圖)，在這裡我使用GitHub帳號登入，方便之後連結GitHub上的repo\n\n### 新增靜態網頁\n\n進入 Sites 選單 &rarr; Add new site &rarr; Import an existing project\n\n![選擇已有的專案匯入](/images/other/use-netlify-building-blog/03_add_new_site.png)\n\n### 連結GitHub帳號\n\n![連結GitHub帳號](/images/other/use-netlify-building-blog/04-connect-github.png)\n\n### 選擇要產生靜態網頁的repo\n\n![選擇要產生靜態網頁的repo](/images/other/use-netlify-building-blog/05-pick-a-repo.png)\n\n### Basic build settings(基礎建置設定)\n\n![Basic build settings](/images/other/use-netlify-building-blog/06-Basic-build-settings.png)\n\nNetlify會自動偵測使用何種框架產生靜態網頁，例如: 此部落格使用[Hexo](https://hexo.io/zh-tw/)框架產生靜態網頁\n\n若是偵測的指令有錯，可以自行在`Build command`進行修改\n\n+ **Build Command**: 產生靜態網頁的指令(如上圖①)\n+ **Publish directory**: 靜態網頁產生後的位置(如上圖②)\n\n以上若設定好之後，可以按下`Deploy site`(如上圖③)，會自動依照你的設定部屬網站\n\n### 查看結果\n\n![佈署結果](/images/other/use-netlify-building-blog/07-deploy-complete.png)\n\n可以看到Netlify會幫我們產生一個網址，可以點選此網址查看網站內容\n\n若是想要自定義網站網址的話，可以參考下一節`自定義網站網址`\n\n## 自定義網站網址\n\n自定義網址可以在Netlify進行購買或者在外部買一個網址，接著透過Netlify DNS解析\n\n以下方法採取在Gandi購買一個網址，然後透過Netlify DNS作解析\n\n### Gandi小資料\n\n> Gandi官網：<https://www.gandi.net/zh-Hant>\n> 提供網域名稱、網頁代管、SSL憑證與電子信箱...等服務\n\n![Gandi官網](/images/other/use-netlify-building-blog/08-gandi-official-website.png)\n\n### 在Gandi購買網址\n\n確認你要買的網址沒被使用，接著就可以按下加入購物車進行購買\n\n剩下的步驟就按照網站的流程下去進行，就可以順利將此網址購買成功\n\n![確認網址並購買](/images/other/use-netlify-building-blog/09-buy-domain.png)\n\n購買成功後，可以在`管理者界面`中`域名`菜單中看到所購買的網址，可以點選網址做進階設定\n\n![Gandi管理者界面](/images/other/use-netlify-building-blog/10-gandi-admin-console.png)\n\n![網址進階設定畫面](/images/other/use-netlify-building-blog/11-domain-advance-settings.png)\n\n### 回到Netlify設定網址\n\n回到Netlify進入剛剛建立的`site`，接著點選`Domain settings`(如下圖①)\n\n![Domain settings](/images/other/use-netlify-building-blog/12-custom-domain.png)\n\n點選`Add custom domain`\n\n![Add custom domain](/images/other/use-netlify-building-blog/13-add-custom-domain.png)\n\n輸入剛剛購買的網址並驗證\n\n![驗證網址](/images/other/use-netlify-building-blog/14-verify-domain.png)\n\n驗證沒錯之後點選加入，接著會出現Netlify DNS Name servers(名稱伺服器)\n\n![Netlify DNS Name Servers](/images/other/use-netlify-building-blog/15-netlify-dns-name-servers.png)\n\n記住這些Name Server，等等會用到\n\n### 到Gandi設定Name Server\n\n點選`名稱伺服器`\n\n![網址名稱伺服器位置](/images/other/use-netlify-building-blog/16-enter-name-servers.png)\n\n接著選擇`外部`，並填入剛剛在Netlify上看到的那4個Name Server，接著按下儲存\n\n![改成Netlify Name Server](/images/other/use-netlify-building-blog/17-settings-gandi-outside-name-server.png)\n\n等它生效需要一段時間\n\n### 回到Netlify查看結果\n\nNetlify會自動幫我們剛剛設定的網域掛上SSL/TLS憑證\n\n![SSL/TLS憑證](/images/other/use-netlify-building-blog/18-ssl-tls.png)\n\n成功之後，下圖就會變成我們剛剛輸入的網址\n\n![成功掛上自定義網址畫面](/images/other/use-netlify-building-blog/19-finish-custom-domain.png)\n\n恭喜你!!這樣就可以使用自定義的網址訪問你的網站了\n","source":"_posts/other/use-netlify-building-blog.md","raw":"---\ntitle: '[Other] 利用Netlify架設Blog'\ndate: 2021-12-21 16:26:01\ntags: other\ncategories: 學習\ntoc: true\ncover: /images/other/use-netlify-building-blog/netlify_logo_icon_169924.png\n---\n\n當Blog開發好時，需要架設在一個可以託管靜態網頁的網站上，常見的服務有Netlify、Heroku、GitHub Page、GitLab Page、FireBase、S3...等服務。\n\n最後選擇了Netlify，主要是對我這種免費仔跟懶人很便利(:laughing:)，讓我們一起來看看如何在Netlify有什麼方便的服務幫助我們架設Blog吧！\n\n<!-- more -->\n\n## Netlify提供了什麼服務\n\n![Netlify官網](/images/other/use-netlify-building-blog/01_netlify_official_website.png)\n\n+ Netlify官網: <https://www.netlify.com/>\n+ 託管靜態網頁\n+ 可以直接連結你的GitHub or GitLab repo\n+ 自動建構、部屬靜態網頁\n\n## 將靜態網頁部屬到Netlify\n\n### 登入Netlify\n\n![使用GitHub帳號登入Netlify](/images/other/use-netlify-building-blog/02_github_account_login_netlify.png)\n\nNetlify提供許多登入方式(如上圖)，在這裡我使用GitHub帳號登入，方便之後連結GitHub上的repo\n\n### 新增靜態網頁\n\n進入 Sites 選單 &rarr; Add new site &rarr; Import an existing project\n\n![選擇已有的專案匯入](/images/other/use-netlify-building-blog/03_add_new_site.png)\n\n### 連結GitHub帳號\n\n![連結GitHub帳號](/images/other/use-netlify-building-blog/04-connect-github.png)\n\n### 選擇要產生靜態網頁的repo\n\n![選擇要產生靜態網頁的repo](/images/other/use-netlify-building-blog/05-pick-a-repo.png)\n\n### Basic build settings(基礎建置設定)\n\n![Basic build settings](/images/other/use-netlify-building-blog/06-Basic-build-settings.png)\n\nNetlify會自動偵測使用何種框架產生靜態網頁，例如: 此部落格使用[Hexo](https://hexo.io/zh-tw/)框架產生靜態網頁\n\n若是偵測的指令有錯，可以自行在`Build command`進行修改\n\n+ **Build Command**: 產生靜態網頁的指令(如上圖①)\n+ **Publish directory**: 靜態網頁產生後的位置(如上圖②)\n\n以上若設定好之後，可以按下`Deploy site`(如上圖③)，會自動依照你的設定部屬網站\n\n### 查看結果\n\n![佈署結果](/images/other/use-netlify-building-blog/07-deploy-complete.png)\n\n可以看到Netlify會幫我們產生一個網址，可以點選此網址查看網站內容\n\n若是想要自定義網站網址的話，可以參考下一節`自定義網站網址`\n\n## 自定義網站網址\n\n自定義網址可以在Netlify進行購買或者在外部買一個網址，接著透過Netlify DNS解析\n\n以下方法採取在Gandi購買一個網址，然後透過Netlify DNS作解析\n\n### Gandi小資料\n\n> Gandi官網：<https://www.gandi.net/zh-Hant>\n> 提供網域名稱、網頁代管、SSL憑證與電子信箱...等服務\n\n![Gandi官網](/images/other/use-netlify-building-blog/08-gandi-official-website.png)\n\n### 在Gandi購買網址\n\n確認你要買的網址沒被使用，接著就可以按下加入購物車進行購買\n\n剩下的步驟就按照網站的流程下去進行，就可以順利將此網址購買成功\n\n![確認網址並購買](/images/other/use-netlify-building-blog/09-buy-domain.png)\n\n購買成功後，可以在`管理者界面`中`域名`菜單中看到所購買的網址，可以點選網址做進階設定\n\n![Gandi管理者界面](/images/other/use-netlify-building-blog/10-gandi-admin-console.png)\n\n![網址進階設定畫面](/images/other/use-netlify-building-blog/11-domain-advance-settings.png)\n\n### 回到Netlify設定網址\n\n回到Netlify進入剛剛建立的`site`，接著點選`Domain settings`(如下圖①)\n\n![Domain settings](/images/other/use-netlify-building-blog/12-custom-domain.png)\n\n點選`Add custom domain`\n\n![Add custom domain](/images/other/use-netlify-building-blog/13-add-custom-domain.png)\n\n輸入剛剛購買的網址並驗證\n\n![驗證網址](/images/other/use-netlify-building-blog/14-verify-domain.png)\n\n驗證沒錯之後點選加入，接著會出現Netlify DNS Name servers(名稱伺服器)\n\n![Netlify DNS Name Servers](/images/other/use-netlify-building-blog/15-netlify-dns-name-servers.png)\n\n記住這些Name Server，等等會用到\n\n### 到Gandi設定Name Server\n\n點選`名稱伺服器`\n\n![網址名稱伺服器位置](/images/other/use-netlify-building-blog/16-enter-name-servers.png)\n\n接著選擇`外部`，並填入剛剛在Netlify上看到的那4個Name Server，接著按下儲存\n\n![改成Netlify Name Server](/images/other/use-netlify-building-blog/17-settings-gandi-outside-name-server.png)\n\n等它生效需要一段時間\n\n### 回到Netlify查看結果\n\nNetlify會自動幫我們剛剛設定的網域掛上SSL/TLS憑證\n\n![SSL/TLS憑證](/images/other/use-netlify-building-blog/18-ssl-tls.png)\n\n成功之後，下圖就會變成我們剛剛輸入的網址\n\n![成功掛上自定義網址畫面](/images/other/use-netlify-building-blog/19-finish-custom-domain.png)\n\n恭喜你!!這樣就可以使用自定義的網址訪問你的網站了\n","slug":"other/use-netlify-building-blog","published":1,"updated":"2022-02-21T06:35:00.103Z","_id":"ckxfufyry0000pgze896t3mk1","comments":1,"layout":"post","photos":[],"link":"","content":"<p>當Blog開發好時，需要架設在一個可以託管靜態網頁的網站上，常見的服務有Netlify、Heroku、GitHub Page、GitLab Page、FireBase、S3…等服務。</p>\n<p>最後選擇了Netlify，主要是對我這種免費仔跟懶人很便利(:laughing:)，讓我們一起來看看如何在Netlify有什麼方便的服務幫助我們架設Blog吧！</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Netlify提供了什麼服務\"><a href=\"#Netlify提供了什麼服務\" class=\"headerlink\" title=\"Netlify提供了什麼服務\"></a>Netlify提供了什麼服務</h2><p><img src=\"/images/other/use-netlify-building-blog/01_netlify_official_website.png\" alt=\"Netlify官網\"></p>\n<ul>\n<li>Netlify官網: <a href=\"https://www.netlify.com/\">https://www.netlify.com/</a></li>\n<li>託管靜態網頁</li>\n<li>可以直接連結你的GitHub or GitLab repo</li>\n<li>自動建構、部屬靜態網頁</li>\n</ul>\n<h2 id=\"將靜態網頁部屬到Netlify\"><a href=\"#將靜態網頁部屬到Netlify\" class=\"headerlink\" title=\"將靜態網頁部屬到Netlify\"></a>將靜態網頁部屬到Netlify</h2><h3 id=\"登入Netlify\"><a href=\"#登入Netlify\" class=\"headerlink\" title=\"登入Netlify\"></a>登入Netlify</h3><p><img src=\"/images/other/use-netlify-building-blog/02_github_account_login_netlify.png\" alt=\"使用GitHub帳號登入Netlify\"></p>\n<p>Netlify提供許多登入方式(如上圖)，在這裡我使用GitHub帳號登入，方便之後連結GitHub上的repo</p>\n<h3 id=\"新增靜態網頁\"><a href=\"#新增靜態網頁\" class=\"headerlink\" title=\"新增靜態網頁\"></a>新增靜態網頁</h3><p>進入 Sites 選單 &rarr; Add new site &rarr; Import an existing project</p>\n<p><img src=\"/images/other/use-netlify-building-blog/03_add_new_site.png\" alt=\"選擇已有的專案匯入\"></p>\n<h3 id=\"連結GitHub帳號\"><a href=\"#連結GitHub帳號\" class=\"headerlink\" title=\"連結GitHub帳號\"></a>連結GitHub帳號</h3><p><img src=\"/images/other/use-netlify-building-blog/04-connect-github.png\" alt=\"連結GitHub帳號\"></p>\n<h3 id=\"選擇要產生靜態網頁的repo\"><a href=\"#選擇要產生靜態網頁的repo\" class=\"headerlink\" title=\"選擇要產生靜態網頁的repo\"></a>選擇要產生靜態網頁的repo</h3><p><img src=\"/images/other/use-netlify-building-blog/05-pick-a-repo.png\" alt=\"選擇要產生靜態網頁的repo\"></p>\n<h3 id=\"Basic-build-settings-基礎建置設定\"><a href=\"#Basic-build-settings-基礎建置設定\" class=\"headerlink\" title=\"Basic build settings(基礎建置設定)\"></a>Basic build settings(基礎建置設定)</h3><p><img src=\"/images/other/use-netlify-building-blog/06-Basic-build-settings.png\" alt=\"Basic build settings\"></p>\n<p>Netlify會自動偵測使用何種框架產生靜態網頁，例如: 此部落格使用<a href=\"https://hexo.io/zh-tw/\">Hexo</a>框架產生靜態網頁</p>\n<p>若是偵測的指令有錯，可以自行在<code>Build command</code>進行修改</p>\n<ul>\n<li><strong>Build Command</strong>: 產生靜態網頁的指令(如上圖①)</li>\n<li><strong>Publish directory</strong>: 靜態網頁產生後的位置(如上圖②)</li>\n</ul>\n<p>以上若設定好之後，可以按下<code>Deploy site</code>(如上圖③)，會自動依照你的設定部屬網站</p>\n<h3 id=\"查看結果\"><a href=\"#查看結果\" class=\"headerlink\" title=\"查看結果\"></a>查看結果</h3><p><img src=\"/images/other/use-netlify-building-blog/07-deploy-complete.png\" alt=\"佈署結果\"></p>\n<p>可以看到Netlify會幫我們產生一個網址，可以點選此網址查看網站內容</p>\n<p>若是想要自定義網站網址的話，可以參考下一節<code>自定義網站網址</code></p>\n<h2 id=\"自定義網站網址\"><a href=\"#自定義網站網址\" class=\"headerlink\" title=\"自定義網站網址\"></a>自定義網站網址</h2><p>自定義網址可以在Netlify進行購買或者在外部買一個網址，接著透過Netlify DNS解析</p>\n<p>以下方法採取在Gandi購買一個網址，然後透過Netlify DNS作解析</p>\n<h3 id=\"Gandi小資料\"><a href=\"#Gandi小資料\" class=\"headerlink\" title=\"Gandi小資料\"></a>Gandi小資料</h3><blockquote>\n<p>Gandi官網：<a href=\"https://www.gandi.net/zh-Hant\">https://www.gandi.net/zh-Hant</a><br>提供網域名稱、網頁代管、SSL憑證與電子信箱…等服務</p>\n</blockquote>\n<p><img src=\"/images/other/use-netlify-building-blog/08-gandi-official-website.png\" alt=\"Gandi官網\"></p>\n<h3 id=\"在Gandi購買網址\"><a href=\"#在Gandi購買網址\" class=\"headerlink\" title=\"在Gandi購買網址\"></a>在Gandi購買網址</h3><p>確認你要買的網址沒被使用，接著就可以按下加入購物車進行購買</p>\n<p>剩下的步驟就按照網站的流程下去進行，就可以順利將此網址購買成功</p>\n<p><img src=\"/images/other/use-netlify-building-blog/09-buy-domain.png\" alt=\"確認網址並購買\"></p>\n<p>購買成功後，可以在<code>管理者界面</code>中<code>域名</code>菜單中看到所購買的網址，可以點選網址做進階設定</p>\n<p><img src=\"/images/other/use-netlify-building-blog/10-gandi-admin-console.png\" alt=\"Gandi管理者界面\"></p>\n<p><img src=\"/images/other/use-netlify-building-blog/11-domain-advance-settings.png\" alt=\"網址進階設定畫面\"></p>\n<h3 id=\"回到Netlify設定網址\"><a href=\"#回到Netlify設定網址\" class=\"headerlink\" title=\"回到Netlify設定網址\"></a>回到Netlify設定網址</h3><p>回到Netlify進入剛剛建立的<code>site</code>，接著點選<code>Domain settings</code>(如下圖①)</p>\n<p><img src=\"/images/other/use-netlify-building-blog/12-custom-domain.png\" alt=\"Domain settings\"></p>\n<p>點選<code>Add custom domain</code></p>\n<p><img src=\"/images/other/use-netlify-building-blog/13-add-custom-domain.png\" alt=\"Add custom domain\"></p>\n<p>輸入剛剛購買的網址並驗證</p>\n<p><img src=\"/images/other/use-netlify-building-blog/14-verify-domain.png\" alt=\"驗證網址\"></p>\n<p>驗證沒錯之後點選加入，接著會出現Netlify DNS Name servers(名稱伺服器)</p>\n<p><img src=\"/images/other/use-netlify-building-blog/15-netlify-dns-name-servers.png\" alt=\"Netlify DNS Name Servers\"></p>\n<p>記住這些Name Server，等等會用到</p>\n<h3 id=\"到Gandi設定Name-Server\"><a href=\"#到Gandi設定Name-Server\" class=\"headerlink\" title=\"到Gandi設定Name Server\"></a>到Gandi設定Name Server</h3><p>點選<code>名稱伺服器</code></p>\n<p><img src=\"/images/other/use-netlify-building-blog/16-enter-name-servers.png\" alt=\"網址名稱伺服器位置\"></p>\n<p>接著選擇<code>外部</code>，並填入剛剛在Netlify上看到的那4個Name Server，接著按下儲存</p>\n<p><img src=\"/images/other/use-netlify-building-blog/17-settings-gandi-outside-name-server.png\" alt=\"改成Netlify Name Server\"></p>\n<p>等它生效需要一段時間</p>\n<h3 id=\"回到Netlify查看結果\"><a href=\"#回到Netlify查看結果\" class=\"headerlink\" title=\"回到Netlify查看結果\"></a>回到Netlify查看結果</h3><p>Netlify會自動幫我們剛剛設定的網域掛上SSL/TLS憑證</p>\n<p><img src=\"/images/other/use-netlify-building-blog/18-ssl-tls.png\" alt=\"SSL/TLS憑證\"></p>\n<p>成功之後，下圖就會變成我們剛剛輸入的網址</p>\n<p><img src=\"/images/other/use-netlify-building-blog/19-finish-custom-domain.png\" alt=\"成功掛上自定義網址畫面\"></p>\n<p>恭喜你!!這樣就可以使用自定義的網址訪問你的網站了</p>\n","site":{"data":{}},"excerpt":"<p>當Blog開發好時，需要架設在一個可以託管靜態網頁的網站上，常見的服務有Netlify、Heroku、GitHub Page、GitLab Page、FireBase、S3…等服務。</p>\n<p>最後選擇了Netlify，主要是對我這種免費仔跟懶人很便利(:laughing:)，讓我們一起來看看如何在Netlify有什麼方便的服務幫助我們架設Blog吧！</p>","more":"<h2 id=\"Netlify提供了什麼服務\"><a href=\"#Netlify提供了什麼服務\" class=\"headerlink\" title=\"Netlify提供了什麼服務\"></a>Netlify提供了什麼服務</h2><p><img src=\"/images/other/use-netlify-building-blog/01_netlify_official_website.png\" alt=\"Netlify官網\"></p>\n<ul>\n<li>Netlify官網: <a href=\"https://www.netlify.com/\">https://www.netlify.com/</a></li>\n<li>託管靜態網頁</li>\n<li>可以直接連結你的GitHub or GitLab repo</li>\n<li>自動建構、部屬靜態網頁</li>\n</ul>\n<h2 id=\"將靜態網頁部屬到Netlify\"><a href=\"#將靜態網頁部屬到Netlify\" class=\"headerlink\" title=\"將靜態網頁部屬到Netlify\"></a>將靜態網頁部屬到Netlify</h2><h3 id=\"登入Netlify\"><a href=\"#登入Netlify\" class=\"headerlink\" title=\"登入Netlify\"></a>登入Netlify</h3><p><img src=\"/images/other/use-netlify-building-blog/02_github_account_login_netlify.png\" alt=\"使用GitHub帳號登入Netlify\"></p>\n<p>Netlify提供許多登入方式(如上圖)，在這裡我使用GitHub帳號登入，方便之後連結GitHub上的repo</p>\n<h3 id=\"新增靜態網頁\"><a href=\"#新增靜態網頁\" class=\"headerlink\" title=\"新增靜態網頁\"></a>新增靜態網頁</h3><p>進入 Sites 選單 &rarr; Add new site &rarr; Import an existing project</p>\n<p><img src=\"/images/other/use-netlify-building-blog/03_add_new_site.png\" alt=\"選擇已有的專案匯入\"></p>\n<h3 id=\"連結GitHub帳號\"><a href=\"#連結GitHub帳號\" class=\"headerlink\" title=\"連結GitHub帳號\"></a>連結GitHub帳號</h3><p><img src=\"/images/other/use-netlify-building-blog/04-connect-github.png\" alt=\"連結GitHub帳號\"></p>\n<h3 id=\"選擇要產生靜態網頁的repo\"><a href=\"#選擇要產生靜態網頁的repo\" class=\"headerlink\" title=\"選擇要產生靜態網頁的repo\"></a>選擇要產生靜態網頁的repo</h3><p><img src=\"/images/other/use-netlify-building-blog/05-pick-a-repo.png\" alt=\"選擇要產生靜態網頁的repo\"></p>\n<h3 id=\"Basic-build-settings-基礎建置設定\"><a href=\"#Basic-build-settings-基礎建置設定\" class=\"headerlink\" title=\"Basic build settings(基礎建置設定)\"></a>Basic build settings(基礎建置設定)</h3><p><img src=\"/images/other/use-netlify-building-blog/06-Basic-build-settings.png\" alt=\"Basic build settings\"></p>\n<p>Netlify會自動偵測使用何種框架產生靜態網頁，例如: 此部落格使用<a href=\"https://hexo.io/zh-tw/\">Hexo</a>框架產生靜態網頁</p>\n<p>若是偵測的指令有錯，可以自行在<code>Build command</code>進行修改</p>\n<ul>\n<li><strong>Build Command</strong>: 產生靜態網頁的指令(如上圖①)</li>\n<li><strong>Publish directory</strong>: 靜態網頁產生後的位置(如上圖②)</li>\n</ul>\n<p>以上若設定好之後，可以按下<code>Deploy site</code>(如上圖③)，會自動依照你的設定部屬網站</p>\n<h3 id=\"查看結果\"><a href=\"#查看結果\" class=\"headerlink\" title=\"查看結果\"></a>查看結果</h3><p><img src=\"/images/other/use-netlify-building-blog/07-deploy-complete.png\" alt=\"佈署結果\"></p>\n<p>可以看到Netlify會幫我們產生一個網址，可以點選此網址查看網站內容</p>\n<p>若是想要自定義網站網址的話，可以參考下一節<code>自定義網站網址</code></p>\n<h2 id=\"自定義網站網址\"><a href=\"#自定義網站網址\" class=\"headerlink\" title=\"自定義網站網址\"></a>自定義網站網址</h2><p>自定義網址可以在Netlify進行購買或者在外部買一個網址，接著透過Netlify DNS解析</p>\n<p>以下方法採取在Gandi購買一個網址，然後透過Netlify DNS作解析</p>\n<h3 id=\"Gandi小資料\"><a href=\"#Gandi小資料\" class=\"headerlink\" title=\"Gandi小資料\"></a>Gandi小資料</h3><blockquote>\n<p>Gandi官網：<a href=\"https://www.gandi.net/zh-Hant\">https://www.gandi.net/zh-Hant</a><br>提供網域名稱、網頁代管、SSL憑證與電子信箱…等服務</p>\n</blockquote>\n<p><img src=\"/images/other/use-netlify-building-blog/08-gandi-official-website.png\" alt=\"Gandi官網\"></p>\n<h3 id=\"在Gandi購買網址\"><a href=\"#在Gandi購買網址\" class=\"headerlink\" title=\"在Gandi購買網址\"></a>在Gandi購買網址</h3><p>確認你要買的網址沒被使用，接著就可以按下加入購物車進行購買</p>\n<p>剩下的步驟就按照網站的流程下去進行，就可以順利將此網址購買成功</p>\n<p><img src=\"/images/other/use-netlify-building-blog/09-buy-domain.png\" alt=\"確認網址並購買\"></p>\n<p>購買成功後，可以在<code>管理者界面</code>中<code>域名</code>菜單中看到所購買的網址，可以點選網址做進階設定</p>\n<p><img src=\"/images/other/use-netlify-building-blog/10-gandi-admin-console.png\" alt=\"Gandi管理者界面\"></p>\n<p><img src=\"/images/other/use-netlify-building-blog/11-domain-advance-settings.png\" alt=\"網址進階設定畫面\"></p>\n<h3 id=\"回到Netlify設定網址\"><a href=\"#回到Netlify設定網址\" class=\"headerlink\" title=\"回到Netlify設定網址\"></a>回到Netlify設定網址</h3><p>回到Netlify進入剛剛建立的<code>site</code>，接著點選<code>Domain settings</code>(如下圖①)</p>\n<p><img src=\"/images/other/use-netlify-building-blog/12-custom-domain.png\" alt=\"Domain settings\"></p>\n<p>點選<code>Add custom domain</code></p>\n<p><img src=\"/images/other/use-netlify-building-blog/13-add-custom-domain.png\" alt=\"Add custom domain\"></p>\n<p>輸入剛剛購買的網址並驗證</p>\n<p><img src=\"/images/other/use-netlify-building-blog/14-verify-domain.png\" alt=\"驗證網址\"></p>\n<p>驗證沒錯之後點選加入，接著會出現Netlify DNS Name servers(名稱伺服器)</p>\n<p><img src=\"/images/other/use-netlify-building-blog/15-netlify-dns-name-servers.png\" alt=\"Netlify DNS Name Servers\"></p>\n<p>記住這些Name Server，等等會用到</p>\n<h3 id=\"到Gandi設定Name-Server\"><a href=\"#到Gandi設定Name-Server\" class=\"headerlink\" title=\"到Gandi設定Name Server\"></a>到Gandi設定Name Server</h3><p>點選<code>名稱伺服器</code></p>\n<p><img src=\"/images/other/use-netlify-building-blog/16-enter-name-servers.png\" alt=\"網址名稱伺服器位置\"></p>\n<p>接著選擇<code>外部</code>，並填入剛剛在Netlify上看到的那4個Name Server，接著按下儲存</p>\n<p><img src=\"/images/other/use-netlify-building-blog/17-settings-gandi-outside-name-server.png\" alt=\"改成Netlify Name Server\"></p>\n<p>等它生效需要一段時間</p>\n<h3 id=\"回到Netlify查看結果\"><a href=\"#回到Netlify查看結果\" class=\"headerlink\" title=\"回到Netlify查看結果\"></a>回到Netlify查看結果</h3><p>Netlify會自動幫我們剛剛設定的網域掛上SSL/TLS憑證</p>\n<p><img src=\"/images/other/use-netlify-building-blog/18-ssl-tls.png\" alt=\"SSL/TLS憑證\"></p>\n<p>成功之後，下圖就會變成我們剛剛輸入的網址</p>\n<p><img src=\"/images/other/use-netlify-building-blog/19-finish-custom-domain.png\" alt=\"成功掛上自定義網址畫面\"></p>\n<p>恭喜你!!這樣就可以使用自定義的網址訪問你的網站了</p>"},{"title":"[Middleware] 初探gRPC","date":"2022-01-11T05:47:01.000Z","toc":true,"cover":"/images/golang/grpc-icon-color.png","_content":"\ngRPC是Google基於`Protobuf`開發的跨語言開源RPC框架。使用HTTP/2通訊協定，可以基於一個HTTP/2連線提供多個服務，對於移動設備更加友好。以下將使用Golang來說明實做\n\n<!-- more -->\n\n## grpc與REST\n\ngRPC很容易拿來與REST做比較，以下先列舉gRPC與REST的對應表，來幫助我們更快的學習\n\n| Feature  | gRPC  | REST  |\n|-|-|-|\n| Protocol  | HTTP/2  | HTTP/1.1  |\n| Payload  | Protobuf(binary, small)  | JSON(text, large) |\n| API contract | .proto | OpenAPI |\n| Code generation | protoc | Swagger |\n| Security | TLS/SSL | TLS/SSL |\n| Streaming | Bidirectional streaming | client &rarr; server |\n| Browser support | require gRPC-web | Yes |\n\n資料來源: <https://dev.to/techschoolguru/is-grpc-better-than-rest-where-to-use-it-3blg>\n\n## Protobuf\n\nProtobuf是Protocol Buffers的簡稱，是由Google公司開發的一種數據描述語言(類似XML或是JSON)。\n\n在學習gRPC之前，需要先了解Protobuf。Protobuf是gRPC裡的傳輸格式，類似Restful的JSON格式\n\n### 安裝相關插件\n\n相關安裝內容可參考[gRPC官網教學](https://grpc.io/docs/languages/go/quickstart/)\n\n#### Protocol Buffer Compiler\n\n- Linux\n\n``` bash\napt install -y protobuf-compiler\nprotoc --version  # Ensure compiler version is 3+\n```\n\n- MacOS\n\n```bash\nbrew install protobuf\nprotoc --version  # Ensure compiler version is 3+\n```\n\n#### Go Plugins\n\n1. protoc檔產生成Go語言的插件\n\n   ``` bash\n   go install google.golang.org/protobuf/cmd/protoc-gen-go\n   go install google.golang.org/grpc/cmd/protoc-gen-go-grpc\n   ```\n\n2. 設置`PATH`讓`protoc`指令能找到剛剛安裝的插件\n\n   ```bash\n   export PATH=\"$PATH:$(go env GOPATH)/bin\"\n   ```\n\n### 定義.proto檔案\n\n建立專案資料夾\n\n```bash\nmkdir grpc-sample && cd grpc-sample \n```\n\n初始化go mod\n\n```bash\ngo mod init grpc-sample \n```\n\n抓取grpc套件，供程式使用\n\n```bash\ngo get google.golang.org/grpc\n```\n\n以下我們透過一個基本的`hello.proto`檔案，來講解撰寫`.proto`所需要的內容格式\n\n```bash\nmkdir proto && cd proto\ntouch hello.proto\n```\n\nhello.proto\n\n```protobuf\nsyntax = \"proto3\";\n\npackage proto;\n\noption go_package = \"grpc-sample/proto\";\n\nservice HelloService {\n  rpc Hello (HelloRequest) returns (HelloReply);\n}\n\nmessage HelloRequest {\n  string name = 1;\n}\n\nmessage HelloReply {\n  string message = 1;\n}\n```\n\n- **syntax**: 表示採用proto3的語法。\n\n> proto3對語言進行了簡化，所有message裡的成員，均採用類似Go語言的型態初始值(不再支援自定義默認值)，也不再支援required特性\n\n- **package**: 此.proto檔所在的目錄。\n- **go_package**: 定義生成的Go程式所屬於的package\n- **message**: protobuf中最基本的數據單位，對應Go語言中的struct。\n- **service**: 定義RPC介面方法。\n\n### 生成Go語言\n\n進到有`.proto`檔案的資料夾，輸入以下指令\n\n```bash\nprotoc --go_out=. --go_opt=paths=source_relative \\\n    --go-grpc_out=. --go-grpc_opt=paths=source_relative \\\n    *.proto\n```\n\n指令輸入完之後，會產生`*.pb.go`檔案，這是可以讓Go語言使用Protobuf和gRPC的檔案\n\n> 關於protoc工具的使用，之後會有另一篇文章說明。現在先讓我們專注在如何撰寫gRPC\n\n### 實作 gRPC Server\n\n#### 實作 hello.proto 中的 HelloService\n\n```golang\ntype server struct {\n  pb.UnimplementedHelloServiceServer\n}\n\nfunc (s *server) Hello(ctx context.Context, req *pb.HelloReq) (*pb.HelloResp, error) {\n  return &pb.HelloResp{Message: \"Hello \" + req.GetName()}, nil\n}\n```\n\n#### 建立gRPC Server\n\n```golang\nconst port = \":50051\"\n\nfunc main() {\n  lis, err := net.Listen(\"tcp\", port)\n  if err != nil {\n    log.Fatalf(\"failed to listen: %v\", err)\n  }\n\n  grpcServer := grpc.NewServer()\n  pb.RegisterHelloServiceServer(grpcServer, &server{})\n  log.Printf(\"server listening at %v\", lis.Addr())\n\n  if err := grpcServer.Serve(lis); err != nil {\n    log.Fatalf(\"failed to serve: %v\", err)\n  }\n}\n```\n\n#### 啟動gRPC Server\n\n```bash\ngo run server/server.go\n```\n\n### 建立gRPC Client\n\n#### 建立與gRPC Server的連線\n\n```golang\nconst (\n  address     = \"localhost:50051\"\n  defaultName = \"world\"\n)\n\nfunc main() {\n  // 建立gRPC連線\n  conn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())\n  if err != nil {\n    log.Fatalf(\"did not connect: %v\", err)\n  }\n  defer conn.Close()\n\n  grpcClient := pb.NewHelloServiceClient(conn)\n\n  name := defaultName\n  if len(os.Args) > 1 {\n    name = os.Args[1]\n  }\n\n  ctx, cancel := context.WithTimeout(context.Background(), time.Second)\n  defer cancel()\n  // 向gRPRC server發送請求\n  resp, err := grpcClient.Hello(ctx, &pb.HelloReq{Name: name})\n  if err != nil {\n    log.Fatalf(\"could not get response: %v\", err)\n  }\n  log.Printf(\"Message: %s\", resp.GetMessage())\n}\n```\n\n#### 啟動gRPC Client\n\n```bash\ngo run client/client.go\n```\n\n啟動之後就會看到console上印出`Message: Hello world`\n\n## gRPC的優缺點\n\n總結來說，gRPC在效能上比REST快非常多(基於`HTTP/2`與`probuf`)，預設為`非同步`可以平行處理多個請求\n\n> HTTP/1.1: 一個tcp連線，client發送一個請求，server回一個相對應的請求\n> HTTP/2: 一個tcp連線，client可以發送多個請求，server可以回不只多個回應\n\n### gRPC的優點\n\n- 程式碼產生: `.proto`檔即是程式結構，並可產生多種語言相對應的程式\n- 節省網路傳輸量：速度更快、檔案更小\n- 節省 CPU 消耗：序列化以及反序列化`probuf(binary format)`，所消耗的CPU資源較JSON少\n- 嚴格規格: 定義好`.proto`的schema，只要實作就可以了。不須爭論是何種HTTP Method\n\n### gRPC的缺點\n\n- 有限的瀏覽器支援: 無法直接從瀏覽器呼叫 gRPC 服務，只能透過[gRPC-Web](https://github.com/grpc/grpc-web)處理\n- 不是人類看得懂的: prtobuf的二進位格式不是人類看得懂的\n- 需要額外的學習時間和導入成本\n\n## 總結\n\n上面解講如何撰寫.proto檔，以及如何實作gRPC server跟client\n大致上分成以下步驟:\n\n1. 下載相關插件\n2. 撰寫`.proto`檔案\n3. 將`.protoc`檔產生成相對應的語言程式檔\n4. 實作gRPC Server、gRPC client\n\n以及分析gRPC的優缺點與REST的比較\n\n完整程式碼可參閱[github](https://github.com/limitcycle/grpc-sample)\n\n## 參考資料\n\n- <https://grpc.io/docs/languages/go/quickstart/>\n- <https://pjchender.dev/golang/grpc-getting-started/>\n- <https://docs.microsoft.com/zh-tw/aspnet/core/grpc/comparison?view=aspnetcore-5.0>\n","source":"_posts/golang/grpc-1.md","raw":"---\ntitle: '[Middleware] 初探gRPC'\ndate: 2022-01-11 13:47:01\ntags: middleware\ncategories: 學習\ntoc: true\ncover: /images/golang/grpc-icon-color.png\n---\n\ngRPC是Google基於`Protobuf`開發的跨語言開源RPC框架。使用HTTP/2通訊協定，可以基於一個HTTP/2連線提供多個服務，對於移動設備更加友好。以下將使用Golang來說明實做\n\n<!-- more -->\n\n## grpc與REST\n\ngRPC很容易拿來與REST做比較，以下先列舉gRPC與REST的對應表，來幫助我們更快的學習\n\n| Feature  | gRPC  | REST  |\n|-|-|-|\n| Protocol  | HTTP/2  | HTTP/1.1  |\n| Payload  | Protobuf(binary, small)  | JSON(text, large) |\n| API contract | .proto | OpenAPI |\n| Code generation | protoc | Swagger |\n| Security | TLS/SSL | TLS/SSL |\n| Streaming | Bidirectional streaming | client &rarr; server |\n| Browser support | require gRPC-web | Yes |\n\n資料來源: <https://dev.to/techschoolguru/is-grpc-better-than-rest-where-to-use-it-3blg>\n\n## Protobuf\n\nProtobuf是Protocol Buffers的簡稱，是由Google公司開發的一種數據描述語言(類似XML或是JSON)。\n\n在學習gRPC之前，需要先了解Protobuf。Protobuf是gRPC裡的傳輸格式，類似Restful的JSON格式\n\n### 安裝相關插件\n\n相關安裝內容可參考[gRPC官網教學](https://grpc.io/docs/languages/go/quickstart/)\n\n#### Protocol Buffer Compiler\n\n- Linux\n\n``` bash\napt install -y protobuf-compiler\nprotoc --version  # Ensure compiler version is 3+\n```\n\n- MacOS\n\n```bash\nbrew install protobuf\nprotoc --version  # Ensure compiler version is 3+\n```\n\n#### Go Plugins\n\n1. protoc檔產生成Go語言的插件\n\n   ``` bash\n   go install google.golang.org/protobuf/cmd/protoc-gen-go\n   go install google.golang.org/grpc/cmd/protoc-gen-go-grpc\n   ```\n\n2. 設置`PATH`讓`protoc`指令能找到剛剛安裝的插件\n\n   ```bash\n   export PATH=\"$PATH:$(go env GOPATH)/bin\"\n   ```\n\n### 定義.proto檔案\n\n建立專案資料夾\n\n```bash\nmkdir grpc-sample && cd grpc-sample \n```\n\n初始化go mod\n\n```bash\ngo mod init grpc-sample \n```\n\n抓取grpc套件，供程式使用\n\n```bash\ngo get google.golang.org/grpc\n```\n\n以下我們透過一個基本的`hello.proto`檔案，來講解撰寫`.proto`所需要的內容格式\n\n```bash\nmkdir proto && cd proto\ntouch hello.proto\n```\n\nhello.proto\n\n```protobuf\nsyntax = \"proto3\";\n\npackage proto;\n\noption go_package = \"grpc-sample/proto\";\n\nservice HelloService {\n  rpc Hello (HelloRequest) returns (HelloReply);\n}\n\nmessage HelloRequest {\n  string name = 1;\n}\n\nmessage HelloReply {\n  string message = 1;\n}\n```\n\n- **syntax**: 表示採用proto3的語法。\n\n> proto3對語言進行了簡化，所有message裡的成員，均採用類似Go語言的型態初始值(不再支援自定義默認值)，也不再支援required特性\n\n- **package**: 此.proto檔所在的目錄。\n- **go_package**: 定義生成的Go程式所屬於的package\n- **message**: protobuf中最基本的數據單位，對應Go語言中的struct。\n- **service**: 定義RPC介面方法。\n\n### 生成Go語言\n\n進到有`.proto`檔案的資料夾，輸入以下指令\n\n```bash\nprotoc --go_out=. --go_opt=paths=source_relative \\\n    --go-grpc_out=. --go-grpc_opt=paths=source_relative \\\n    *.proto\n```\n\n指令輸入完之後，會產生`*.pb.go`檔案，這是可以讓Go語言使用Protobuf和gRPC的檔案\n\n> 關於protoc工具的使用，之後會有另一篇文章說明。現在先讓我們專注在如何撰寫gRPC\n\n### 實作 gRPC Server\n\n#### 實作 hello.proto 中的 HelloService\n\n```golang\ntype server struct {\n  pb.UnimplementedHelloServiceServer\n}\n\nfunc (s *server) Hello(ctx context.Context, req *pb.HelloReq) (*pb.HelloResp, error) {\n  return &pb.HelloResp{Message: \"Hello \" + req.GetName()}, nil\n}\n```\n\n#### 建立gRPC Server\n\n```golang\nconst port = \":50051\"\n\nfunc main() {\n  lis, err := net.Listen(\"tcp\", port)\n  if err != nil {\n    log.Fatalf(\"failed to listen: %v\", err)\n  }\n\n  grpcServer := grpc.NewServer()\n  pb.RegisterHelloServiceServer(grpcServer, &server{})\n  log.Printf(\"server listening at %v\", lis.Addr())\n\n  if err := grpcServer.Serve(lis); err != nil {\n    log.Fatalf(\"failed to serve: %v\", err)\n  }\n}\n```\n\n#### 啟動gRPC Server\n\n```bash\ngo run server/server.go\n```\n\n### 建立gRPC Client\n\n#### 建立與gRPC Server的連線\n\n```golang\nconst (\n  address     = \"localhost:50051\"\n  defaultName = \"world\"\n)\n\nfunc main() {\n  // 建立gRPC連線\n  conn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())\n  if err != nil {\n    log.Fatalf(\"did not connect: %v\", err)\n  }\n  defer conn.Close()\n\n  grpcClient := pb.NewHelloServiceClient(conn)\n\n  name := defaultName\n  if len(os.Args) > 1 {\n    name = os.Args[1]\n  }\n\n  ctx, cancel := context.WithTimeout(context.Background(), time.Second)\n  defer cancel()\n  // 向gRPRC server發送請求\n  resp, err := grpcClient.Hello(ctx, &pb.HelloReq{Name: name})\n  if err != nil {\n    log.Fatalf(\"could not get response: %v\", err)\n  }\n  log.Printf(\"Message: %s\", resp.GetMessage())\n}\n```\n\n#### 啟動gRPC Client\n\n```bash\ngo run client/client.go\n```\n\n啟動之後就會看到console上印出`Message: Hello world`\n\n## gRPC的優缺點\n\n總結來說，gRPC在效能上比REST快非常多(基於`HTTP/2`與`probuf`)，預設為`非同步`可以平行處理多個請求\n\n> HTTP/1.1: 一個tcp連線，client發送一個請求，server回一個相對應的請求\n> HTTP/2: 一個tcp連線，client可以發送多個請求，server可以回不只多個回應\n\n### gRPC的優點\n\n- 程式碼產生: `.proto`檔即是程式結構，並可產生多種語言相對應的程式\n- 節省網路傳輸量：速度更快、檔案更小\n- 節省 CPU 消耗：序列化以及反序列化`probuf(binary format)`，所消耗的CPU資源較JSON少\n- 嚴格規格: 定義好`.proto`的schema，只要實作就可以了。不須爭論是何種HTTP Method\n\n### gRPC的缺點\n\n- 有限的瀏覽器支援: 無法直接從瀏覽器呼叫 gRPC 服務，只能透過[gRPC-Web](https://github.com/grpc/grpc-web)處理\n- 不是人類看得懂的: prtobuf的二進位格式不是人類看得懂的\n- 需要額外的學習時間和導入成本\n\n## 總結\n\n上面解講如何撰寫.proto檔，以及如何實作gRPC server跟client\n大致上分成以下步驟:\n\n1. 下載相關插件\n2. 撰寫`.proto`檔案\n3. 將`.protoc`檔產生成相對應的語言程式檔\n4. 實作gRPC Server、gRPC client\n\n以及分析gRPC的優缺點與REST的比較\n\n完整程式碼可參閱[github](https://github.com/limitcycle/grpc-sample)\n\n## 參考資料\n\n- <https://grpc.io/docs/languages/go/quickstart/>\n- <https://pjchender.dev/golang/grpc-getting-started/>\n- <https://docs.microsoft.com/zh-tw/aspnet/core/grpc/comparison?view=aspnetcore-5.0>\n","slug":"golang/grpc-1","published":1,"updated":"2022-02-21T06:35:00.103Z","_id":"ckyclb86i0001pyze2pisccfe","comments":1,"layout":"post","photos":[],"link":"","content":"<p>gRPC是Google基於<code>Protobuf</code>開發的跨語言開源RPC框架。使用HTTP/2通訊協定，可以基於一個HTTP/2連線提供多個服務，對於移動設備更加友好。以下將使用Golang來說明實做</p>\n<span id=\"more\"></span>\n\n<h2 id=\"grpc與REST\"><a href=\"#grpc與REST\" class=\"headerlink\" title=\"grpc與REST\"></a>grpc與REST</h2><p>gRPC很容易拿來與REST做比較，以下先列舉gRPC與REST的對應表，來幫助我們更快的學習</p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>gRPC</th>\n<th>REST</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Protocol</td>\n<td>HTTP/2</td>\n<td>HTTP/1.1</td>\n</tr>\n<tr>\n<td>Payload</td>\n<td>Protobuf(binary, small)</td>\n<td>JSON(text, large)</td>\n</tr>\n<tr>\n<td>API contract</td>\n<td>.proto</td>\n<td>OpenAPI</td>\n</tr>\n<tr>\n<td>Code generation</td>\n<td>protoc</td>\n<td>Swagger</td>\n</tr>\n<tr>\n<td>Security</td>\n<td>TLS/SSL</td>\n<td>TLS/SSL</td>\n</tr>\n<tr>\n<td>Streaming</td>\n<td>Bidirectional streaming</td>\n<td>client &rarr; server</td>\n</tr>\n<tr>\n<td>Browser support</td>\n<td>require gRPC-web</td>\n<td>Yes</td>\n</tr>\n</tbody></table>\n<p>資料來源: <a href=\"https://dev.to/techschoolguru/is-grpc-better-than-rest-where-to-use-it-3blg\">https://dev.to/techschoolguru/is-grpc-better-than-rest-where-to-use-it-3blg</a></p>\n<h2 id=\"Protobuf\"><a href=\"#Protobuf\" class=\"headerlink\" title=\"Protobuf\"></a>Protobuf</h2><p>Protobuf是Protocol Buffers的簡稱，是由Google公司開發的一種數據描述語言(類似XML或是JSON)。</p>\n<p>在學習gRPC之前，需要先了解Protobuf。Protobuf是gRPC裡的傳輸格式，類似Restful的JSON格式</p>\n<h3 id=\"安裝相關插件\"><a href=\"#安裝相關插件\" class=\"headerlink\" title=\"安裝相關插件\"></a>安裝相關插件</h3><p>相關安裝內容可參考<a href=\"https://grpc.io/docs/languages/go/quickstart/\">gRPC官網教學</a></p>\n<h4 id=\"Protocol-Buffer-Compiler\"><a href=\"#Protocol-Buffer-Compiler\" class=\"headerlink\" title=\"Protocol Buffer Compiler\"></a>Protocol Buffer Compiler</h4><ul>\n<li>Linux</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt install -y protobuf-compiler</span><br><span class=\"line\">protoc --version  <span class=\"comment\"># Ensure compiler version is 3+</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>MacOS</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install protobuf</span><br><span class=\"line\">protoc --version  <span class=\"comment\"># Ensure compiler version is 3+</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Go-Plugins\"><a href=\"#Go-Plugins\" class=\"headerlink\" title=\"Go Plugins\"></a>Go Plugins</h4><ol>\n<li><p>protoc檔產生成Go語言的插件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go install google.golang.org/protobuf/cmd/protoc-gen-go</span><br><span class=\"line\">go install google.golang.org/grpc/cmd/protoc-gen-go-grpc</span><br></pre></td></tr></table></figure></li>\n<li><p>設置<code>PATH</code>讓<code>protoc</code>指令能找到剛剛安裝的插件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"string\">&quot;<span class=\"variable\">$PATH</span>:<span class=\"subst\">$(go env GOPATH)</span>/bin&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"定義-proto檔案\"><a href=\"#定義-proto檔案\" class=\"headerlink\" title=\"定義.proto檔案\"></a>定義.proto檔案</h3><p>建立專案資料夾</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir grpc-sample &amp;&amp; <span class=\"built_in\">cd</span> grpc-sample </span><br></pre></td></tr></table></figure>\n\n<p>初始化go mod</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go mod init grpc-sample </span><br></pre></td></tr></table></figure>\n\n<p>抓取grpc套件，供程式使用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get google.golang.org/grpc</span><br></pre></td></tr></table></figure>\n\n<p>以下我們透過一個基本的<code>hello.proto</code>檔案，來講解撰寫<code>.proto</code>所需要的內容格式</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir proto &amp;&amp; <span class=\"built_in\">cd</span> proto</span><br><span class=\"line\">touch hello.proto</span><br></pre></td></tr></table></figure>\n\n<p>hello.proto</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax = <span class=\"string\">&quot;proto3&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> proto;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">option</span> go_package = <span class=\"string\">&quot;grpc-sample/proto&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">service</span> <span class=\"title\">HelloService</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">rpc</span> Hello (HelloRequest) <span class=\"keyword\">returns</span> (HelloReply)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">HelloRequest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> name = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">HelloReply</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> <span class=\"class\"><span class=\"keyword\">message</span> = 1;</span></span><br><span class=\"line\"><span class=\"class\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>syntax</strong>: 表示採用proto3的語法。</li>\n</ul>\n<blockquote>\n<p>proto3對語言進行了簡化，所有message裡的成員，均採用類似Go語言的型態初始值(不再支援自定義默認值)，也不再支援required特性</p>\n</blockquote>\n<ul>\n<li><strong>package</strong>: 此.proto檔所在的目錄。</li>\n<li><strong>go_package</strong>: 定義生成的Go程式所屬於的package</li>\n<li><strong>message</strong>: protobuf中最基本的數據單位，對應Go語言中的struct。</li>\n<li><strong>service</strong>: 定義RPC介面方法。</li>\n</ul>\n<h3 id=\"生成Go語言\"><a href=\"#生成Go語言\" class=\"headerlink\" title=\"生成Go語言\"></a>生成Go語言</h3><p>進到有<code>.proto</code>檔案的資料夾，輸入以下指令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protoc --go_out=. --go_opt=paths=source_relative \\</span><br><span class=\"line\">    --go-grpc_out=. --go-grpc_opt=paths=source_relative \\</span><br><span class=\"line\">    *.proto</span><br></pre></td></tr></table></figure>\n\n<p>指令輸入完之後，會產生<code>*.pb.go</code>檔案，這是可以讓Go語言使用Protobuf和gRPC的檔案</p>\n<blockquote>\n<p>關於protoc工具的使用，之後會有另一篇文章說明。現在先讓我們專注在如何撰寫gRPC</p>\n</blockquote>\n<h3 id=\"實作-gRPC-Server\"><a href=\"#實作-gRPC-Server\" class=\"headerlink\" title=\"實作 gRPC Server\"></a>實作 gRPC Server</h3><h4 id=\"實作-hello-proto-中的-HelloService\"><a href=\"#實作-hello-proto-中的-HelloService\" class=\"headerlink\" title=\"實作 hello.proto 中的 HelloService\"></a>實作 hello.proto 中的 HelloService</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  pb.UnimplementedHelloServiceServer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *server)</span> <span class=\"title\">Hello</span><span class=\"params\">(ctx context.Context, req *pb.HelloReq)</span> <span class=\"params\">(*pb.HelloResp, error)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;pb.HelloResp&#123;Message: <span class=\"string\">&quot;Hello &quot;</span> + req.GetName()&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"建立gRPC-Server\"><a href=\"#建立gRPC-Server\" class=\"headerlink\" title=\"建立gRPC Server\"></a>建立gRPC Server</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> port = <span class=\"string\">&quot;:50051&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  lis, err := net.Listen(<span class=\"string\">&quot;tcp&quot;</span>, port)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatalf(<span class=\"string\">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  grpcServer := grpc.NewServer()</span><br><span class=\"line\">  pb.RegisterHelloServiceServer(grpcServer, &amp;server&#123;&#125;)</span><br><span class=\"line\">  log.Printf(<span class=\"string\">&quot;server listening at %v&quot;</span>, lis.Addr())</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := grpcServer.Serve(lis); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatalf(<span class=\"string\">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"啟動gRPC-Server\"><a href=\"#啟動gRPC-Server\" class=\"headerlink\" title=\"啟動gRPC Server\"></a>啟動gRPC Server</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go run server/server.go</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"建立gRPC-Client\"><a href=\"#建立gRPC-Client\" class=\"headerlink\" title=\"建立gRPC Client\"></a>建立gRPC Client</h3><h4 id=\"建立與gRPC-Server的連線\"><a href=\"#建立與gRPC-Server的連線\" class=\"headerlink\" title=\"建立與gRPC Server的連線\"></a>建立與gRPC Server的連線</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">  address     = <span class=\"string\">&quot;localhost:50051&quot;</span></span><br><span class=\"line\">  defaultName = <span class=\"string\">&quot;world&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 建立gRPC連線</span></span><br><span class=\"line\">  conn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatalf(<span class=\"string\">&quot;did not connect: %v&quot;</span>, err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">  grpcClient := pb.NewHelloServiceClient(conn)</span><br><span class=\"line\"></span><br><span class=\"line\">  name := defaultName</span><br><span class=\"line\">  <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(os.Args) &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">    name = os.Args[<span class=\"number\">1</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> cancel()</span><br><span class=\"line\">  <span class=\"comment\">// 向gRPRC server發送請求</span></span><br><span class=\"line\">  resp, err := grpcClient.Hello(ctx, &amp;pb.HelloReq&#123;Name: name&#125;)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatalf(<span class=\"string\">&quot;could not get response: %v&quot;</span>, err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  log.Printf(<span class=\"string\">&quot;Message: %s&quot;</span>, resp.GetMessage())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"啟動gRPC-Client\"><a href=\"#啟動gRPC-Client\" class=\"headerlink\" title=\"啟動gRPC Client\"></a>啟動gRPC Client</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go run client/client.go</span><br></pre></td></tr></table></figure>\n\n<p>啟動之後就會看到console上印出<code>Message: Hello world</code></p>\n<h2 id=\"gRPC的優缺點\"><a href=\"#gRPC的優缺點\" class=\"headerlink\" title=\"gRPC的優缺點\"></a>gRPC的優缺點</h2><p>總結來說，gRPC在效能上比REST快非常多(基於<code>HTTP/2</code>與<code>probuf</code>)，預設為<code>非同步</code>可以平行處理多個請求</p>\n<blockquote>\n<p>HTTP/1.1: 一個tcp連線，client發送一個請求，server回一個相對應的請求<br>HTTP/2: 一個tcp連線，client可以發送多個請求，server可以回不只多個回應</p>\n</blockquote>\n<h3 id=\"gRPC的優點\"><a href=\"#gRPC的優點\" class=\"headerlink\" title=\"gRPC的優點\"></a>gRPC的優點</h3><ul>\n<li>程式碼產生: <code>.proto</code>檔即是程式結構，並可產生多種語言相對應的程式</li>\n<li>節省網路傳輸量：速度更快、檔案更小</li>\n<li>節省 CPU 消耗：序列化以及反序列化<code>probuf(binary format)</code>，所消耗的CPU資源較JSON少</li>\n<li>嚴格規格: 定義好<code>.proto</code>的schema，只要實作就可以了。不須爭論是何種HTTP Method</li>\n</ul>\n<h3 id=\"gRPC的缺點\"><a href=\"#gRPC的缺點\" class=\"headerlink\" title=\"gRPC的缺點\"></a>gRPC的缺點</h3><ul>\n<li>有限的瀏覽器支援: 無法直接從瀏覽器呼叫 gRPC 服務，只能透過<a href=\"https://github.com/grpc/grpc-web\">gRPC-Web</a>處理</li>\n<li>不是人類看得懂的: prtobuf的二進位格式不是人類看得懂的</li>\n<li>需要額外的學習時間和導入成本</li>\n</ul>\n<h2 id=\"總結\"><a href=\"#總結\" class=\"headerlink\" title=\"總結\"></a>總結</h2><p>上面解講如何撰寫.proto檔，以及如何實作gRPC server跟client<br>大致上分成以下步驟:</p>\n<ol>\n<li>下載相關插件</li>\n<li>撰寫<code>.proto</code>檔案</li>\n<li>將<code>.protoc</code>檔產生成相對應的語言程式檔</li>\n<li>實作gRPC Server、gRPC client</li>\n</ol>\n<p>以及分析gRPC的優缺點與REST的比較</p>\n<p>完整程式碼可參閱<a href=\"https://github.com/limitcycle/grpc-sample\">github</a></p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://grpc.io/docs/languages/go/quickstart/\">https://grpc.io/docs/languages/go/quickstart/</a></li>\n<li><a href=\"https://pjchender.dev/golang/grpc-getting-started/\">https://pjchender.dev/golang/grpc-getting-started/</a></li>\n<li><a href=\"https://docs.microsoft.com/zh-tw/aspnet/core/grpc/comparison?view=aspnetcore-5.0\">https://docs.microsoft.com/zh-tw/aspnet/core/grpc/comparison?view=aspnetcore-5.0</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>gRPC是Google基於<code>Protobuf</code>開發的跨語言開源RPC框架。使用HTTP/2通訊協定，可以基於一個HTTP/2連線提供多個服務，對於移動設備更加友好。以下將使用Golang來說明實做</p>","more":"<h2 id=\"grpc與REST\"><a href=\"#grpc與REST\" class=\"headerlink\" title=\"grpc與REST\"></a>grpc與REST</h2><p>gRPC很容易拿來與REST做比較，以下先列舉gRPC與REST的對應表，來幫助我們更快的學習</p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>gRPC</th>\n<th>REST</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Protocol</td>\n<td>HTTP/2</td>\n<td>HTTP/1.1</td>\n</tr>\n<tr>\n<td>Payload</td>\n<td>Protobuf(binary, small)</td>\n<td>JSON(text, large)</td>\n</tr>\n<tr>\n<td>API contract</td>\n<td>.proto</td>\n<td>OpenAPI</td>\n</tr>\n<tr>\n<td>Code generation</td>\n<td>protoc</td>\n<td>Swagger</td>\n</tr>\n<tr>\n<td>Security</td>\n<td>TLS/SSL</td>\n<td>TLS/SSL</td>\n</tr>\n<tr>\n<td>Streaming</td>\n<td>Bidirectional streaming</td>\n<td>client &rarr; server</td>\n</tr>\n<tr>\n<td>Browser support</td>\n<td>require gRPC-web</td>\n<td>Yes</td>\n</tr>\n</tbody></table>\n<p>資料來源: <a href=\"https://dev.to/techschoolguru/is-grpc-better-than-rest-where-to-use-it-3blg\">https://dev.to/techschoolguru/is-grpc-better-than-rest-where-to-use-it-3blg</a></p>\n<h2 id=\"Protobuf\"><a href=\"#Protobuf\" class=\"headerlink\" title=\"Protobuf\"></a>Protobuf</h2><p>Protobuf是Protocol Buffers的簡稱，是由Google公司開發的一種數據描述語言(類似XML或是JSON)。</p>\n<p>在學習gRPC之前，需要先了解Protobuf。Protobuf是gRPC裡的傳輸格式，類似Restful的JSON格式</p>\n<h3 id=\"安裝相關插件\"><a href=\"#安裝相關插件\" class=\"headerlink\" title=\"安裝相關插件\"></a>安裝相關插件</h3><p>相關安裝內容可參考<a href=\"https://grpc.io/docs/languages/go/quickstart/\">gRPC官網教學</a></p>\n<h4 id=\"Protocol-Buffer-Compiler\"><a href=\"#Protocol-Buffer-Compiler\" class=\"headerlink\" title=\"Protocol Buffer Compiler\"></a>Protocol Buffer Compiler</h4><ul>\n<li>Linux</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt install -y protobuf-compiler</span><br><span class=\"line\">protoc --version  <span class=\"comment\"># Ensure compiler version is 3+</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>MacOS</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install protobuf</span><br><span class=\"line\">protoc --version  <span class=\"comment\"># Ensure compiler version is 3+</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Go-Plugins\"><a href=\"#Go-Plugins\" class=\"headerlink\" title=\"Go Plugins\"></a>Go Plugins</h4><ol>\n<li><p>protoc檔產生成Go語言的插件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go install google.golang.org/protobuf/cmd/protoc-gen-go</span><br><span class=\"line\">go install google.golang.org/grpc/cmd/protoc-gen-go-grpc</span><br></pre></td></tr></table></figure></li>\n<li><p>設置<code>PATH</code>讓<code>protoc</code>指令能找到剛剛安裝的插件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"string\">&quot;<span class=\"variable\">$PATH</span>:<span class=\"subst\">$(go env GOPATH)</span>/bin&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"定義-proto檔案\"><a href=\"#定義-proto檔案\" class=\"headerlink\" title=\"定義.proto檔案\"></a>定義.proto檔案</h3><p>建立專案資料夾</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir grpc-sample &amp;&amp; <span class=\"built_in\">cd</span> grpc-sample </span><br></pre></td></tr></table></figure>\n\n<p>初始化go mod</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go mod init grpc-sample </span><br></pre></td></tr></table></figure>\n\n<p>抓取grpc套件，供程式使用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get google.golang.org/grpc</span><br></pre></td></tr></table></figure>\n\n<p>以下我們透過一個基本的<code>hello.proto</code>檔案，來講解撰寫<code>.proto</code>所需要的內容格式</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir proto &amp;&amp; <span class=\"built_in\">cd</span> proto</span><br><span class=\"line\">touch hello.proto</span><br></pre></td></tr></table></figure>\n\n<p>hello.proto</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax = <span class=\"string\">&quot;proto3&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> proto;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">option</span> go_package = <span class=\"string\">&quot;grpc-sample/proto&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">service</span> <span class=\"title\">HelloService</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">rpc</span> Hello (HelloRequest) <span class=\"keyword\">returns</span> (HelloReply)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">HelloRequest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> name = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">HelloReply</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> <span class=\"class\"><span class=\"keyword\">message</span> = 1;</span></span><br><span class=\"line\"><span class=\"class\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>syntax</strong>: 表示採用proto3的語法。</li>\n</ul>\n<blockquote>\n<p>proto3對語言進行了簡化，所有message裡的成員，均採用類似Go語言的型態初始值(不再支援自定義默認值)，也不再支援required特性</p>\n</blockquote>\n<ul>\n<li><strong>package</strong>: 此.proto檔所在的目錄。</li>\n<li><strong>go_package</strong>: 定義生成的Go程式所屬於的package</li>\n<li><strong>message</strong>: protobuf中最基本的數據單位，對應Go語言中的struct。</li>\n<li><strong>service</strong>: 定義RPC介面方法。</li>\n</ul>\n<h3 id=\"生成Go語言\"><a href=\"#生成Go語言\" class=\"headerlink\" title=\"生成Go語言\"></a>生成Go語言</h3><p>進到有<code>.proto</code>檔案的資料夾，輸入以下指令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protoc --go_out=. --go_opt=paths=source_relative \\</span><br><span class=\"line\">    --go-grpc_out=. --go-grpc_opt=paths=source_relative \\</span><br><span class=\"line\">    *.proto</span><br></pre></td></tr></table></figure>\n\n<p>指令輸入完之後，會產生<code>*.pb.go</code>檔案，這是可以讓Go語言使用Protobuf和gRPC的檔案</p>\n<blockquote>\n<p>關於protoc工具的使用，之後會有另一篇文章說明。現在先讓我們專注在如何撰寫gRPC</p>\n</blockquote>\n<h3 id=\"實作-gRPC-Server\"><a href=\"#實作-gRPC-Server\" class=\"headerlink\" title=\"實作 gRPC Server\"></a>實作 gRPC Server</h3><h4 id=\"實作-hello-proto-中的-HelloService\"><a href=\"#實作-hello-proto-中的-HelloService\" class=\"headerlink\" title=\"實作 hello.proto 中的 HelloService\"></a>實作 hello.proto 中的 HelloService</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  pb.UnimplementedHelloServiceServer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *server)</span> <span class=\"title\">Hello</span><span class=\"params\">(ctx context.Context, req *pb.HelloReq)</span> <span class=\"params\">(*pb.HelloResp, error)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;pb.HelloResp&#123;Message: <span class=\"string\">&quot;Hello &quot;</span> + req.GetName()&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"建立gRPC-Server\"><a href=\"#建立gRPC-Server\" class=\"headerlink\" title=\"建立gRPC Server\"></a>建立gRPC Server</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> port = <span class=\"string\">&quot;:50051&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  lis, err := net.Listen(<span class=\"string\">&quot;tcp&quot;</span>, port)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatalf(<span class=\"string\">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  grpcServer := grpc.NewServer()</span><br><span class=\"line\">  pb.RegisterHelloServiceServer(grpcServer, &amp;server&#123;&#125;)</span><br><span class=\"line\">  log.Printf(<span class=\"string\">&quot;server listening at %v&quot;</span>, lis.Addr())</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := grpcServer.Serve(lis); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatalf(<span class=\"string\">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"啟動gRPC-Server\"><a href=\"#啟動gRPC-Server\" class=\"headerlink\" title=\"啟動gRPC Server\"></a>啟動gRPC Server</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go run server/server.go</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"建立gRPC-Client\"><a href=\"#建立gRPC-Client\" class=\"headerlink\" title=\"建立gRPC Client\"></a>建立gRPC Client</h3><h4 id=\"建立與gRPC-Server的連線\"><a href=\"#建立與gRPC-Server的連線\" class=\"headerlink\" title=\"建立與gRPC Server的連線\"></a>建立與gRPC Server的連線</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">  address     = <span class=\"string\">&quot;localhost:50051&quot;</span></span><br><span class=\"line\">  defaultName = <span class=\"string\">&quot;world&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 建立gRPC連線</span></span><br><span class=\"line\">  conn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatalf(<span class=\"string\">&quot;did not connect: %v&quot;</span>, err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">  grpcClient := pb.NewHelloServiceClient(conn)</span><br><span class=\"line\"></span><br><span class=\"line\">  name := defaultName</span><br><span class=\"line\">  <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(os.Args) &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">    name = os.Args[<span class=\"number\">1</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> cancel()</span><br><span class=\"line\">  <span class=\"comment\">// 向gRPRC server發送請求</span></span><br><span class=\"line\">  resp, err := grpcClient.Hello(ctx, &amp;pb.HelloReq&#123;Name: name&#125;)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatalf(<span class=\"string\">&quot;could not get response: %v&quot;</span>, err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  log.Printf(<span class=\"string\">&quot;Message: %s&quot;</span>, resp.GetMessage())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"啟動gRPC-Client\"><a href=\"#啟動gRPC-Client\" class=\"headerlink\" title=\"啟動gRPC Client\"></a>啟動gRPC Client</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go run client/client.go</span><br></pre></td></tr></table></figure>\n\n<p>啟動之後就會看到console上印出<code>Message: Hello world</code></p>\n<h2 id=\"gRPC的優缺點\"><a href=\"#gRPC的優缺點\" class=\"headerlink\" title=\"gRPC的優缺點\"></a>gRPC的優缺點</h2><p>總結來說，gRPC在效能上比REST快非常多(基於<code>HTTP/2</code>與<code>probuf</code>)，預設為<code>非同步</code>可以平行處理多個請求</p>\n<blockquote>\n<p>HTTP/1.1: 一個tcp連線，client發送一個請求，server回一個相對應的請求<br>HTTP/2: 一個tcp連線，client可以發送多個請求，server可以回不只多個回應</p>\n</blockquote>\n<h3 id=\"gRPC的優點\"><a href=\"#gRPC的優點\" class=\"headerlink\" title=\"gRPC的優點\"></a>gRPC的優點</h3><ul>\n<li>程式碼產生: <code>.proto</code>檔即是程式結構，並可產生多種語言相對應的程式</li>\n<li>節省網路傳輸量：速度更快、檔案更小</li>\n<li>節省 CPU 消耗：序列化以及反序列化<code>probuf(binary format)</code>，所消耗的CPU資源較JSON少</li>\n<li>嚴格規格: 定義好<code>.proto</code>的schema，只要實作就可以了。不須爭論是何種HTTP Method</li>\n</ul>\n<h3 id=\"gRPC的缺點\"><a href=\"#gRPC的缺點\" class=\"headerlink\" title=\"gRPC的缺點\"></a>gRPC的缺點</h3><ul>\n<li>有限的瀏覽器支援: 無法直接從瀏覽器呼叫 gRPC 服務，只能透過<a href=\"https://github.com/grpc/grpc-web\">gRPC-Web</a>處理</li>\n<li>不是人類看得懂的: prtobuf的二進位格式不是人類看得懂的</li>\n<li>需要額外的學習時間和導入成本</li>\n</ul>\n<h2 id=\"總結\"><a href=\"#總結\" class=\"headerlink\" title=\"總結\"></a>總結</h2><p>上面解講如何撰寫.proto檔，以及如何實作gRPC server跟client<br>大致上分成以下步驟:</p>\n<ol>\n<li>下載相關插件</li>\n<li>撰寫<code>.proto</code>檔案</li>\n<li>將<code>.protoc</code>檔產生成相對應的語言程式檔</li>\n<li>實作gRPC Server、gRPC client</li>\n</ol>\n<p>以及分析gRPC的優缺點與REST的比較</p>\n<p>完整程式碼可參閱<a href=\"https://github.com/limitcycle/grpc-sample\">github</a></p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://grpc.io/docs/languages/go/quickstart/\">https://grpc.io/docs/languages/go/quickstart/</a></li>\n<li><a href=\"https://pjchender.dev/golang/grpc-getting-started/\">https://pjchender.dev/golang/grpc-getting-started/</a></li>\n<li><a href=\"https://docs.microsoft.com/zh-tw/aspnet/core/grpc/comparison?view=aspnetcore-5.0\">https://docs.microsoft.com/zh-tw/aspnet/core/grpc/comparison?view=aspnetcore-5.0</a></li>\n</ul>"},{"title":"[Golang] 錯誤處理","date":"2022-01-25T02:02:10.000Z","toc":true,"cover":"/images/golang/error/error-cover.jpeg","_content":"\nGolang的Error Handling有以下問題，一直被許多人詬病\n\n1. Error Handling穿插在golang代碼中，造成業務邏輯代碼可讀性受到影響\n2. 大量且重複的`if err != nil`無法簡化\n3. 簡單的`return err`不能適用所有場景\n\n那麼，到底怎樣才是Golang Error Handling最好作法呢？\n\n<!-- more -->\n\n## 設計思維\n\n### Errors are values\n\n`Errors are values`是Golang創始人之一的Rob Pike對error的設計理念。他認為error和方法的其他返回值一樣，只是多返回值裡面的其中之一，並沒有特別之處。因此，對error的處理就跟對方法其他的返回值一樣處理即可。\n\n### 考慮失敗，而不是成功\n\n在調用任何方法時，都要考慮到它失敗的結果。\n> 當方法回傳value和error，不能對這個value有任何假設，必須先判定error。唯一可以忽略error的是你連value都不關心。\n\n### 完全交給你控制error\n\n## Error定義\n\nGolang的error如同上面所說的是一個普通的值，翻看源碼為一個簡單的介面。\n\n```golang\n// The error built-in interface type is the conventional interface for\n// representing an error condition, with the nil value representing no error.\ntype error interface {\n  Error() string\n}\n```\n\n### 建立Error\n\n在Golang標準庫和許多第三方Go框架中，我們通常使用`errors.New`方法來建立error\n\n```golang\n// https://pkg.go.dev/io\n\nvar ErrShortWrite = errors.New(\"short write\")\n\nvar ErrShortBuffer = errors.New(\"short buffer\")\n\nvar EOF = errors.New(\"EOF\")\n\nvar ErrUnexpectedEOF = errors.New(\"unexpected EOF\")\n\nvar ErrNoProgress = errors.New(\"multiple Read calls return no data or error\")\n```\n\n**這裡會有個重點需要注意**: `errors.New()`方法即使創建相同字串內容的error也不是同一個error。為什麼會這樣呢？以下會有詳細說明\n\n```golang\npackage main\n\nimport (\n  \"errors\"\n  \"fmt\"\n)\n\nvar EOF = errors.New(\"EOF\")\n\nfunc main() {\n  fmt.Println(EOF == errors.New(\"EOF\")) // output: false\n}\n```\n\n### errors.New()源碼解析\n\nerrors.New()源碼:\n\n```golang\npackage errors\n\n// New returns an error that formats as the given text.\n// Each call to New returns a distinct error value even if the text is identical.\nfunc New(text string) error {\n  return &errorString{text} // 注意這裡：返回的是&errorString{text}指針，而不是errorString{text}值\n}\n\n// errorString is a trivial implementation of error.\ntype errorString struct {\n  s string\n}\n\nfunc (e *errorString) Error() string {\n  return e.s\n}\n```\n\n> 在Golang中，指針的等值是根據記憶體位置。因此，即使兩個errors.New裡的字串內容相同，但等值比較也會回傳`false`\n\n### errors.New()為什麼是回傳指針\n\n我們先來看一個例子，我們模仿`errors.New()`創建一個自定義的錯誤，但與標準庫不同的是，我們自定義錯誤回傳的是值，而不是指針\n\n```golang\ntype myError struct {\n  s string\n}\n\nfunc (me myError) Error() string {\n  return me.s\n}\n\nfunc New(text string) error {\n  return myError{text} // 這裡返回值，而不是指針\n}\n\nvar errorA = New(\"error a\")\nvar errorB = errors.New(\"error b\")\n\nfunc main() {\n  fmt.Println(errorA == New(\"error a\")) // output: true\n\n  fmt.Println(errorB == errors.New(\"error b\")) // output: false\n}\n```\n\n可以看到我們自定義的`myError`在比對時，只要字串相同就會回傳`true`。\n\n**這時我們就需要想如果字串相同就回傳`true`會有什麼問題?**\n\n> 假設在不同的package定義不同的error，但error裡的字串相同。在進行錯誤比對時，會造成程式誤判，導致進入非預期的錯誤處理流程\n\n## 錯誤類型\n\n### Sentinel Error\n\n預定義的特定錯誤，我們稱為`sentinel error`，然後在調用的時候進行比對判斷。在標準庫與第三方框架大量使用這種方法，例如下方`io`標準庫裡定義的錯誤\n\n```golang\n// EOF is the error returned by Read when no more input is available.\n// Functions should return EOF only to signal a graceful end of input.\n// If the EOF occurs unexpectedly in a structured data stream,\n// the appropriate error is either ErrUnexpectedEOF or some other error\n// giving more detail.\nvar EOF = errors.New(\"EOF\")\n\n// ErrUnexpectedEOF means that EOF was encountered in the\n// middle of reading a fixed-size block or data structure.\nvar ErrUnexpectedEOF = errors.New(\"unexpected EOF\")\n\n// ErrNoProgress is returned by some clients of an io.Reader when\n// many calls to Read have failed to return any data or error,\n// usually the sign of a broken io.Reader implementation.\nvar ErrNoProgress = errors.New(\"multiple Read calls return no data or error\")\n```\n\n進行比對時，我們一般使用`==`或者`errors.Is`進行判斷\n\n```golang\nif err == io.EOF {\n  // do something\n}\n\nif errors.Is(err, io.EOF){\n  // do something\n}\n```\n\n這種錯誤類型有以下缺點\n\n1. 會與調用此錯誤的package形成依賴\n2. 將這些錯誤類型當成API暴露給第三方\n3. 包含的錯誤訊息十分有限\n\n導致在重構或升級時會很麻煩\n\n### Error type\n\n`Error type`跟我們前面自定義的`myError`一樣實現了`error`介面\n\n```golang\ntype MyError struct {\n  line int\n  file string\n  s string\n}\n\nfunc (e *MyError) Error() string {\n  return fmt.Sprint(\"%s:%d: %s\", e.file, e.line, e.s)\n}\n\nfunc New(file string, line int, s string) error {\n  return &MyError{line: line, file: file, s: s}\n}\n```\n\n然後在外部使用`類型判斷`來判斷是否是此種錯誤類型\n\n```golang\nfunc f() {\n  switch err.(type) {\n    case *MyStruct:\n    // ...\n    case others:\n    // ...\n  }\n}\n```\n\n這種方式對於`sentinel error`來說，可以包含更詳細的信息。但也會有將此錯誤類型提供給外部的問題，例如標準庫中的`os.PathError`\n\n### Opaque errors\n\n為不透明的錯誤處理，這種方式最大的好處就是**只返回錯誤，暴露錯誤判別介面**，不返回類型\n\ngolang [net](https://pkg.go.dev/net#Error)裡的Error\n\n```golang\ntype Error interface {\n  error\n  Timeout() bool   // Is the error a timeout?\n  Temporary() bool // Is the error temporary?\n}\n\n// 錯誤處理\nif nerr, ok := err.(net.Error); ok && nerr.Temporary() {\n    // 處理\n    return\n}\n\nif err != nil {\n\n}\n```\n\n也可以這樣改寫\n\n```golang\ntype temporary interface {\n  Temporary() bool\n}\n\nfunc IsTemporary(err error) bool {\n  te, ok := err.(temporary)\n  return ok && te.Temporary()\n}\n```\n\n這種方式我們可以判斷錯誤**實現了某種特定的行為**，而不是判斷錯誤是某種特定類型或者值。這樣可以減少API的暴露，後續的處理會比較靈活，這樣使用在公用庫會比較好\n\n## Error Handle\n\n### Eliminate error handling by eliminating errors\n\n詳細可參考The Go Blog: <https://go.dev/blog/errors-are-values>\n\n改寫前\n\n```golang\n_, err = fd.Write(p0[a:b])\nif err != nil {\n    return err\n}\n_, err = fd.Write(p1[c:d])\nif err != nil {\n    return err\n}\n_, err = fd.Write(p2[e:f])\nif err != nil {\n    return err\n}\n// and so on\n```\n\n改寫後\n\n```golang\ntype errWriter struct {\n  w   io.Writer\n  err error\n}\n\nfunc (ew *errWriter) write(buf []byte) {\n  if ew.err != nil {\n      return\n  }\n  _, ew.err = ew.w.Write(buf)\n}\n\n// 使用時\new := &errWriter{w: fd}\new.write(p0[a:b])\new.write(p1[c:d])\new.write(p2[e:f])\n// and so on\nif ew.err != nil {\n    return ew.err\n}\n```\n\n標準庫中的`bufio.Writer`也有這種用法。這種就是將重複的邏輯進行封裝，然後把error進行暫存，接著我們只需要在最後判斷error就行了\n\n### go1.13前的fmt.Errorf\n\n在Go1.13版以前，我們可以透過`fmt.Errorf`包裝一個error類型並返回一個新的error類型\n\n```golang\nif err == os.ErrNotExist {\n  return fmt.Errorf(\"xxx.go meet err: %v\", err)\n}\n```\n\n透過`fmt.Errorf`包裝，會將原有的error類型丟失，因此無法使用`==`比較。那如果希望保留error的原始類型，應該如何完成呢？\n\n### go1.13的Error Wrapping\n\n#### Wrap\n\nGo1.13版提出了`Error Wrapping`的概念，透過`fmt.Errorf`的使用來保留error的原始類型，使用範例如下：\n\n```golang\nfunc top() error {\n  if err := middle(); err != nil {\n    return fmt.Errorf(\"error wrapper 2 : %w\", err)\n  }\n  return nil\n}\n\nfunc middle() error {\n  if err := bottom(); err != nil {\n    return fmt.Errorf(\"error wrapper 1 : %w\", err)\n  }\n  return nil\n}\n\nfunc bottom() error {\n  return errors.New(\"core error\")\n}\n```\n\n不仔細看的話，會以為跟之前的`fmt.Errorf`一樣。這裡的區別是在`%v`和`%w`兩個不同的佔位符。`%w`是Go1.13版本新增的佔位符類型，透過結構體嵌套來紀錄error的原始類型\n\n![Go Error Wrap](/images/golang/error/wrap.png)\n\n#### UnWrap\n\n與`wrap`相對應的是`unwrap`。Go1.13的標準庫`errors`提供了`Unwrap`方法，每調用一次`Unwrap`就能夠拆開一層錯誤類型\n\n```golang\nerr := top()\n\nfor err != nil {\n  t.Log(err)\n  err = errors.Unwrap(err)\n}\n// Output\n// error wrapper 2 : error wrapper 1 : core error\n// error wrapper 1 : core error\n// core error\n```\n\n![Go Error Unwrap](/images/golang/error/unwrap.png)\n\n### Is和AS\n\n`Is`和`As`是Go1.13 errors包裡提供的兩個核心方法：\n\n1. `Is`與上述的`==`相同\n\n    ```golang\n    // Similar to:\n    //   if err == ErrNotFound { … }\n    if errors.Is(err, ErrNotFound) {\n        // something wasn't found\n    }\n    ```\n  \n2. `As`用於判斷是否為特定的錯誤類型\n\n    ```golang\n    // Similar to:\n    //   if e, ok := err.(*QueryError); ok { … }\n    var e *QueryError\n    // Note: *QueryError is the type of the error.\n    if errors.As(err, &e) {\n      // err is a *QueryError, and e is set to the error's value\n    }\n    ```\n\n### pkg/errors\n\nGo1.13版本的Error Wrapping是借鑒社區開源庫: <https://github.com/pkg/errors>。不僅如此，pkg/errors還提供了打印`Error Stack`的功能\n\n1. error源頭使用`errors.New`\n\n    ```golang\n    func bottom() error {\n      return errors.New(\"bottom error\")\n    }\n    ```\n\n2. error調用鏈裡使用errors.Wrap\n\n    ```golang\n    func top() error {\n      if err := middle(); err != nil {\n        return errors.Wrap(err, \"top error\")\n      }\n      return nil\n    }\n\n    func middle() error {\n      if err := bottom(); err != nil {\n        return errors.Wrap(err, \"middle error\")\n      }\n    return nil\n   }\n   ```\n\n3. 獲取error的RootCause和Error Stack\n\n    ```golang\n    func main() {\n      fmt.Printf(\"%+v\", errors.Cause(top()))\n    }\n\n    // output\n    bottom error\n    main.bottom\n      /Users/wuguohua/Workspace/Go/src/github.com/KevinWu0904/interview/main.go:30\n    main.middle\n      /Users/wuguohua/Workspace/Go/src/github.com/KevinWu0904/interview/main.go:22\n    main.top\n      /Users/wuguohua/Workspace/Go/src/github.com/KevinWu0904/interview/main.go:14\n    main.main\n      /Users/wuguohua/Workspace/Go/src/github.com/KevinWu0904/interview/main.go:10\n    runtime.main\n      /Users/wuguohua/.gvm/gos/go1.15.8/src/runtime/proc.go:204\n    runtime.goexit\n      /Users/wuguohua/.gvm/gos/go1.15.8/src/runtime/asm_amd64.s:1374\n    Process finished with the exit code 0\n    ```\n\n4. 完整代碼\n\n    ```golang\n    package main\n\n    import (\n      \"fmt\"\n      \"github.com/pkg/errors\"\n    )\n\n    func main() {\n      fmt.Printf(\"%+v\", errors.Cause(top()))\n    }\n\n    func top() error {\n      if err := middle(); err != nil {\n        return errors.Wrap(err, \"top error\")\n      }\n      return nil\n    }\n\n    func middle() error {\n      if err := bottom(); err != nil {\n        return errors.Wrap(err, \"middle error\")\n      }\n      return nil\n    }\n\n    func bottom() error {\n      return errors.New(\"bottom error\")\n    }\n    ```\n\n### 小結\n\n+ Sentinel Error與Error Wrapping一起使用\n+ 如果需要Error Stack資訊，則推薦使用`pkg/errors`\n\n## Go2 Draft Design\n\nGo2 Error Handling仍處於Proposal階段(尚未定版)，我們先看官方目前所提供的範例\n\n改造前:\n\n```golang\nfunc printSum(a, b string) error {\n  x, err := strconv.Atoi(a)\n  if err != nil {\n    return err\n  }\n  y, err := strconv.Atoi(b)\n  if err != nil {\n    return err\n  }\n  fmt.Println(\"result:\", x + y)\n  return nil\n}\n```\n\n改造後:\n\n```golang\nfunc printSum(a, b string) error {\n  handle err { return err }\n  x := check strconv.Atoi(a)\n  y := check strconv.Atoi(b)\n  fmt.Println(\"result:\", x + y)\n  return nil\n}\n```\n\nGo2計畫引入兩個關鍵字`handle`和`check`來簡化error對業務邏輯的分割和大量重複的`if err != nil`\n\n可以看到，改造後的代碼明顯減少，可讀性大大增加。並且handle對最終error進行統一處理，減少重複邏輯\n\n不過，由於Go2尚未發佈，就讓我們拭目以待未來Go2能夠成功簡化error吧！\n\n## Panic\n\nGolang中的`panic`代表著程式中不可恢復的錯誤，例如索引越界、不可恢復的環境問題、stack溢位。使用上有以下幾點需要注意：\n\n1. 在程式啟動時，如果有強依賴的服務故障時，使用`panic`退出\n2. 在程式啟動時，如果有配置文件不符合規定時，使用`panic`退出(防禦程序)\n3. 其他時候只要不是不可恢復的錯誤，不該使用`panic`應該使用`error`\n4. 在程式進入點，例如`gin`需要使用`recover`預防程式退出\n5. 在程式中應該避免使用野生的`goroutine`\n    i. 如果需要異步任務，應該使用異步`worker`，消息通知的方式進行處理，避免產生大量的`goroutine`\n    ii. 如果需要使用`goroutine`時，應該使用統一的方法進行創建，這個方法中會運行`recover`，避免野生`goroutine` `panic`導致主程序退出\n\n```golang\nfunc Go(f func()) {\n  go func() {\n    defer func() {\n      if err := recover(); err != nil {\n        log.Printf(\"panic: %+v\", err)\n      }\n    }()\n\n    f()\n  }()\n}\n```\n\n## 最佳實踐\n\n1. 在我們自定義的方法中，使用`errors.New`或者`errors.Errorf`返回錯誤\n  \n    ```golang\n    func myfun(args []string) error {\n      if len(args) < 3 {\n        return errors.Errorf(\"not enouth arguments...\")\n      }\n      return nil\n    }\n    ``\n\n2. 若調用其他方法，請直接返回錯誤。若需要夾帶訊息，請使用`errors.WithMessage`\n\n    ```golang\n    if err != nil {\n      // 直接返回\n      // return err \n      return errors.WithMessage(err, \"xxx\")\n    }\n    ```\n\n3. 如果使用標準庫或其他第三方套件時，請使用`errors.Wrap`保存stack訊息\n4. 在程序的進入點或者goroutine進入點，使用`%+v`印出stack訊息\n\n## 總結\n\n此篇文章介紹了Go error的特點與目前最佳實踐。golang error設計可以說是golang的特點也是缺點，相信官方會針對這個問題慢慢提出最佳解法的\n\n## 參考資料\n\n+ <https://lailin.xyz/post/go-training-03.html>\n+ <https://www.kevinwu0904.top/blogs/golang-error>\n+ <https://go.dev/blog/go1.13-errors>\n+ <https://go.googlesource.com/proposal/+/master/design/29934-error-values.md>\n","source":"_posts/golang/errors.md","raw":"---\ntitle: '[Golang] 錯誤處理'\ndate: 2022-01-25 10:02:10\ntags: golang\ncategories: 學習\ntoc: true\ncover: /images/golang/error/error-cover.jpeg\n---\n\nGolang的Error Handling有以下問題，一直被許多人詬病\n\n1. Error Handling穿插在golang代碼中，造成業務邏輯代碼可讀性受到影響\n2. 大量且重複的`if err != nil`無法簡化\n3. 簡單的`return err`不能適用所有場景\n\n那麼，到底怎樣才是Golang Error Handling最好作法呢？\n\n<!-- more -->\n\n## 設計思維\n\n### Errors are values\n\n`Errors are values`是Golang創始人之一的Rob Pike對error的設計理念。他認為error和方法的其他返回值一樣，只是多返回值裡面的其中之一，並沒有特別之處。因此，對error的處理就跟對方法其他的返回值一樣處理即可。\n\n### 考慮失敗，而不是成功\n\n在調用任何方法時，都要考慮到它失敗的結果。\n> 當方法回傳value和error，不能對這個value有任何假設，必須先判定error。唯一可以忽略error的是你連value都不關心。\n\n### 完全交給你控制error\n\n## Error定義\n\nGolang的error如同上面所說的是一個普通的值，翻看源碼為一個簡單的介面。\n\n```golang\n// The error built-in interface type is the conventional interface for\n// representing an error condition, with the nil value representing no error.\ntype error interface {\n  Error() string\n}\n```\n\n### 建立Error\n\n在Golang標準庫和許多第三方Go框架中，我們通常使用`errors.New`方法來建立error\n\n```golang\n// https://pkg.go.dev/io\n\nvar ErrShortWrite = errors.New(\"short write\")\n\nvar ErrShortBuffer = errors.New(\"short buffer\")\n\nvar EOF = errors.New(\"EOF\")\n\nvar ErrUnexpectedEOF = errors.New(\"unexpected EOF\")\n\nvar ErrNoProgress = errors.New(\"multiple Read calls return no data or error\")\n```\n\n**這裡會有個重點需要注意**: `errors.New()`方法即使創建相同字串內容的error也不是同一個error。為什麼會這樣呢？以下會有詳細說明\n\n```golang\npackage main\n\nimport (\n  \"errors\"\n  \"fmt\"\n)\n\nvar EOF = errors.New(\"EOF\")\n\nfunc main() {\n  fmt.Println(EOF == errors.New(\"EOF\")) // output: false\n}\n```\n\n### errors.New()源碼解析\n\nerrors.New()源碼:\n\n```golang\npackage errors\n\n// New returns an error that formats as the given text.\n// Each call to New returns a distinct error value even if the text is identical.\nfunc New(text string) error {\n  return &errorString{text} // 注意這裡：返回的是&errorString{text}指針，而不是errorString{text}值\n}\n\n// errorString is a trivial implementation of error.\ntype errorString struct {\n  s string\n}\n\nfunc (e *errorString) Error() string {\n  return e.s\n}\n```\n\n> 在Golang中，指針的等值是根據記憶體位置。因此，即使兩個errors.New裡的字串內容相同，但等值比較也會回傳`false`\n\n### errors.New()為什麼是回傳指針\n\n我們先來看一個例子，我們模仿`errors.New()`創建一個自定義的錯誤，但與標準庫不同的是，我們自定義錯誤回傳的是值，而不是指針\n\n```golang\ntype myError struct {\n  s string\n}\n\nfunc (me myError) Error() string {\n  return me.s\n}\n\nfunc New(text string) error {\n  return myError{text} // 這裡返回值，而不是指針\n}\n\nvar errorA = New(\"error a\")\nvar errorB = errors.New(\"error b\")\n\nfunc main() {\n  fmt.Println(errorA == New(\"error a\")) // output: true\n\n  fmt.Println(errorB == errors.New(\"error b\")) // output: false\n}\n```\n\n可以看到我們自定義的`myError`在比對時，只要字串相同就會回傳`true`。\n\n**這時我們就需要想如果字串相同就回傳`true`會有什麼問題?**\n\n> 假設在不同的package定義不同的error，但error裡的字串相同。在進行錯誤比對時，會造成程式誤判，導致進入非預期的錯誤處理流程\n\n## 錯誤類型\n\n### Sentinel Error\n\n預定義的特定錯誤，我們稱為`sentinel error`，然後在調用的時候進行比對判斷。在標準庫與第三方框架大量使用這種方法，例如下方`io`標準庫裡定義的錯誤\n\n```golang\n// EOF is the error returned by Read when no more input is available.\n// Functions should return EOF only to signal a graceful end of input.\n// If the EOF occurs unexpectedly in a structured data stream,\n// the appropriate error is either ErrUnexpectedEOF or some other error\n// giving more detail.\nvar EOF = errors.New(\"EOF\")\n\n// ErrUnexpectedEOF means that EOF was encountered in the\n// middle of reading a fixed-size block or data structure.\nvar ErrUnexpectedEOF = errors.New(\"unexpected EOF\")\n\n// ErrNoProgress is returned by some clients of an io.Reader when\n// many calls to Read have failed to return any data or error,\n// usually the sign of a broken io.Reader implementation.\nvar ErrNoProgress = errors.New(\"multiple Read calls return no data or error\")\n```\n\n進行比對時，我們一般使用`==`或者`errors.Is`進行判斷\n\n```golang\nif err == io.EOF {\n  // do something\n}\n\nif errors.Is(err, io.EOF){\n  // do something\n}\n```\n\n這種錯誤類型有以下缺點\n\n1. 會與調用此錯誤的package形成依賴\n2. 將這些錯誤類型當成API暴露給第三方\n3. 包含的錯誤訊息十分有限\n\n導致在重構或升級時會很麻煩\n\n### Error type\n\n`Error type`跟我們前面自定義的`myError`一樣實現了`error`介面\n\n```golang\ntype MyError struct {\n  line int\n  file string\n  s string\n}\n\nfunc (e *MyError) Error() string {\n  return fmt.Sprint(\"%s:%d: %s\", e.file, e.line, e.s)\n}\n\nfunc New(file string, line int, s string) error {\n  return &MyError{line: line, file: file, s: s}\n}\n```\n\n然後在外部使用`類型判斷`來判斷是否是此種錯誤類型\n\n```golang\nfunc f() {\n  switch err.(type) {\n    case *MyStruct:\n    // ...\n    case others:\n    // ...\n  }\n}\n```\n\n這種方式對於`sentinel error`來說，可以包含更詳細的信息。但也會有將此錯誤類型提供給外部的問題，例如標準庫中的`os.PathError`\n\n### Opaque errors\n\n為不透明的錯誤處理，這種方式最大的好處就是**只返回錯誤，暴露錯誤判別介面**，不返回類型\n\ngolang [net](https://pkg.go.dev/net#Error)裡的Error\n\n```golang\ntype Error interface {\n  error\n  Timeout() bool   // Is the error a timeout?\n  Temporary() bool // Is the error temporary?\n}\n\n// 錯誤處理\nif nerr, ok := err.(net.Error); ok && nerr.Temporary() {\n    // 處理\n    return\n}\n\nif err != nil {\n\n}\n```\n\n也可以這樣改寫\n\n```golang\ntype temporary interface {\n  Temporary() bool\n}\n\nfunc IsTemporary(err error) bool {\n  te, ok := err.(temporary)\n  return ok && te.Temporary()\n}\n```\n\n這種方式我們可以判斷錯誤**實現了某種特定的行為**，而不是判斷錯誤是某種特定類型或者值。這樣可以減少API的暴露，後續的處理會比較靈活，這樣使用在公用庫會比較好\n\n## Error Handle\n\n### Eliminate error handling by eliminating errors\n\n詳細可參考The Go Blog: <https://go.dev/blog/errors-are-values>\n\n改寫前\n\n```golang\n_, err = fd.Write(p0[a:b])\nif err != nil {\n    return err\n}\n_, err = fd.Write(p1[c:d])\nif err != nil {\n    return err\n}\n_, err = fd.Write(p2[e:f])\nif err != nil {\n    return err\n}\n// and so on\n```\n\n改寫後\n\n```golang\ntype errWriter struct {\n  w   io.Writer\n  err error\n}\n\nfunc (ew *errWriter) write(buf []byte) {\n  if ew.err != nil {\n      return\n  }\n  _, ew.err = ew.w.Write(buf)\n}\n\n// 使用時\new := &errWriter{w: fd}\new.write(p0[a:b])\new.write(p1[c:d])\new.write(p2[e:f])\n// and so on\nif ew.err != nil {\n    return ew.err\n}\n```\n\n標準庫中的`bufio.Writer`也有這種用法。這種就是將重複的邏輯進行封裝，然後把error進行暫存，接著我們只需要在最後判斷error就行了\n\n### go1.13前的fmt.Errorf\n\n在Go1.13版以前，我們可以透過`fmt.Errorf`包裝一個error類型並返回一個新的error類型\n\n```golang\nif err == os.ErrNotExist {\n  return fmt.Errorf(\"xxx.go meet err: %v\", err)\n}\n```\n\n透過`fmt.Errorf`包裝，會將原有的error類型丟失，因此無法使用`==`比較。那如果希望保留error的原始類型，應該如何完成呢？\n\n### go1.13的Error Wrapping\n\n#### Wrap\n\nGo1.13版提出了`Error Wrapping`的概念，透過`fmt.Errorf`的使用來保留error的原始類型，使用範例如下：\n\n```golang\nfunc top() error {\n  if err := middle(); err != nil {\n    return fmt.Errorf(\"error wrapper 2 : %w\", err)\n  }\n  return nil\n}\n\nfunc middle() error {\n  if err := bottom(); err != nil {\n    return fmt.Errorf(\"error wrapper 1 : %w\", err)\n  }\n  return nil\n}\n\nfunc bottom() error {\n  return errors.New(\"core error\")\n}\n```\n\n不仔細看的話，會以為跟之前的`fmt.Errorf`一樣。這裡的區別是在`%v`和`%w`兩個不同的佔位符。`%w`是Go1.13版本新增的佔位符類型，透過結構體嵌套來紀錄error的原始類型\n\n![Go Error Wrap](/images/golang/error/wrap.png)\n\n#### UnWrap\n\n與`wrap`相對應的是`unwrap`。Go1.13的標準庫`errors`提供了`Unwrap`方法，每調用一次`Unwrap`就能夠拆開一層錯誤類型\n\n```golang\nerr := top()\n\nfor err != nil {\n  t.Log(err)\n  err = errors.Unwrap(err)\n}\n// Output\n// error wrapper 2 : error wrapper 1 : core error\n// error wrapper 1 : core error\n// core error\n```\n\n![Go Error Unwrap](/images/golang/error/unwrap.png)\n\n### Is和AS\n\n`Is`和`As`是Go1.13 errors包裡提供的兩個核心方法：\n\n1. `Is`與上述的`==`相同\n\n    ```golang\n    // Similar to:\n    //   if err == ErrNotFound { … }\n    if errors.Is(err, ErrNotFound) {\n        // something wasn't found\n    }\n    ```\n  \n2. `As`用於判斷是否為特定的錯誤類型\n\n    ```golang\n    // Similar to:\n    //   if e, ok := err.(*QueryError); ok { … }\n    var e *QueryError\n    // Note: *QueryError is the type of the error.\n    if errors.As(err, &e) {\n      // err is a *QueryError, and e is set to the error's value\n    }\n    ```\n\n### pkg/errors\n\nGo1.13版本的Error Wrapping是借鑒社區開源庫: <https://github.com/pkg/errors>。不僅如此，pkg/errors還提供了打印`Error Stack`的功能\n\n1. error源頭使用`errors.New`\n\n    ```golang\n    func bottom() error {\n      return errors.New(\"bottom error\")\n    }\n    ```\n\n2. error調用鏈裡使用errors.Wrap\n\n    ```golang\n    func top() error {\n      if err := middle(); err != nil {\n        return errors.Wrap(err, \"top error\")\n      }\n      return nil\n    }\n\n    func middle() error {\n      if err := bottom(); err != nil {\n        return errors.Wrap(err, \"middle error\")\n      }\n    return nil\n   }\n   ```\n\n3. 獲取error的RootCause和Error Stack\n\n    ```golang\n    func main() {\n      fmt.Printf(\"%+v\", errors.Cause(top()))\n    }\n\n    // output\n    bottom error\n    main.bottom\n      /Users/wuguohua/Workspace/Go/src/github.com/KevinWu0904/interview/main.go:30\n    main.middle\n      /Users/wuguohua/Workspace/Go/src/github.com/KevinWu0904/interview/main.go:22\n    main.top\n      /Users/wuguohua/Workspace/Go/src/github.com/KevinWu0904/interview/main.go:14\n    main.main\n      /Users/wuguohua/Workspace/Go/src/github.com/KevinWu0904/interview/main.go:10\n    runtime.main\n      /Users/wuguohua/.gvm/gos/go1.15.8/src/runtime/proc.go:204\n    runtime.goexit\n      /Users/wuguohua/.gvm/gos/go1.15.8/src/runtime/asm_amd64.s:1374\n    Process finished with the exit code 0\n    ```\n\n4. 完整代碼\n\n    ```golang\n    package main\n\n    import (\n      \"fmt\"\n      \"github.com/pkg/errors\"\n    )\n\n    func main() {\n      fmt.Printf(\"%+v\", errors.Cause(top()))\n    }\n\n    func top() error {\n      if err := middle(); err != nil {\n        return errors.Wrap(err, \"top error\")\n      }\n      return nil\n    }\n\n    func middle() error {\n      if err := bottom(); err != nil {\n        return errors.Wrap(err, \"middle error\")\n      }\n      return nil\n    }\n\n    func bottom() error {\n      return errors.New(\"bottom error\")\n    }\n    ```\n\n### 小結\n\n+ Sentinel Error與Error Wrapping一起使用\n+ 如果需要Error Stack資訊，則推薦使用`pkg/errors`\n\n## Go2 Draft Design\n\nGo2 Error Handling仍處於Proposal階段(尚未定版)，我們先看官方目前所提供的範例\n\n改造前:\n\n```golang\nfunc printSum(a, b string) error {\n  x, err := strconv.Atoi(a)\n  if err != nil {\n    return err\n  }\n  y, err := strconv.Atoi(b)\n  if err != nil {\n    return err\n  }\n  fmt.Println(\"result:\", x + y)\n  return nil\n}\n```\n\n改造後:\n\n```golang\nfunc printSum(a, b string) error {\n  handle err { return err }\n  x := check strconv.Atoi(a)\n  y := check strconv.Atoi(b)\n  fmt.Println(\"result:\", x + y)\n  return nil\n}\n```\n\nGo2計畫引入兩個關鍵字`handle`和`check`來簡化error對業務邏輯的分割和大量重複的`if err != nil`\n\n可以看到，改造後的代碼明顯減少，可讀性大大增加。並且handle對最終error進行統一處理，減少重複邏輯\n\n不過，由於Go2尚未發佈，就讓我們拭目以待未來Go2能夠成功簡化error吧！\n\n## Panic\n\nGolang中的`panic`代表著程式中不可恢復的錯誤，例如索引越界、不可恢復的環境問題、stack溢位。使用上有以下幾點需要注意：\n\n1. 在程式啟動時，如果有強依賴的服務故障時，使用`panic`退出\n2. 在程式啟動時，如果有配置文件不符合規定時，使用`panic`退出(防禦程序)\n3. 其他時候只要不是不可恢復的錯誤，不該使用`panic`應該使用`error`\n4. 在程式進入點，例如`gin`需要使用`recover`預防程式退出\n5. 在程式中應該避免使用野生的`goroutine`\n    i. 如果需要異步任務，應該使用異步`worker`，消息通知的方式進行處理，避免產生大量的`goroutine`\n    ii. 如果需要使用`goroutine`時，應該使用統一的方法進行創建，這個方法中會運行`recover`，避免野生`goroutine` `panic`導致主程序退出\n\n```golang\nfunc Go(f func()) {\n  go func() {\n    defer func() {\n      if err := recover(); err != nil {\n        log.Printf(\"panic: %+v\", err)\n      }\n    }()\n\n    f()\n  }()\n}\n```\n\n## 最佳實踐\n\n1. 在我們自定義的方法中，使用`errors.New`或者`errors.Errorf`返回錯誤\n  \n    ```golang\n    func myfun(args []string) error {\n      if len(args) < 3 {\n        return errors.Errorf(\"not enouth arguments...\")\n      }\n      return nil\n    }\n    ``\n\n2. 若調用其他方法，請直接返回錯誤。若需要夾帶訊息，請使用`errors.WithMessage`\n\n    ```golang\n    if err != nil {\n      // 直接返回\n      // return err \n      return errors.WithMessage(err, \"xxx\")\n    }\n    ```\n\n3. 如果使用標準庫或其他第三方套件時，請使用`errors.Wrap`保存stack訊息\n4. 在程序的進入點或者goroutine進入點，使用`%+v`印出stack訊息\n\n## 總結\n\n此篇文章介紹了Go error的特點與目前最佳實踐。golang error設計可以說是golang的特點也是缺點，相信官方會針對這個問題慢慢提出最佳解法的\n\n## 參考資料\n\n+ <https://lailin.xyz/post/go-training-03.html>\n+ <https://www.kevinwu0904.top/blogs/golang-error>\n+ <https://go.dev/blog/go1.13-errors>\n+ <https://go.googlesource.com/proposal/+/master/design/29934-error-values.md>\n","slug":"golang/errors","published":1,"updated":"2022-02-21T06:18:04.302Z","_id":"ckytptgql0000guze6tpp827u","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Golang的Error Handling有以下問題，一直被許多人詬病</p>\n<ol>\n<li>Error Handling穿插在golang代碼中，造成業務邏輯代碼可讀性受到影響</li>\n<li>大量且重複的<code>if err != nil</code>無法簡化</li>\n<li>簡單的<code>return err</code>不能適用所有場景</li>\n</ol>\n<p>那麼，到底怎樣才是Golang Error Handling最好作法呢？</p>\n<span id=\"more\"></span>\n\n<h2 id=\"設計思維\"><a href=\"#設計思維\" class=\"headerlink\" title=\"設計思維\"></a>設計思維</h2><h3 id=\"Errors-are-values\"><a href=\"#Errors-are-values\" class=\"headerlink\" title=\"Errors are values\"></a>Errors are values</h3><p><code>Errors are values</code>是Golang創始人之一的Rob Pike對error的設計理念。他認為error和方法的其他返回值一樣，只是多返回值裡面的其中之一，並沒有特別之處。因此，對error的處理就跟對方法其他的返回值一樣處理即可。</p>\n<h3 id=\"考慮失敗，而不是成功\"><a href=\"#考慮失敗，而不是成功\" class=\"headerlink\" title=\"考慮失敗，而不是成功\"></a>考慮失敗，而不是成功</h3><p>在調用任何方法時，都要考慮到它失敗的結果。</p>\n<blockquote>\n<p>當方法回傳value和error，不能對這個value有任何假設，必須先判定error。唯一可以忽略error的是你連value都不關心。</p>\n</blockquote>\n<h3 id=\"完全交給你控制error\"><a href=\"#完全交給你控制error\" class=\"headerlink\" title=\"完全交給你控制error\"></a>完全交給你控制error</h3><h2 id=\"Error定義\"><a href=\"#Error定義\" class=\"headerlink\" title=\"Error定義\"></a>Error定義</h2><p>Golang的error如同上面所說的是一個普通的值，翻看源碼為一個簡單的介面。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// The error built-in interface type is the conventional interface for</span></span><br><span class=\"line\"><span class=\"comment\">// representing an error condition, with the nil value representing no error.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> error <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  Error() <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"建立Error\"><a href=\"#建立Error\" class=\"headerlink\" title=\"建立Error\"></a>建立Error</h3><p>在Golang標準庫和許多第三方Go框架中，我們通常使用<code>errors.New</code>方法來建立error</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// https://pkg.go.dev/io</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ErrShortWrite = errors.New(<span class=\"string\">&quot;short write&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ErrShortBuffer = errors.New(<span class=\"string\">&quot;short buffer&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> EOF = errors.New(<span class=\"string\">&quot;EOF&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ErrUnexpectedEOF = errors.New(<span class=\"string\">&quot;unexpected EOF&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ErrNoProgress = errors.New(<span class=\"string\">&quot;multiple Read calls return no data or error&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>這裡會有個重點需要注意</strong>: <code>errors.New()</code>方法即使創建相同字串內容的error也不是同一個error。為什麼會這樣呢？以下會有詳細說明</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">&quot;errors&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> EOF = errors.New(<span class=\"string\">&quot;EOF&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(EOF == errors.New(<span class=\"string\">&quot;EOF&quot;</span>)) <span class=\"comment\">// output: false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"errors-New-源碼解析\"><a href=\"#errors-New-源碼解析\" class=\"headerlink\" title=\"errors.New()源碼解析\"></a>errors.New()源碼解析</h3><p>errors.New()源碼:</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> errors</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// New returns an error that formats as the given text.</span></span><br><span class=\"line\"><span class=\"comment\">// Each call to New returns a distinct error value even if the text is identical.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(text <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;errorString&#123;text&#125; <span class=\"comment\">// 注意這裡：返回的是&amp;errorString&#123;text&#125;指針，而不是errorString&#123;text&#125;值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// errorString is a trivial implementation of error.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> errorString <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  s <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *errorString)</span> <span class=\"title\">Error</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> e.s</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在Golang中，指針的等值是根據記憶體位置。因此，即使兩個errors.New裡的字串內容相同，但等值比較也會回傳<code>false</code></p>\n</blockquote>\n<h3 id=\"errors-New-為什麼是回傳指針\"><a href=\"#errors-New-為什麼是回傳指針\" class=\"headerlink\" title=\"errors.New()為什麼是回傳指針\"></a>errors.New()為什麼是回傳指針</h3><p>我們先來看一個例子，我們模仿<code>errors.New()</code>創建一個自定義的錯誤，但與標準庫不同的是，我們自定義錯誤回傳的是值，而不是指針</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> myError <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  s <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(me myError)</span> <span class=\"title\">Error</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> me.s</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(text <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> myError&#123;text&#125; <span class=\"comment\">// 這裡返回值，而不是指針</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> errorA = New(<span class=\"string\">&quot;error a&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> errorB = errors.New(<span class=\"string\">&quot;error b&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(errorA == New(<span class=\"string\">&quot;error a&quot;</span>)) <span class=\"comment\">// output: true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  fmt.Println(errorB == errors.New(<span class=\"string\">&quot;error b&quot;</span>)) <span class=\"comment\">// output: false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到我們自定義的<code>myError</code>在比對時，只要字串相同就會回傳<code>true</code>。</p>\n<p><strong>這時我們就需要想如果字串相同就回傳<code>true</code>會有什麼問題?</strong></p>\n<blockquote>\n<p>假設在不同的package定義不同的error，但error裡的字串相同。在進行錯誤比對時，會造成程式誤判，導致進入非預期的錯誤處理流程</p>\n</blockquote>\n<h2 id=\"錯誤類型\"><a href=\"#錯誤類型\" class=\"headerlink\" title=\"錯誤類型\"></a>錯誤類型</h2><h3 id=\"Sentinel-Error\"><a href=\"#Sentinel-Error\" class=\"headerlink\" title=\"Sentinel Error\"></a>Sentinel Error</h3><p>預定義的特定錯誤，我們稱為<code>sentinel error</code>，然後在調用的時候進行比對判斷。在標準庫與第三方框架大量使用這種方法，例如下方<code>io</code>標準庫裡定義的錯誤</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// EOF is the error returned by Read when no more input is available.</span></span><br><span class=\"line\"><span class=\"comment\">// Functions should return EOF only to signal a graceful end of input.</span></span><br><span class=\"line\"><span class=\"comment\">// If the EOF occurs unexpectedly in a structured data stream,</span></span><br><span class=\"line\"><span class=\"comment\">// the appropriate error is either ErrUnexpectedEOF or some other error</span></span><br><span class=\"line\"><span class=\"comment\">// giving more detail.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> EOF = errors.New(<span class=\"string\">&quot;EOF&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ErrUnexpectedEOF means that EOF was encountered in the</span></span><br><span class=\"line\"><span class=\"comment\">// middle of reading a fixed-size block or data structure.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ErrUnexpectedEOF = errors.New(<span class=\"string\">&quot;unexpected EOF&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ErrNoProgress is returned by some clients of an io.Reader when</span></span><br><span class=\"line\"><span class=\"comment\">// many calls to Read have failed to return any data or error,</span></span><br><span class=\"line\"><span class=\"comment\">// usually the sign of a broken io.Reader implementation.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ErrNoProgress = errors.New(<span class=\"string\">&quot;multiple Read calls return no data or error&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>進行比對時，我們一般使用<code>==</code>或者<code>errors.Is</code>進行判斷</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> errors.Is(err, io.EOF)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這種錯誤類型有以下缺點</p>\n<ol>\n<li>會與調用此錯誤的package形成依賴</li>\n<li>將這些錯誤類型當成API暴露給第三方</li>\n<li>包含的錯誤訊息十分有限</li>\n</ol>\n<p>導致在重構或升級時會很麻煩</p>\n<h3 id=\"Error-type\"><a href=\"#Error-type\" class=\"headerlink\" title=\"Error type\"></a>Error type</h3><p><code>Error type</code>跟我們前面自定義的<code>myError</code>一樣實現了<code>error</code>介面</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyError <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  line <span class=\"keyword\">int</span></span><br><span class=\"line\">  file <span class=\"keyword\">string</span></span><br><span class=\"line\">  s <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *MyError)</span> <span class=\"title\">Error</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fmt.Sprint(<span class=\"string\">&quot;%s:%d: %s&quot;</span>, e.file, e.line, e.s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(file <span class=\"keyword\">string</span>, line <span class=\"keyword\">int</span>, s <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;MyError&#123;line: line, file: file, s: s&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然後在外部使用<code>類型判斷</code>來判斷是否是此種錯誤類型</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> err.(<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> *MyStruct:</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> others:</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這種方式對於<code>sentinel error</code>來說，可以包含更詳細的信息。但也會有將此錯誤類型提供給外部的問題，例如標準庫中的<code>os.PathError</code></p>\n<h3 id=\"Opaque-errors\"><a href=\"#Opaque-errors\" class=\"headerlink\" title=\"Opaque errors\"></a>Opaque errors</h3><p>為不透明的錯誤處理，這種方式最大的好處就是<strong>只返回錯誤，暴露錯誤判別介面</strong>，不返回類型</p>\n<p>golang <a href=\"https://pkg.go.dev/net#Error\">net</a>裡的Error</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Error <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  error</span><br><span class=\"line\">  Timeout() <span class=\"keyword\">bool</span>   <span class=\"comment\">// Is the error a timeout?</span></span><br><span class=\"line\">  Temporary() <span class=\"keyword\">bool</span> <span class=\"comment\">// Is the error temporary?</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 錯誤處理</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Temporary() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 處理</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也可以這樣改寫</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> temporary <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  Temporary() <span class=\"keyword\">bool</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IsTemporary</span><span class=\"params\">(err error)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  te, ok := err.(temporary)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ok &amp;&amp; te.Temporary()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這種方式我們可以判斷錯誤<strong>實現了某種特定的行為</strong>，而不是判斷錯誤是某種特定類型或者值。這樣可以減少API的暴露，後續的處理會比較靈活，這樣使用在公用庫會比較好</p>\n<h2 id=\"Error-Handle\"><a href=\"#Error-Handle\" class=\"headerlink\" title=\"Error Handle\"></a>Error Handle</h2><h3 id=\"Eliminate-error-handling-by-eliminating-errors\"><a href=\"#Eliminate-error-handling-by-eliminating-errors\" class=\"headerlink\" title=\"Eliminate error handling by eliminating errors\"></a>Eliminate error handling by eliminating errors</h3><p>詳細可參考The Go Blog: <a href=\"https://go.dev/blog/errors-are-values\">https://go.dev/blog/errors-are-values</a></p>\n<p>改寫前</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_, err = fd.Write(p0[a:b])</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_, err = fd.Write(p1[c:d])</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_, err = fd.Write(p2[e:f])</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// and so on</span></span><br></pre></td></tr></table></figure>\n\n<p>改寫後</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> errWriter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  w   io.Writer</span><br><span class=\"line\">  err error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ew *errWriter)</span> <span class=\"title\">write</span><span class=\"params\">(buf []<span class=\"keyword\">byte</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ew.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _, ew.err = ew.w.Write(buf)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用時</span></span><br><span class=\"line\">ew := &amp;errWriter&#123;w: fd&#125;</span><br><span class=\"line\">ew.write(p0[a:b])</span><br><span class=\"line\">ew.write(p1[c:d])</span><br><span class=\"line\">ew.write(p2[e:f])</span><br><span class=\"line\"><span class=\"comment\">// and so on</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ew.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ew.err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>標準庫中的<code>bufio.Writer</code>也有這種用法。這種就是將重複的邏輯進行封裝，然後把error進行暫存，接著我們只需要在最後判斷error就行了</p>\n<h3 id=\"go1-13前的fmt-Errorf\"><a href=\"#go1-13前的fmt-Errorf\" class=\"headerlink\" title=\"go1.13前的fmt.Errorf\"></a>go1.13前的fmt.Errorf</h3><p>在Go1.13版以前，我們可以透過<code>fmt.Errorf</code>包裝一個error類型並返回一個新的error類型</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> err == os.ErrNotExist &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;xxx.go meet err: %v&quot;</span>, err)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>透過<code>fmt.Errorf</code>包裝，會將原有的error類型丟失，因此無法使用<code>==</code>比較。那如果希望保留error的原始類型，應該如何完成呢？</p>\n<h3 id=\"go1-13的Error-Wrapping\"><a href=\"#go1-13的Error-Wrapping\" class=\"headerlink\" title=\"go1.13的Error Wrapping\"></a>go1.13的Error Wrapping</h3><h4 id=\"Wrap\"><a href=\"#Wrap\" class=\"headerlink\" title=\"Wrap\"></a>Wrap</h4><p>Go1.13版提出了<code>Error Wrapping</code>的概念，透過<code>fmt.Errorf</code>的使用來保留error的原始類型，使用範例如下：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">top</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := middle(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;error wrapper 2 : %w&quot;</span>, err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">middle</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := bottom(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;error wrapper 1 : %w&quot;</span>, err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">bottom</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> errors.New(<span class=\"string\">&quot;core error&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不仔細看的話，會以為跟之前的<code>fmt.Errorf</code>一樣。這裡的區別是在<code>%v</code>和<code>%w</code>兩個不同的佔位符。<code>%w</code>是Go1.13版本新增的佔位符類型，透過結構體嵌套來紀錄error的原始類型</p>\n<p><img src=\"/images/golang/error/wrap.png\" alt=\"Go Error Wrap\"></p>\n<h4 id=\"UnWrap\"><a href=\"#UnWrap\" class=\"headerlink\" title=\"UnWrap\"></a>UnWrap</h4><p>與<code>wrap</code>相對應的是<code>unwrap</code>。Go1.13的標準庫<code>errors</code>提供了<code>Unwrap</code>方法，每調用一次<code>Unwrap</code>就能夠拆開一層錯誤類型</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err := top()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">  t.Log(err)</span><br><span class=\"line\">  err = errors.Unwrap(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Output</span></span><br><span class=\"line\"><span class=\"comment\">// error wrapper 2 : error wrapper 1 : core error</span></span><br><span class=\"line\"><span class=\"comment\">// error wrapper 1 : core error</span></span><br><span class=\"line\"><span class=\"comment\">// core error</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/golang/error/unwrap.png\" alt=\"Go Error Unwrap\"></p>\n<h3 id=\"Is和AS\"><a href=\"#Is和AS\" class=\"headerlink\" title=\"Is和AS\"></a>Is和AS</h3><p><code>Is</code>和<code>As</code>是Go1.13 errors包裡提供的兩個核心方法：</p>\n<ol>\n<li><p><code>Is</code>與上述的<code>==</code>相同</p>\n <figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Similar to:</span></span><br><span class=\"line\"><span class=\"comment\">//   if err == ErrNotFound &#123; … &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> errors.Is(err, ErrNotFound) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// something wasn&#x27;t found</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>As</code>用於判斷是否為特定的錯誤類型</p>\n <figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Similar to:</span></span><br><span class=\"line\"><span class=\"comment\">//   if e, ok := err.(*QueryError); ok &#123; … &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> e *QueryError</span><br><span class=\"line\"><span class=\"comment\">// Note: *QueryError is the type of the error.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> errors.As(err, &amp;e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// err is a *QueryError, and e is set to the error&#x27;s value</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"pkg-errors\"><a href=\"#pkg-errors\" class=\"headerlink\" title=\"pkg/errors\"></a>pkg/errors</h3><p>Go1.13版本的Error Wrapping是借鑒社區開源庫: <a href=\"https://github.com/pkg/errors\">https://github.com/pkg/errors</a>。不僅如此，pkg/errors還提供了打印<code>Error Stack</code>的功能</p>\n<ol>\n<li><p>error源頭使用<code>errors.New</code></p>\n <figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">bottom</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> errors.New(<span class=\"string\">&quot;bottom error&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>error調用鏈裡使用errors.Wrap</p>\n <figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">top</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> err := middle(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> errors.Wrap(err, <span class=\"string\">&quot;top error&quot;</span>)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">middle</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> err := bottom(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> errors.Wrap(err, <span class=\"string\">&quot;middle error&quot;</span>)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>獲取error的RootCause和Error Stack</p>\n <figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;%+v&quot;</span>, errors.Cause(top()))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output</span></span><br><span class=\"line\">bottom error</span><br><span class=\"line\">main.bottom</span><br><span class=\"line\">  /Users/wuguohua/Workspace/Go/src/github.com/KevinWu0904/interview/main.<span class=\"keyword\">go</span>:<span class=\"number\">30</span></span><br><span class=\"line\">main.middle</span><br><span class=\"line\">  /Users/wuguohua/Workspace/Go/src/github.com/KevinWu0904/interview/main.<span class=\"keyword\">go</span>:<span class=\"number\">22</span></span><br><span class=\"line\">main.top</span><br><span class=\"line\">  /Users/wuguohua/Workspace/Go/src/github.com/KevinWu0904/interview/main.<span class=\"keyword\">go</span>:<span class=\"number\">14</span></span><br><span class=\"line\">main.main</span><br><span class=\"line\">  /Users/wuguohua/Workspace/Go/src/github.com/KevinWu0904/interview/main.<span class=\"keyword\">go</span>:<span class=\"number\">10</span></span><br><span class=\"line\">runtime.main</span><br><span class=\"line\">  /Users/wuguohua/.gvm/gos/go1<span class=\"number\">.15</span><span class=\"number\">.8</span>/src/runtime/proc.<span class=\"keyword\">go</span>:<span class=\"number\">204</span></span><br><span class=\"line\">runtime.goexit</span><br><span class=\"line\">  /Users/wuguohua/.gvm/gos/go1<span class=\"number\">.15</span><span class=\"number\">.8</span>/src/runtime/asm_amd64.s:<span class=\"number\">1374</span></span><br><span class=\"line\">Process finished with the exit code <span class=\"number\">0</span></span><br></pre></td></tr></table></figure></li>\n<li><p>完整代碼</p>\n <figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;github.com/pkg/errors&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;%+v&quot;</span>, errors.Cause(top()))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">top</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := middle(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> errors.Wrap(err, <span class=\"string\">&quot;top error&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">middle</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := bottom(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> errors.Wrap(err, <span class=\"string\">&quot;middle error&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">bottom</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> errors.New(<span class=\"string\">&quot;bottom error&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"小結\"><a href=\"#小結\" class=\"headerlink\" title=\"小結\"></a>小結</h3><ul>\n<li>Sentinel Error與Error Wrapping一起使用</li>\n<li>如果需要Error Stack資訊，則推薦使用<code>pkg/errors</code></li>\n</ul>\n<h2 id=\"Go2-Draft-Design\"><a href=\"#Go2-Draft-Design\" class=\"headerlink\" title=\"Go2 Draft Design\"></a>Go2 Draft Design</h2><p>Go2 Error Handling仍處於Proposal階段(尚未定版)，我們先看官方目前所提供的範例</p>\n<p>改造前:</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printSum</span><span class=\"params\">(a, b <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  x, err := strconv.Atoi(a)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  y, err := strconv.Atoi(b)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;result:&quot;</span>, x + y)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>改造後:</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printSum</span><span class=\"params\">(a, b <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  handle err &#123; <span class=\"keyword\">return</span> err &#125;</span><br><span class=\"line\">  x := check strconv.Atoi(a)</span><br><span class=\"line\">  y := check strconv.Atoi(b)</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;result:&quot;</span>, x + y)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Go2計畫引入兩個關鍵字<code>handle</code>和<code>check</code>來簡化error對業務邏輯的分割和大量重複的<code>if err != nil</code></p>\n<p>可以看到，改造後的代碼明顯減少，可讀性大大增加。並且handle對最終error進行統一處理，減少重複邏輯</p>\n<p>不過，由於Go2尚未發佈，就讓我們拭目以待未來Go2能夠成功簡化error吧！</p>\n<h2 id=\"Panic\"><a href=\"#Panic\" class=\"headerlink\" title=\"Panic\"></a>Panic</h2><p>Golang中的<code>panic</code>代表著程式中不可恢復的錯誤，例如索引越界、不可恢復的環境問題、stack溢位。使用上有以下幾點需要注意：</p>\n<ol>\n<li>在程式啟動時，如果有強依賴的服務故障時，使用<code>panic</code>退出</li>\n<li>在程式啟動時，如果有配置文件不符合規定時，使用<code>panic</code>退出(防禦程序)</li>\n<li>其他時候只要不是不可恢復的錯誤，不該使用<code>panic</code>應該使用<code>error</code></li>\n<li>在程式進入點，例如<code>gin</code>需要使用<code>recover</code>預防程式退出</li>\n<li>在程式中應該避免使用野生的<code>goroutine</code><br> i. 如果需要異步任務，應該使用異步<code>worker</code>，消息通知的方式進行處理，避免產生大量的<code>goroutine</code><br> ii. 如果需要使用<code>goroutine</code>時，應該使用統一的方法進行創建，這個方法中會運行<code>recover</code>，避免野生<code>goroutine</code> <code>panic</code>導致主程序退出</li>\n</ol>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Go</span><span class=\"params\">(f <span class=\"keyword\">func</span>()</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> err := <span class=\"built_in\">recover</span>(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Printf(<span class=\"string\">&quot;panic: %+v&quot;</span>, err)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    f()</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"最佳實踐\"><a href=\"#最佳實踐\" class=\"headerlink\" title=\"最佳實踐\"></a>最佳實踐</h2><ol>\n<li><p>在我們自定義的方法中，使用<code>errors.New</code>或者<code>errors.Errorf</code>返回錯誤</p>\n <figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myfun</span><span class=\"params\">(args []<span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(args) &lt; <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> errors.Errorf(<span class=\"string\">&quot;not enouth arguments...&quot;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"string\">``</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> 若調用其他方法，請直接返回錯誤。若需要夾帶訊息，請使用<span class=\"string\">`errors.WithMessage`</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">``</span><span class=\"string\">`golang</span></span><br><span class=\"line\"><span class=\"string\">    if err != nil &#123;</span></span><br><span class=\"line\"><span class=\"string\">      // 直接返回</span></span><br><span class=\"line\"><span class=\"string\">      // return err </span></span><br><span class=\"line\"><span class=\"string\">      return errors.WithMessage(err, &quot;xxx&quot;)</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br></pre></td></tr></table></figure></li>\n<li><p>如果使用標準庫或其他第三方套件時，請使用<code>errors.Wrap</code>保存stack訊息</p>\n</li>\n<li><p>在程序的進入點或者goroutine進入點，使用<code>%+v</code>印出stack訊息</p>\n</li>\n</ol>\n<h2 id=\"總結\"><a href=\"#總結\" class=\"headerlink\" title=\"總結\"></a>總結</h2><p>此篇文章介紹了Go error的特點與目前最佳實踐。golang error設計可以說是golang的特點也是缺點，相信官方會針對這個問題慢慢提出最佳解法的</p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://lailin.xyz/post/go-training-03.html\">https://lailin.xyz/post/go-training-03.html</a></li>\n<li><a href=\"https://www.kevinwu0904.top/blogs/golang-error\">https://www.kevinwu0904.top/blogs/golang-error</a></li>\n<li><a href=\"https://go.dev/blog/go1.13-errors\">https://go.dev/blog/go1.13-errors</a></li>\n<li><a href=\"https://go.googlesource.com/proposal/+/master/design/29934-error-values.md\">https://go.googlesource.com/proposal/+/master/design/29934-error-values.md</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Golang的Error Handling有以下問題，一直被許多人詬病</p>\n<ol>\n<li>Error Handling穿插在golang代碼中，造成業務邏輯代碼可讀性受到影響</li>\n<li>大量且重複的<code>if err != nil</code>無法簡化</li>\n<li>簡單的<code>return err</code>不能適用所有場景</li>\n</ol>\n<p>那麼，到底怎樣才是Golang Error Handling最好作法呢？</p>","more":"<h2 id=\"設計思維\"><a href=\"#設計思維\" class=\"headerlink\" title=\"設計思維\"></a>設計思維</h2><h3 id=\"Errors-are-values\"><a href=\"#Errors-are-values\" class=\"headerlink\" title=\"Errors are values\"></a>Errors are values</h3><p><code>Errors are values</code>是Golang創始人之一的Rob Pike對error的設計理念。他認為error和方法的其他返回值一樣，只是多返回值裡面的其中之一，並沒有特別之處。因此，對error的處理就跟對方法其他的返回值一樣處理即可。</p>\n<h3 id=\"考慮失敗，而不是成功\"><a href=\"#考慮失敗，而不是成功\" class=\"headerlink\" title=\"考慮失敗，而不是成功\"></a>考慮失敗，而不是成功</h3><p>在調用任何方法時，都要考慮到它失敗的結果。</p>\n<blockquote>\n<p>當方法回傳value和error，不能對這個value有任何假設，必須先判定error。唯一可以忽略error的是你連value都不關心。</p>\n</blockquote>\n<h3 id=\"完全交給你控制error\"><a href=\"#完全交給你控制error\" class=\"headerlink\" title=\"完全交給你控制error\"></a>完全交給你控制error</h3><h2 id=\"Error定義\"><a href=\"#Error定義\" class=\"headerlink\" title=\"Error定義\"></a>Error定義</h2><p>Golang的error如同上面所說的是一個普通的值，翻看源碼為一個簡單的介面。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// The error built-in interface type is the conventional interface for</span></span><br><span class=\"line\"><span class=\"comment\">// representing an error condition, with the nil value representing no error.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> error <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  Error() <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"建立Error\"><a href=\"#建立Error\" class=\"headerlink\" title=\"建立Error\"></a>建立Error</h3><p>在Golang標準庫和許多第三方Go框架中，我們通常使用<code>errors.New</code>方法來建立error</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// https://pkg.go.dev/io</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ErrShortWrite = errors.New(<span class=\"string\">&quot;short write&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ErrShortBuffer = errors.New(<span class=\"string\">&quot;short buffer&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> EOF = errors.New(<span class=\"string\">&quot;EOF&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ErrUnexpectedEOF = errors.New(<span class=\"string\">&quot;unexpected EOF&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ErrNoProgress = errors.New(<span class=\"string\">&quot;multiple Read calls return no data or error&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p><strong>這裡會有個重點需要注意</strong>: <code>errors.New()</code>方法即使創建相同字串內容的error也不是同一個error。為什麼會這樣呢？以下會有詳細說明</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">&quot;errors&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> EOF = errors.New(<span class=\"string\">&quot;EOF&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(EOF == errors.New(<span class=\"string\">&quot;EOF&quot;</span>)) <span class=\"comment\">// output: false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"errors-New-源碼解析\"><a href=\"#errors-New-源碼解析\" class=\"headerlink\" title=\"errors.New()源碼解析\"></a>errors.New()源碼解析</h3><p>errors.New()源碼:</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> errors</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// New returns an error that formats as the given text.</span></span><br><span class=\"line\"><span class=\"comment\">// Each call to New returns a distinct error value even if the text is identical.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(text <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;errorString&#123;text&#125; <span class=\"comment\">// 注意這裡：返回的是&amp;errorString&#123;text&#125;指針，而不是errorString&#123;text&#125;值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// errorString is a trivial implementation of error.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> errorString <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  s <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *errorString)</span> <span class=\"title\">Error</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> e.s</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在Golang中，指針的等值是根據記憶體位置。因此，即使兩個errors.New裡的字串內容相同，但等值比較也會回傳<code>false</code></p>\n</blockquote>\n<h3 id=\"errors-New-為什麼是回傳指針\"><a href=\"#errors-New-為什麼是回傳指針\" class=\"headerlink\" title=\"errors.New()為什麼是回傳指針\"></a>errors.New()為什麼是回傳指針</h3><p>我們先來看一個例子，我們模仿<code>errors.New()</code>創建一個自定義的錯誤，但與標準庫不同的是，我們自定義錯誤回傳的是值，而不是指針</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> myError <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  s <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(me myError)</span> <span class=\"title\">Error</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> me.s</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(text <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> myError&#123;text&#125; <span class=\"comment\">// 這裡返回值，而不是指針</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> errorA = New(<span class=\"string\">&quot;error a&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> errorB = errors.New(<span class=\"string\">&quot;error b&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(errorA == New(<span class=\"string\">&quot;error a&quot;</span>)) <span class=\"comment\">// output: true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  fmt.Println(errorB == errors.New(<span class=\"string\">&quot;error b&quot;</span>)) <span class=\"comment\">// output: false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到我們自定義的<code>myError</code>在比對時，只要字串相同就會回傳<code>true</code>。</p>\n<p><strong>這時我們就需要想如果字串相同就回傳<code>true</code>會有什麼問題?</strong></p>\n<blockquote>\n<p>假設在不同的package定義不同的error，但error裡的字串相同。在進行錯誤比對時，會造成程式誤判，導致進入非預期的錯誤處理流程</p>\n</blockquote>\n<h2 id=\"錯誤類型\"><a href=\"#錯誤類型\" class=\"headerlink\" title=\"錯誤類型\"></a>錯誤類型</h2><h3 id=\"Sentinel-Error\"><a href=\"#Sentinel-Error\" class=\"headerlink\" title=\"Sentinel Error\"></a>Sentinel Error</h3><p>預定義的特定錯誤，我們稱為<code>sentinel error</code>，然後在調用的時候進行比對判斷。在標準庫與第三方框架大量使用這種方法，例如下方<code>io</code>標準庫裡定義的錯誤</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// EOF is the error returned by Read when no more input is available.</span></span><br><span class=\"line\"><span class=\"comment\">// Functions should return EOF only to signal a graceful end of input.</span></span><br><span class=\"line\"><span class=\"comment\">// If the EOF occurs unexpectedly in a structured data stream,</span></span><br><span class=\"line\"><span class=\"comment\">// the appropriate error is either ErrUnexpectedEOF or some other error</span></span><br><span class=\"line\"><span class=\"comment\">// giving more detail.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> EOF = errors.New(<span class=\"string\">&quot;EOF&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ErrUnexpectedEOF means that EOF was encountered in the</span></span><br><span class=\"line\"><span class=\"comment\">// middle of reading a fixed-size block or data structure.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ErrUnexpectedEOF = errors.New(<span class=\"string\">&quot;unexpected EOF&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ErrNoProgress is returned by some clients of an io.Reader when</span></span><br><span class=\"line\"><span class=\"comment\">// many calls to Read have failed to return any data or error,</span></span><br><span class=\"line\"><span class=\"comment\">// usually the sign of a broken io.Reader implementation.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ErrNoProgress = errors.New(<span class=\"string\">&quot;multiple Read calls return no data or error&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>進行比對時，我們一般使用<code>==</code>或者<code>errors.Is</code>進行判斷</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> errors.Is(err, io.EOF)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這種錯誤類型有以下缺點</p>\n<ol>\n<li>會與調用此錯誤的package形成依賴</li>\n<li>將這些錯誤類型當成API暴露給第三方</li>\n<li>包含的錯誤訊息十分有限</li>\n</ol>\n<p>導致在重構或升級時會很麻煩</p>\n<h3 id=\"Error-type\"><a href=\"#Error-type\" class=\"headerlink\" title=\"Error type\"></a>Error type</h3><p><code>Error type</code>跟我們前面自定義的<code>myError</code>一樣實現了<code>error</code>介面</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyError <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  line <span class=\"keyword\">int</span></span><br><span class=\"line\">  file <span class=\"keyword\">string</span></span><br><span class=\"line\">  s <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *MyError)</span> <span class=\"title\">Error</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fmt.Sprint(<span class=\"string\">&quot;%s:%d: %s&quot;</span>, e.file, e.line, e.s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(file <span class=\"keyword\">string</span>, line <span class=\"keyword\">int</span>, s <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;MyError&#123;line: line, file: file, s: s&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然後在外部使用<code>類型判斷</code>來判斷是否是此種錯誤類型</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> err.(<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> *MyStruct:</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> others:</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這種方式對於<code>sentinel error</code>來說，可以包含更詳細的信息。但也會有將此錯誤類型提供給外部的問題，例如標準庫中的<code>os.PathError</code></p>\n<h3 id=\"Opaque-errors\"><a href=\"#Opaque-errors\" class=\"headerlink\" title=\"Opaque errors\"></a>Opaque errors</h3><p>為不透明的錯誤處理，這種方式最大的好處就是<strong>只返回錯誤，暴露錯誤判別介面</strong>，不返回類型</p>\n<p>golang <a href=\"https://pkg.go.dev/net#Error\">net</a>裡的Error</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Error <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  error</span><br><span class=\"line\">  Timeout() <span class=\"keyword\">bool</span>   <span class=\"comment\">// Is the error a timeout?</span></span><br><span class=\"line\">  Temporary() <span class=\"keyword\">bool</span> <span class=\"comment\">// Is the error temporary?</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 錯誤處理</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Temporary() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 處理</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也可以這樣改寫</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> temporary <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  Temporary() <span class=\"keyword\">bool</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IsTemporary</span><span class=\"params\">(err error)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  te, ok := err.(temporary)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ok &amp;&amp; te.Temporary()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這種方式我們可以判斷錯誤<strong>實現了某種特定的行為</strong>，而不是判斷錯誤是某種特定類型或者值。這樣可以減少API的暴露，後續的處理會比較靈活，這樣使用在公用庫會比較好</p>\n<h2 id=\"Error-Handle\"><a href=\"#Error-Handle\" class=\"headerlink\" title=\"Error Handle\"></a>Error Handle</h2><h3 id=\"Eliminate-error-handling-by-eliminating-errors\"><a href=\"#Eliminate-error-handling-by-eliminating-errors\" class=\"headerlink\" title=\"Eliminate error handling by eliminating errors\"></a>Eliminate error handling by eliminating errors</h3><p>詳細可參考The Go Blog: <a href=\"https://go.dev/blog/errors-are-values\">https://go.dev/blog/errors-are-values</a></p>\n<p>改寫前</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_, err = fd.Write(p0[a:b])</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_, err = fd.Write(p1[c:d])</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_, err = fd.Write(p2[e:f])</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// and so on</span></span><br></pre></td></tr></table></figure>\n\n<p>改寫後</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> errWriter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  w   io.Writer</span><br><span class=\"line\">  err error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ew *errWriter)</span> <span class=\"title\">write</span><span class=\"params\">(buf []<span class=\"keyword\">byte</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ew.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _, ew.err = ew.w.Write(buf)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用時</span></span><br><span class=\"line\">ew := &amp;errWriter&#123;w: fd&#125;</span><br><span class=\"line\">ew.write(p0[a:b])</span><br><span class=\"line\">ew.write(p1[c:d])</span><br><span class=\"line\">ew.write(p2[e:f])</span><br><span class=\"line\"><span class=\"comment\">// and so on</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ew.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ew.err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>標準庫中的<code>bufio.Writer</code>也有這種用法。這種就是將重複的邏輯進行封裝，然後把error進行暫存，接著我們只需要在最後判斷error就行了</p>\n<h3 id=\"go1-13前的fmt-Errorf\"><a href=\"#go1-13前的fmt-Errorf\" class=\"headerlink\" title=\"go1.13前的fmt.Errorf\"></a>go1.13前的fmt.Errorf</h3><p>在Go1.13版以前，我們可以透過<code>fmt.Errorf</code>包裝一個error類型並返回一個新的error類型</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> err == os.ErrNotExist &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;xxx.go meet err: %v&quot;</span>, err)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>透過<code>fmt.Errorf</code>包裝，會將原有的error類型丟失，因此無法使用<code>==</code>比較。那如果希望保留error的原始類型，應該如何完成呢？</p>\n<h3 id=\"go1-13的Error-Wrapping\"><a href=\"#go1-13的Error-Wrapping\" class=\"headerlink\" title=\"go1.13的Error Wrapping\"></a>go1.13的Error Wrapping</h3><h4 id=\"Wrap\"><a href=\"#Wrap\" class=\"headerlink\" title=\"Wrap\"></a>Wrap</h4><p>Go1.13版提出了<code>Error Wrapping</code>的概念，透過<code>fmt.Errorf</code>的使用來保留error的原始類型，使用範例如下：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">top</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := middle(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;error wrapper 2 : %w&quot;</span>, err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">middle</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := bottom(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;error wrapper 1 : %w&quot;</span>, err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">bottom</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> errors.New(<span class=\"string\">&quot;core error&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不仔細看的話，會以為跟之前的<code>fmt.Errorf</code>一樣。這裡的區別是在<code>%v</code>和<code>%w</code>兩個不同的佔位符。<code>%w</code>是Go1.13版本新增的佔位符類型，透過結構體嵌套來紀錄error的原始類型</p>\n<p><img src=\"/images/golang/error/wrap.png\" alt=\"Go Error Wrap\"></p>\n<h4 id=\"UnWrap\"><a href=\"#UnWrap\" class=\"headerlink\" title=\"UnWrap\"></a>UnWrap</h4><p>與<code>wrap</code>相對應的是<code>unwrap</code>。Go1.13的標準庫<code>errors</code>提供了<code>Unwrap</code>方法，每調用一次<code>Unwrap</code>就能夠拆開一層錯誤類型</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err := top()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">  t.Log(err)</span><br><span class=\"line\">  err = errors.Unwrap(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Output</span></span><br><span class=\"line\"><span class=\"comment\">// error wrapper 2 : error wrapper 1 : core error</span></span><br><span class=\"line\"><span class=\"comment\">// error wrapper 1 : core error</span></span><br><span class=\"line\"><span class=\"comment\">// core error</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/golang/error/unwrap.png\" alt=\"Go Error Unwrap\"></p>\n<h3 id=\"Is和AS\"><a href=\"#Is和AS\" class=\"headerlink\" title=\"Is和AS\"></a>Is和AS</h3><p><code>Is</code>和<code>As</code>是Go1.13 errors包裡提供的兩個核心方法：</p>\n<ol>\n<li><p><code>Is</code>與上述的<code>==</code>相同</p>\n <figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Similar to:</span></span><br><span class=\"line\"><span class=\"comment\">//   if err == ErrNotFound &#123; … &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> errors.Is(err, ErrNotFound) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// something wasn&#x27;t found</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>As</code>用於判斷是否為特定的錯誤類型</p>\n <figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Similar to:</span></span><br><span class=\"line\"><span class=\"comment\">//   if e, ok := err.(*QueryError); ok &#123; … &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> e *QueryError</span><br><span class=\"line\"><span class=\"comment\">// Note: *QueryError is the type of the error.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> errors.As(err, &amp;e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// err is a *QueryError, and e is set to the error&#x27;s value</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"pkg-errors\"><a href=\"#pkg-errors\" class=\"headerlink\" title=\"pkg/errors\"></a>pkg/errors</h3><p>Go1.13版本的Error Wrapping是借鑒社區開源庫: <a href=\"https://github.com/pkg/errors\">https://github.com/pkg/errors</a>。不僅如此，pkg/errors還提供了打印<code>Error Stack</code>的功能</p>\n<ol>\n<li><p>error源頭使用<code>errors.New</code></p>\n <figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">bottom</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> errors.New(<span class=\"string\">&quot;bottom error&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>error調用鏈裡使用errors.Wrap</p>\n <figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">top</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> err := middle(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> errors.Wrap(err, <span class=\"string\">&quot;top error&quot;</span>)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">middle</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> err := bottom(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> errors.Wrap(err, <span class=\"string\">&quot;middle error&quot;</span>)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>獲取error的RootCause和Error Stack</p>\n <figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;%+v&quot;</span>, errors.Cause(top()))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output</span></span><br><span class=\"line\">bottom error</span><br><span class=\"line\">main.bottom</span><br><span class=\"line\">  /Users/wuguohua/Workspace/Go/src/github.com/KevinWu0904/interview/main.<span class=\"keyword\">go</span>:<span class=\"number\">30</span></span><br><span class=\"line\">main.middle</span><br><span class=\"line\">  /Users/wuguohua/Workspace/Go/src/github.com/KevinWu0904/interview/main.<span class=\"keyword\">go</span>:<span class=\"number\">22</span></span><br><span class=\"line\">main.top</span><br><span class=\"line\">  /Users/wuguohua/Workspace/Go/src/github.com/KevinWu0904/interview/main.<span class=\"keyword\">go</span>:<span class=\"number\">14</span></span><br><span class=\"line\">main.main</span><br><span class=\"line\">  /Users/wuguohua/Workspace/Go/src/github.com/KevinWu0904/interview/main.<span class=\"keyword\">go</span>:<span class=\"number\">10</span></span><br><span class=\"line\">runtime.main</span><br><span class=\"line\">  /Users/wuguohua/.gvm/gos/go1<span class=\"number\">.15</span><span class=\"number\">.8</span>/src/runtime/proc.<span class=\"keyword\">go</span>:<span class=\"number\">204</span></span><br><span class=\"line\">runtime.goexit</span><br><span class=\"line\">  /Users/wuguohua/.gvm/gos/go1<span class=\"number\">.15</span><span class=\"number\">.8</span>/src/runtime/asm_amd64.s:<span class=\"number\">1374</span></span><br><span class=\"line\">Process finished with the exit code <span class=\"number\">0</span></span><br></pre></td></tr></table></figure></li>\n<li><p>完整代碼</p>\n <figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;github.com/pkg/errors&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">&quot;%+v&quot;</span>, errors.Cause(top()))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">top</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := middle(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> errors.Wrap(err, <span class=\"string\">&quot;top error&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">middle</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := bottom(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> errors.Wrap(err, <span class=\"string\">&quot;middle error&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">bottom</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> errors.New(<span class=\"string\">&quot;bottom error&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"小結\"><a href=\"#小結\" class=\"headerlink\" title=\"小結\"></a>小結</h3><ul>\n<li>Sentinel Error與Error Wrapping一起使用</li>\n<li>如果需要Error Stack資訊，則推薦使用<code>pkg/errors</code></li>\n</ul>\n<h2 id=\"Go2-Draft-Design\"><a href=\"#Go2-Draft-Design\" class=\"headerlink\" title=\"Go2 Draft Design\"></a>Go2 Draft Design</h2><p>Go2 Error Handling仍處於Proposal階段(尚未定版)，我們先看官方目前所提供的範例</p>\n<p>改造前:</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printSum</span><span class=\"params\">(a, b <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  x, err := strconv.Atoi(a)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  y, err := strconv.Atoi(b)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;result:&quot;</span>, x + y)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>改造後:</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printSum</span><span class=\"params\">(a, b <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  handle err &#123; <span class=\"keyword\">return</span> err &#125;</span><br><span class=\"line\">  x := check strconv.Atoi(a)</span><br><span class=\"line\">  y := check strconv.Atoi(b)</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;result:&quot;</span>, x + y)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Go2計畫引入兩個關鍵字<code>handle</code>和<code>check</code>來簡化error對業務邏輯的分割和大量重複的<code>if err != nil</code></p>\n<p>可以看到，改造後的代碼明顯減少，可讀性大大增加。並且handle對最終error進行統一處理，減少重複邏輯</p>\n<p>不過，由於Go2尚未發佈，就讓我們拭目以待未來Go2能夠成功簡化error吧！</p>\n<h2 id=\"Panic\"><a href=\"#Panic\" class=\"headerlink\" title=\"Panic\"></a>Panic</h2><p>Golang中的<code>panic</code>代表著程式中不可恢復的錯誤，例如索引越界、不可恢復的環境問題、stack溢位。使用上有以下幾點需要注意：</p>\n<ol>\n<li>在程式啟動時，如果有強依賴的服務故障時，使用<code>panic</code>退出</li>\n<li>在程式啟動時，如果有配置文件不符合規定時，使用<code>panic</code>退出(防禦程序)</li>\n<li>其他時候只要不是不可恢復的錯誤，不該使用<code>panic</code>應該使用<code>error</code></li>\n<li>在程式進入點，例如<code>gin</code>需要使用<code>recover</code>預防程式退出</li>\n<li>在程式中應該避免使用野生的<code>goroutine</code><br> i. 如果需要異步任務，應該使用異步<code>worker</code>，消息通知的方式進行處理，避免產生大量的<code>goroutine</code><br> ii. 如果需要使用<code>goroutine</code>時，應該使用統一的方法進行創建，這個方法中會運行<code>recover</code>，避免野生<code>goroutine</code> <code>panic</code>導致主程序退出</li>\n</ol>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Go</span><span class=\"params\">(f <span class=\"keyword\">func</span>()</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> err := <span class=\"built_in\">recover</span>(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Printf(<span class=\"string\">&quot;panic: %+v&quot;</span>, err)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">    f()</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"最佳實踐\"><a href=\"#最佳實踐\" class=\"headerlink\" title=\"最佳實踐\"></a>最佳實踐</h2><ol>\n<li><p>在我們自定義的方法中，使用<code>errors.New</code>或者<code>errors.Errorf</code>返回錯誤</p>\n <figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myfun</span><span class=\"params\">(args []<span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(args) &lt; <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> errors.Errorf(<span class=\"string\">&quot;not enouth arguments...&quot;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"string\">``</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> 若調用其他方法，請直接返回錯誤。若需要夾帶訊息，請使用<span class=\"string\">`errors.WithMessage`</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">``</span><span class=\"string\">`golang</span></span><br><span class=\"line\"><span class=\"string\">    if err != nil &#123;</span></span><br><span class=\"line\"><span class=\"string\">      // 直接返回</span></span><br><span class=\"line\"><span class=\"string\">      // return err </span></span><br><span class=\"line\"><span class=\"string\">      return errors.WithMessage(err, &quot;xxx&quot;)</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br></pre></td></tr></table></figure></li>\n<li><p>如果使用標準庫或其他第三方套件時，請使用<code>errors.Wrap</code>保存stack訊息</p>\n</li>\n<li><p>在程序的進入點或者goroutine進入點，使用<code>%+v</code>印出stack訊息</p>\n</li>\n</ol>\n<h2 id=\"總結\"><a href=\"#總結\" class=\"headerlink\" title=\"總結\"></a>總結</h2><p>此篇文章介紹了Go error的特點與目前最佳實踐。golang error設計可以說是golang的特點也是缺點，相信官方會針對這個問題慢慢提出最佳解法的</p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://lailin.xyz/post/go-training-03.html\">https://lailin.xyz/post/go-training-03.html</a></li>\n<li><a href=\"https://www.kevinwu0904.top/blogs/golang-error\">https://www.kevinwu0904.top/blogs/golang-error</a></li>\n<li><a href=\"https://go.dev/blog/go1.13-errors\">https://go.dev/blog/go1.13-errors</a></li>\n<li><a href=\"https://go.googlesource.com/proposal/+/master/design/29934-error-values.md\">https://go.googlesource.com/proposal/+/master/design/29934-error-values.md</a></li>\n</ul>"},{"title":"[Golang] Goroutine","date":"2022-02-06T19:51:01.000Z","toc":true,"cover":"/images/golang/goroutine.jpeg","_content":"\n在Golang中使用簡單的`go`關鍵字開啟一個goroutine，但這樣可能會造成開啟過多的goroutine，造成一些無可避免的bug。以下內容會針對golang使用goroutine的一些注意事項\n\n<!-- more -->\n\n## 常見例子\n\n我們很常看見以下例子，就讓我們看看這樣會有什麼問題吧\n\n```golang\nfunc serveApp() {\n  go func() {\n    mux := http.NewServeMux()\n    mux.HandleFunc(\"/\", func(resp http.ResponseWriter, req *http.Request) {\n      fmt.Fprintln(resp, \"Hello World!\")\n    })\n    if err := http.ListenAndServe(\":8080\", mux); err != nil {\n      log.Fatal(err)\n    }\n  }()\n}\n\nfunc serveDebug() {\n  go http.ListenAndServe(\":8081\", nil)\n}\n\nfunc main() {\n  serveApp()\n\n  serveDebug()\n\n  select {} // 空的select會阻塞\n}\n```\n\n## Leave concurrency to the caller\n\n請將是否併發的選擇權交給調用者，而不是自己默默加上`goroutine`，不然這樣調用者不知道調用的函數裡使用goroutine\n\n```golang\nfunc serveApp() {\n  mux := http.NewServeMux()\n  mux.HandleFunc(\"/\", func(resp http.ResponseWriter, req *http.Request) {\n    fmt.Fprintln(resp, \"Hello World!\")\n  })\n  if err := http.ListenAndServe(\":8080\", mux); err != nil {\n    log.Fatal(err)\n  }\n}\n\nfunc serveDebug() {\n  http.ListenAndServe(\":8081\", http.DefaultServeMux)\n}\n\nfunc main() {\n\n  go serveDebug()\n\n  go serveApp()\n\n  select {} // 空的select會阻塞\n}\n```\n\n## Keep yourself busy or do the work yourself\n\n如果你的 goroutine 無法明確取得進展，這樣通常需要自己做而不是委託給 goroutine 。\n\n```golang\nfunc serveApp() {\n  mux := http.NewServeMux()\n  mux.HandleFunc(\"/\", func(resp http.ResponseWriter, req *http.Request) {\n    fmt.Fprintln(resp, \"Hello World!\")\n  })\n  if err := http.ListenAndServe(\":8080\", mux); err != nil {\n    log.Fatal(err)\n  }\n}\n\nfunc serveDebug() {\n  http.ListenAndServe(\":8081\", http.DefaultServeMux)\n}\n\nfunc main() {\n\n  go serveDebug()\n  \n  serveApp()\n}\n```\n\n這樣消除了將結果從 goroutine 返回到其發起者所需的大量狀態跟踪和通道操作。\n\n## Never start a goroutine without knowning when it will stop\n\n上面的修改還是存在一些問題，當serveDebug發生中斷時，main並不會知道\n我們使用`channel`進行改寫通知，詳細代碼如下\n\n```golang\n// 啟動一個http服務\nfunc server(handler http.Handler, addr string, stop <-chan struct{}) error {\n  s := http.Server{\n    Handler: handler,\n    Addr:    addr,\n  }\n\n  // 我們可以控制這個goroutine退出，只要 stop 這個 channel close或寫入數據，這裡就會退出\n  // 同時也調用 s.Shutdown，server這個func調用的http服務也會優雅下線\n  go func() {\n    <-stop\n    log.Printf(\"server will exiting, addr: %s\", addr)\n    s.Shutdown(context.Background())\n  }()\n\n  return s.ListenAndServe()\n}\n\nfunc serveApp(stop <-chan struct{}) error {\n  mux := http.NewServeMux()\n  mux.HandleFunc(\"/\", func(resp http.ResponseWriter, req *http.Request) {\n    fmt.Fprintln(resp, \"Hello World!\")\n  })\n\n  return server(mux, \":8080\", stop)\n}\n\nfunc serveDebug(stop <-chan struct{}) error {\n  go func() {\n    server(http.DefaultServeMux, \":8001\", stop)\n  }()\n  // 這邊模擬debug服務退出\n  time.Sleep(5 * time.Second)\n  return fmt.Errorf(\"mock debug exit\")\n}\n\nfunc main() {\n  // 用於監聽服務是否有錯誤\n  done := make(chan error, 2)\n  // 用於控制其他的服務退出，只要其中有一個服務退出，其他服務跟著退出\n  stop := make(chan struct{}, 2)\n\n  go func() {\n    done <- serveDebug(stop)\n  }()\n\n  go func() {\n    done <- serveApp(stop)\n  }()\n\n  // 用於判斷當前服務是否停止的狀態\n  var stopped bool\n  // 循環讀取done這個channel\n  // 只要有一個錯誤，我們就關閉stop這個channel\n  for i := 0; i < cap(done); i++ {\n    if err := <-done; err != nil {\n      log.Printf(\"server exit err: %+v\", err)\n    }\n    if !stopped {\n      stopped = true\n      close(stop)\n    }\n  }\n}\n```\n\n> close(chan)的時候，channel還可以讀取，但不能寫入\n\n測試結果\n\n```bash\n2022/02/11 11:32:40 server exit err: mock debug exit\n2022/02/11 11:32:40 server will exiting, addr: :8001\n2022/02/11 11:32:40 server will exiting, addr: :8080\n2022/02/11 11:32:40 server exit err: http: Server closed\n```\n\n## goroutine leak\n\ngoroutine leak顧名思義就是goroutine一直佔用著資源，無法退出\n\n### 造成原因\n\n大部分的goroutine leak通常是`sync`、`channel`操作不當造成的，而且調用方無法控制此 goroutine 退出的方法\n> `sync`、`channel`造成 goroutine leak具體內容會在後續文章繼續探討\n\n簡單的範例：\n\n```golang\nfunc main() {\n  // 計算剛開始的 goroutine 數量\n  startingGs := runtime.NumGoroutine()\n\n  leak()\n\n  // 暫停一秒觀察leak()停止後的狀況\n  time.Sleep(time.Second)\n\n  // 計算結束後的 goroutine 數量\n  endingGs := runtime.NumGoroutine()\n\n  fmt.Println(\"Number of goroutines before: \", startingGs)\n  fmt.Println(\"Number of goroutines after: \", endingGs)\n  fmt.Println(\"Number of goroutines leaked: \", endingGs-startingGs)\n}\n\n// 此方法模擬當 channel 一直沒有值進來\n// 此 goroutine 會一直阻塞\nfunc leak() {\n  ch := make(chan int)\n\n  go func() {\n    fmt.Println(\"We received a value: \", <-ch)\n  }()\n}\n```\n\n## Incomplete Work\n\n當我們程序中止時，並未等 goroutine 完成它應該完成的工作(非 main goroutine)，就會發生`Incomplete work`\n\n可以執行以下程式，看看會有什麼結果\n\n```golang\nfunc main() {\n  fmt.Println(\"Hello\")\n  go fmt.Println(\"Goodbye\")\n}\n```\n\n可以發現console只有印出`Hello`，並沒有等待`Goodbye`印出再退出程序\n\n### 這樣會產生什麼問題\n\n這樣的方式有可能讓我們在寫檔或寫入資料庫時，造成資料遺漏問題\n\n### 如何預防\n\n以下讓我們看一個模擬web trace服務\n\n```golang\ntype Tracker struct {\n}\n\nfunc (t *Tracker) Event(data string) {\n  time.Sleep(time.Second)\n  fmt.Println(data)\n}\n\ntype App struct {\n  tracker Tracker\n}\n\nfunc (a *App) Handle(text string) {\n  fmt.Println(text + \" App.Handle()\")\n\n  go a.tracker.Event(text + \" Tracker.Event()\")\n}\n\nfunc main() {\n  var a App\n\n  a.Handle(\"1\")\n  a.Handle(\"2\")\n}\n```\n\n執行結果:\n\n```bash\n1 App.Handle()\n2 App.Handle()\n```\n\n#### 方法一: 使用 sync.WaitGroup 改寫\n\n我們可以使用`sync.WaitGroup`來追蹤每一個創建的 goroutine\n\n```golang\ntype Tracker struct {\n  wg sync.WaitGroup\n}\n\nfunc (t *Tracker) Event(data string) {\n  t.wg.Add(1)\n\n  go func() {\n  //\n    defer t.wg.Done()\n\n    time.Sleep(time.Second)\n    fmt.Println(data)\n  }()\n}\n\nfunc (t *Tracker) Showdown() {\n  t.wg.Wait()\n}\n\ntype App struct {\n  tracker Tracker\n}\n\nfunc (a *App) Handle(text string) {\n  fmt.Println(text + \" App.Handle()\")\n\n  a.tracker.Event(text + \" Tracker.Event()\")\n}\n\nfunc main() {\n  var a App\n  a.Handle(\"1\")\n  a.Handle(\"2\")\n\n  a.tracker.Showdown()\n}\n```\n\n執行結果\n\n```bash\n1 App.Handle()\n2 App.Handle()\n2 Tracker.Event()\n1 Tracker.Event()\n```\n\n#### 方法二: 設置超時時間\n\n**方法一**可以等待 goroutine 將任務完成再進行關閉，但這樣等待的時間並沒有限制\n\n有可能造成等待的時間過長，一直無限的等待下去\n\n為了預防這個問題，我們接著給`Showdown()`加上超時時間\n\n```golang\nfunc (t *Tracker) Showdown(ctx context.Context) error {\n  ch := make(chan struct{})\n\n  go func() {\n    t.wg.Wait()\n    close(ch)\n  }()\n\n  select {\n  case <-ch:\n    return nil\n  case <-ctx.Done():\n    return errors.New(\"timeout\")\n  }\n}\n```\n\n我們接著改寫`main()`，並將`Event()`延長停止時間，故意讓它發生超時\n\n```golang\nfunc (t *Tracker) Event(data string) {\n  t.wg.Add(1)\n\n  go func() {\n    defer t.wg.Done()\n    // 延長至6秒\n    time.Sleep(6 * time.Second)\n    fmt.Println(data)\n  }()\n}\n\nfunc main() {\n  var a App\n  a.Handle(\"1\")\n  a.Handle(\"2\")\n  // 設置超時時間5秒\n  const timeout = 5 * time.Second\n  ctx, cancel := context.WithTimeout(context.Background(), timeout)\n  defer cancel()\n\n  err := a.tracker.Showdown(ctx)\n  if err != nil {\n    log.Println(err)\n  }\n}\n```\n\n執行結果\n\n```bash\n1 App.Handle()\n2 App.Handle()\nxxxx/xx/xx xx:xx:xx timeout\n```\n\n#### 補充\n\n方法二的改法，會有`goroutine`過多的問題。我們再多一個`stop` `channel`來避免這個問題。詳細代碼如下:\n\n```golang\ntype Tracker struct {\n  ch   chan string\n  stop chan struct{}\n}\n\nfunc NewTracker() *Tracker {\n  return &Tracker{\n    ch: make(chan string, 10),\n  }\n}\n\nfunc (t *Tracker) Event(ctx context.Context, data string) error {\n  select {\n  case t.ch <- data:\n    return nil\n  case <-ctx.Done():\n    return ctx.Err()\n  }\n}\n\nfunc (t *Tracker) Run() {\n  for data := range t.ch {\n    time.Sleep(1 * time.Second)\n    fmt.Println(data)\n  }\n  t.stop <- struct{}{}\n}\n\nfunc (t *Tracker) Showdown(ctx context.Context) {\n  close(t.ch) //\n  select {\n  case <-t.stop:\n  case <-ctx.Done():\n  }\n}\n\nfunc main() {\n  tr := NewTracker()\n  go tr.Run()\n\n  _ = tr.Event(context.Background(), \"1\")\n  _ = tr.Event(context.Background(), \"2\")\n  _ = tr.Event(context.Background(), \"3\")\n\n  ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(5*time.Second))\n  defer cancel()\n\n  tr.Showdown(ctx)\n}\n```\n\n## 總結\n\n1. 將使用 goroutine 的選擇權交給調用者\n2. 知道所使用的 goroutine 的生命週期(何時開始、何時退出、控制如何退出)，避免 goroutine leak\n3. 調用 goroutine 請加上 `panic` `recovery`機制，避免整個服務直接退出\n4. **如果有大量請求，避免直接創建 goroutine處理**，應該使用`worker`模式來處理，可以避免調oom問題。若請求量很小的話，可以不用理會這個問題\n\n## 參考資料\n\n<https://lailin.xyz/post/go-training-week3-goroutine.html>\n<https://dave.cheney.net/practical-go/presentations/qcon-china.html>\n<https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html>\n<https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html>\n","source":"_posts/golang/goroutine.md","raw":"---\ntitle: '[Golang] Goroutine'\ndate: 2022-02-07 03:51:01\ntags: golang\ncategories: 學習\ntoc: true\ncover: /images/golang/goroutine.jpeg\n---\n\n在Golang中使用簡單的`go`關鍵字開啟一個goroutine，但這樣可能會造成開啟過多的goroutine，造成一些無可避免的bug。以下內容會針對golang使用goroutine的一些注意事項\n\n<!-- more -->\n\n## 常見例子\n\n我們很常看見以下例子，就讓我們看看這樣會有什麼問題吧\n\n```golang\nfunc serveApp() {\n  go func() {\n    mux := http.NewServeMux()\n    mux.HandleFunc(\"/\", func(resp http.ResponseWriter, req *http.Request) {\n      fmt.Fprintln(resp, \"Hello World!\")\n    })\n    if err := http.ListenAndServe(\":8080\", mux); err != nil {\n      log.Fatal(err)\n    }\n  }()\n}\n\nfunc serveDebug() {\n  go http.ListenAndServe(\":8081\", nil)\n}\n\nfunc main() {\n  serveApp()\n\n  serveDebug()\n\n  select {} // 空的select會阻塞\n}\n```\n\n## Leave concurrency to the caller\n\n請將是否併發的選擇權交給調用者，而不是自己默默加上`goroutine`，不然這樣調用者不知道調用的函數裡使用goroutine\n\n```golang\nfunc serveApp() {\n  mux := http.NewServeMux()\n  mux.HandleFunc(\"/\", func(resp http.ResponseWriter, req *http.Request) {\n    fmt.Fprintln(resp, \"Hello World!\")\n  })\n  if err := http.ListenAndServe(\":8080\", mux); err != nil {\n    log.Fatal(err)\n  }\n}\n\nfunc serveDebug() {\n  http.ListenAndServe(\":8081\", http.DefaultServeMux)\n}\n\nfunc main() {\n\n  go serveDebug()\n\n  go serveApp()\n\n  select {} // 空的select會阻塞\n}\n```\n\n## Keep yourself busy or do the work yourself\n\n如果你的 goroutine 無法明確取得進展，這樣通常需要自己做而不是委託給 goroutine 。\n\n```golang\nfunc serveApp() {\n  mux := http.NewServeMux()\n  mux.HandleFunc(\"/\", func(resp http.ResponseWriter, req *http.Request) {\n    fmt.Fprintln(resp, \"Hello World!\")\n  })\n  if err := http.ListenAndServe(\":8080\", mux); err != nil {\n    log.Fatal(err)\n  }\n}\n\nfunc serveDebug() {\n  http.ListenAndServe(\":8081\", http.DefaultServeMux)\n}\n\nfunc main() {\n\n  go serveDebug()\n  \n  serveApp()\n}\n```\n\n這樣消除了將結果從 goroutine 返回到其發起者所需的大量狀態跟踪和通道操作。\n\n## Never start a goroutine without knowning when it will stop\n\n上面的修改還是存在一些問題，當serveDebug發生中斷時，main並不會知道\n我們使用`channel`進行改寫通知，詳細代碼如下\n\n```golang\n// 啟動一個http服務\nfunc server(handler http.Handler, addr string, stop <-chan struct{}) error {\n  s := http.Server{\n    Handler: handler,\n    Addr:    addr,\n  }\n\n  // 我們可以控制這個goroutine退出，只要 stop 這個 channel close或寫入數據，這裡就會退出\n  // 同時也調用 s.Shutdown，server這個func調用的http服務也會優雅下線\n  go func() {\n    <-stop\n    log.Printf(\"server will exiting, addr: %s\", addr)\n    s.Shutdown(context.Background())\n  }()\n\n  return s.ListenAndServe()\n}\n\nfunc serveApp(stop <-chan struct{}) error {\n  mux := http.NewServeMux()\n  mux.HandleFunc(\"/\", func(resp http.ResponseWriter, req *http.Request) {\n    fmt.Fprintln(resp, \"Hello World!\")\n  })\n\n  return server(mux, \":8080\", stop)\n}\n\nfunc serveDebug(stop <-chan struct{}) error {\n  go func() {\n    server(http.DefaultServeMux, \":8001\", stop)\n  }()\n  // 這邊模擬debug服務退出\n  time.Sleep(5 * time.Second)\n  return fmt.Errorf(\"mock debug exit\")\n}\n\nfunc main() {\n  // 用於監聽服務是否有錯誤\n  done := make(chan error, 2)\n  // 用於控制其他的服務退出，只要其中有一個服務退出，其他服務跟著退出\n  stop := make(chan struct{}, 2)\n\n  go func() {\n    done <- serveDebug(stop)\n  }()\n\n  go func() {\n    done <- serveApp(stop)\n  }()\n\n  // 用於判斷當前服務是否停止的狀態\n  var stopped bool\n  // 循環讀取done這個channel\n  // 只要有一個錯誤，我們就關閉stop這個channel\n  for i := 0; i < cap(done); i++ {\n    if err := <-done; err != nil {\n      log.Printf(\"server exit err: %+v\", err)\n    }\n    if !stopped {\n      stopped = true\n      close(stop)\n    }\n  }\n}\n```\n\n> close(chan)的時候，channel還可以讀取，但不能寫入\n\n測試結果\n\n```bash\n2022/02/11 11:32:40 server exit err: mock debug exit\n2022/02/11 11:32:40 server will exiting, addr: :8001\n2022/02/11 11:32:40 server will exiting, addr: :8080\n2022/02/11 11:32:40 server exit err: http: Server closed\n```\n\n## goroutine leak\n\ngoroutine leak顧名思義就是goroutine一直佔用著資源，無法退出\n\n### 造成原因\n\n大部分的goroutine leak通常是`sync`、`channel`操作不當造成的，而且調用方無法控制此 goroutine 退出的方法\n> `sync`、`channel`造成 goroutine leak具體內容會在後續文章繼續探討\n\n簡單的範例：\n\n```golang\nfunc main() {\n  // 計算剛開始的 goroutine 數量\n  startingGs := runtime.NumGoroutine()\n\n  leak()\n\n  // 暫停一秒觀察leak()停止後的狀況\n  time.Sleep(time.Second)\n\n  // 計算結束後的 goroutine 數量\n  endingGs := runtime.NumGoroutine()\n\n  fmt.Println(\"Number of goroutines before: \", startingGs)\n  fmt.Println(\"Number of goroutines after: \", endingGs)\n  fmt.Println(\"Number of goroutines leaked: \", endingGs-startingGs)\n}\n\n// 此方法模擬當 channel 一直沒有值進來\n// 此 goroutine 會一直阻塞\nfunc leak() {\n  ch := make(chan int)\n\n  go func() {\n    fmt.Println(\"We received a value: \", <-ch)\n  }()\n}\n```\n\n## Incomplete Work\n\n當我們程序中止時，並未等 goroutine 完成它應該完成的工作(非 main goroutine)，就會發生`Incomplete work`\n\n可以執行以下程式，看看會有什麼結果\n\n```golang\nfunc main() {\n  fmt.Println(\"Hello\")\n  go fmt.Println(\"Goodbye\")\n}\n```\n\n可以發現console只有印出`Hello`，並沒有等待`Goodbye`印出再退出程序\n\n### 這樣會產生什麼問題\n\n這樣的方式有可能讓我們在寫檔或寫入資料庫時，造成資料遺漏問題\n\n### 如何預防\n\n以下讓我們看一個模擬web trace服務\n\n```golang\ntype Tracker struct {\n}\n\nfunc (t *Tracker) Event(data string) {\n  time.Sleep(time.Second)\n  fmt.Println(data)\n}\n\ntype App struct {\n  tracker Tracker\n}\n\nfunc (a *App) Handle(text string) {\n  fmt.Println(text + \" App.Handle()\")\n\n  go a.tracker.Event(text + \" Tracker.Event()\")\n}\n\nfunc main() {\n  var a App\n\n  a.Handle(\"1\")\n  a.Handle(\"2\")\n}\n```\n\n執行結果:\n\n```bash\n1 App.Handle()\n2 App.Handle()\n```\n\n#### 方法一: 使用 sync.WaitGroup 改寫\n\n我們可以使用`sync.WaitGroup`來追蹤每一個創建的 goroutine\n\n```golang\ntype Tracker struct {\n  wg sync.WaitGroup\n}\n\nfunc (t *Tracker) Event(data string) {\n  t.wg.Add(1)\n\n  go func() {\n  //\n    defer t.wg.Done()\n\n    time.Sleep(time.Second)\n    fmt.Println(data)\n  }()\n}\n\nfunc (t *Tracker) Showdown() {\n  t.wg.Wait()\n}\n\ntype App struct {\n  tracker Tracker\n}\n\nfunc (a *App) Handle(text string) {\n  fmt.Println(text + \" App.Handle()\")\n\n  a.tracker.Event(text + \" Tracker.Event()\")\n}\n\nfunc main() {\n  var a App\n  a.Handle(\"1\")\n  a.Handle(\"2\")\n\n  a.tracker.Showdown()\n}\n```\n\n執行結果\n\n```bash\n1 App.Handle()\n2 App.Handle()\n2 Tracker.Event()\n1 Tracker.Event()\n```\n\n#### 方法二: 設置超時時間\n\n**方法一**可以等待 goroutine 將任務完成再進行關閉，但這樣等待的時間並沒有限制\n\n有可能造成等待的時間過長，一直無限的等待下去\n\n為了預防這個問題，我們接著給`Showdown()`加上超時時間\n\n```golang\nfunc (t *Tracker) Showdown(ctx context.Context) error {\n  ch := make(chan struct{})\n\n  go func() {\n    t.wg.Wait()\n    close(ch)\n  }()\n\n  select {\n  case <-ch:\n    return nil\n  case <-ctx.Done():\n    return errors.New(\"timeout\")\n  }\n}\n```\n\n我們接著改寫`main()`，並將`Event()`延長停止時間，故意讓它發生超時\n\n```golang\nfunc (t *Tracker) Event(data string) {\n  t.wg.Add(1)\n\n  go func() {\n    defer t.wg.Done()\n    // 延長至6秒\n    time.Sleep(6 * time.Second)\n    fmt.Println(data)\n  }()\n}\n\nfunc main() {\n  var a App\n  a.Handle(\"1\")\n  a.Handle(\"2\")\n  // 設置超時時間5秒\n  const timeout = 5 * time.Second\n  ctx, cancel := context.WithTimeout(context.Background(), timeout)\n  defer cancel()\n\n  err := a.tracker.Showdown(ctx)\n  if err != nil {\n    log.Println(err)\n  }\n}\n```\n\n執行結果\n\n```bash\n1 App.Handle()\n2 App.Handle()\nxxxx/xx/xx xx:xx:xx timeout\n```\n\n#### 補充\n\n方法二的改法，會有`goroutine`過多的問題。我們再多一個`stop` `channel`來避免這個問題。詳細代碼如下:\n\n```golang\ntype Tracker struct {\n  ch   chan string\n  stop chan struct{}\n}\n\nfunc NewTracker() *Tracker {\n  return &Tracker{\n    ch: make(chan string, 10),\n  }\n}\n\nfunc (t *Tracker) Event(ctx context.Context, data string) error {\n  select {\n  case t.ch <- data:\n    return nil\n  case <-ctx.Done():\n    return ctx.Err()\n  }\n}\n\nfunc (t *Tracker) Run() {\n  for data := range t.ch {\n    time.Sleep(1 * time.Second)\n    fmt.Println(data)\n  }\n  t.stop <- struct{}{}\n}\n\nfunc (t *Tracker) Showdown(ctx context.Context) {\n  close(t.ch) //\n  select {\n  case <-t.stop:\n  case <-ctx.Done():\n  }\n}\n\nfunc main() {\n  tr := NewTracker()\n  go tr.Run()\n\n  _ = tr.Event(context.Background(), \"1\")\n  _ = tr.Event(context.Background(), \"2\")\n  _ = tr.Event(context.Background(), \"3\")\n\n  ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(5*time.Second))\n  defer cancel()\n\n  tr.Showdown(ctx)\n}\n```\n\n## 總結\n\n1. 將使用 goroutine 的選擇權交給調用者\n2. 知道所使用的 goroutine 的生命週期(何時開始、何時退出、控制如何退出)，避免 goroutine leak\n3. 調用 goroutine 請加上 `panic` `recovery`機制，避免整個服務直接退出\n4. **如果有大量請求，避免直接創建 goroutine處理**，應該使用`worker`模式來處理，可以避免調oom問題。若請求量很小的話，可以不用理會這個問題\n\n## 參考資料\n\n<https://lailin.xyz/post/go-training-week3-goroutine.html>\n<https://dave.cheney.net/practical-go/presentations/qcon-china.html>\n<https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html>\n<https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html>\n","slug":"golang/goroutine","published":1,"updated":"2022-02-21T06:35:00.102Z","_id":"ckzjn810b0000dmze8jg7d5bm","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在Golang中使用簡單的<code>go</code>關鍵字開啟一個goroutine，但這樣可能會造成開啟過多的goroutine，造成一些無可避免的bug。以下內容會針對golang使用goroutine的一些注意事項</p>\n<span id=\"more\"></span>\n\n<h2 id=\"常見例子\"><a href=\"#常見例子\" class=\"headerlink\" title=\"常見例子\"></a>常見例子</h2><p>我們很常看見以下例子，就讓我們看看這樣會有什麼問題吧</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serveApp</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    mux := http.NewServeMux()</span><br><span class=\"line\">    mux.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class=\"line\">      fmt.Fprintln(resp, <span class=\"string\">&quot;Hello World!&quot;</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := http.ListenAndServe(<span class=\"string\">&quot;:8080&quot;</span>, mux); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      log.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serveDebug</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">go</span> http.ListenAndServe(<span class=\"string\">&quot;:8081&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  serveApp()</span><br><span class=\"line\"></span><br><span class=\"line\">  serveDebug()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">select</span> &#123;&#125; <span class=\"comment\">// 空的select會阻塞</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Leave-concurrency-to-the-caller\"><a href=\"#Leave-concurrency-to-the-caller\" class=\"headerlink\" title=\"Leave concurrency to the caller\"></a>Leave concurrency to the caller</h2><p>請將是否併發的選擇權交給調用者，而不是自己默默加上<code>goroutine</code>，不然這樣調用者不知道調用的函數裡使用goroutine</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serveApp</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  mux := http.NewServeMux()</span><br><span class=\"line\">  mux.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintln(resp, <span class=\"string\">&quot;Hello World!&quot;</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := http.ListenAndServe(<span class=\"string\">&quot;:8080&quot;</span>, mux); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatal(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serveDebug</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  http.ListenAndServe(<span class=\"string\">&quot;:8081&quot;</span>, http.DefaultServeMux)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">go</span> serveDebug()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">go</span> serveApp()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">select</span> &#123;&#125; <span class=\"comment\">// 空的select會阻塞</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Keep-yourself-busy-or-do-the-work-yourself\"><a href=\"#Keep-yourself-busy-or-do-the-work-yourself\" class=\"headerlink\" title=\"Keep yourself busy or do the work yourself\"></a>Keep yourself busy or do the work yourself</h2><p>如果你的 goroutine 無法明確取得進展，這樣通常需要自己做而不是委託給 goroutine 。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serveApp</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  mux := http.NewServeMux()</span><br><span class=\"line\">  mux.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintln(resp, <span class=\"string\">&quot;Hello World!&quot;</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := http.ListenAndServe(<span class=\"string\">&quot;:8080&quot;</span>, mux); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatal(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serveDebug</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  http.ListenAndServe(<span class=\"string\">&quot;:8081&quot;</span>, http.DefaultServeMux)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">go</span> serveDebug()</span><br><span class=\"line\">  </span><br><span class=\"line\">  serveApp()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這樣消除了將結果從 goroutine 返回到其發起者所需的大量狀態跟踪和通道操作。</p>\n<h2 id=\"Never-start-a-goroutine-without-knowning-when-it-will-stop\"><a href=\"#Never-start-a-goroutine-without-knowning-when-it-will-stop\" class=\"headerlink\" title=\"Never start a goroutine without knowning when it will stop\"></a>Never start a goroutine without knowning when it will stop</h2><p>上面的修改還是存在一些問題，當serveDebug發生中斷時，main並不會知道<br>我們使用<code>channel</code>進行改寫通知，詳細代碼如下</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 啟動一個http服務</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">server</span><span class=\"params\">(handler http.Handler, addr <span class=\"keyword\">string</span>, stop &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  s := http.Server&#123;</span><br><span class=\"line\">    Handler: handler,</span><br><span class=\"line\">    Addr:    addr,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 我們可以控制這個goroutine退出，只要 stop 這個 channel close或寫入數據，這裡就會退出</span></span><br><span class=\"line\">  <span class=\"comment\">// 同時也調用 s.Shutdown，server這個func調用的http服務也會優雅下線</span></span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    &lt;-stop</span><br><span class=\"line\">    log.Printf(<span class=\"string\">&quot;server will exiting, addr: %s&quot;</span>, addr)</span><br><span class=\"line\">    s.Shutdown(context.Background())</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> s.ListenAndServe()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serveApp</span><span class=\"params\">(stop &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  mux := http.NewServeMux()</span><br><span class=\"line\">  mux.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintln(resp, <span class=\"string\">&quot;Hello World!&quot;</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> server(mux, <span class=\"string\">&quot;:8080&quot;</span>, stop)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serveDebug</span><span class=\"params\">(stop &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    server(http.DefaultServeMux, <span class=\"string\">&quot;:8001&quot;</span>, stop)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">  <span class=\"comment\">// 這邊模擬debug服務退出</span></span><br><span class=\"line\">  time.Sleep(<span class=\"number\">5</span> * time.Second)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;mock debug exit&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 用於監聽服務是否有錯誤</span></span><br><span class=\"line\">  done := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> error, <span class=\"number\">2</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 用於控制其他的服務退出，只要其中有一個服務退出，其他服務跟著退出</span></span><br><span class=\"line\">  stop := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;, <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    done &lt;- serveDebug(stop)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    done &lt;- serveApp(stop)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 用於判斷當前服務是否停止的狀態</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> stopped <span class=\"keyword\">bool</span></span><br><span class=\"line\">  <span class=\"comment\">// 循環讀取done這個channel</span></span><br><span class=\"line\">  <span class=\"comment\">// 只要有一個錯誤，我們就關閉stop這個channel</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">cap</span>(done); i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := &lt;-done; err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      log.Printf(<span class=\"string\">&quot;server exit err: %+v&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> !stopped &#123;</span><br><span class=\"line\">      stopped = <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"built_in\">close</span>(stop)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>close(chan)的時候，channel還可以讀取，但不能寫入</p>\n</blockquote>\n<p>測試結果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2022/02/11 11:32:40 server <span class=\"built_in\">exit</span> err: mock debug <span class=\"built_in\">exit</span></span><br><span class=\"line\">2022/02/11 11:32:40 server will exiting, addr: :8001</span><br><span class=\"line\">2022/02/11 11:32:40 server will exiting, addr: :8080</span><br><span class=\"line\">2022/02/11 11:32:40 server <span class=\"built_in\">exit</span> err: http: Server closed</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"goroutine-leak\"><a href=\"#goroutine-leak\" class=\"headerlink\" title=\"goroutine leak\"></a>goroutine leak</h2><p>goroutine leak顧名思義就是goroutine一直佔用著資源，無法退出</p>\n<h3 id=\"造成原因\"><a href=\"#造成原因\" class=\"headerlink\" title=\"造成原因\"></a>造成原因</h3><p>大部分的goroutine leak通常是<code>sync</code>、<code>channel</code>操作不當造成的，而且調用方無法控制此 goroutine 退出的方法</p>\n<blockquote>\n<p><code>sync</code>、<code>channel</code>造成 goroutine leak具體內容會在後續文章繼續探討</p>\n</blockquote>\n<p>簡單的範例：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 計算剛開始的 goroutine 數量</span></span><br><span class=\"line\">  startingGs := runtime.NumGoroutine()</span><br><span class=\"line\"></span><br><span class=\"line\">  leak()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 暫停一秒觀察leak()停止後的狀況</span></span><br><span class=\"line\">  time.Sleep(time.Second)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 計算結束後的 goroutine 數量</span></span><br><span class=\"line\">  endingGs := runtime.NumGoroutine()</span><br><span class=\"line\"></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;Number of goroutines before: &quot;</span>, startingGs)</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;Number of goroutines after: &quot;</span>, endingGs)</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;Number of goroutines leaked: &quot;</span>, endingGs-startingGs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 此方法模擬當 channel 一直沒有值進來</span></span><br><span class=\"line\"><span class=\"comment\">// 此 goroutine 會一直阻塞</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">leak</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;We received a value: &quot;</span>, &lt;-ch)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Incomplete-Work\"><a href=\"#Incomplete-Work\" class=\"headerlink\" title=\"Incomplete Work\"></a>Incomplete Work</h2><p>當我們程序中止時，並未等 goroutine 完成它應該完成的工作(非 main goroutine)，就會發生<code>Incomplete work</code></p>\n<p>可以執行以下程式，看看會有什麼結果</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;Hello&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> fmt.Println(<span class=\"string\">&quot;Goodbye&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以發現console只有印出<code>Hello</code>，並沒有等待<code>Goodbye</code>印出再退出程序</p>\n<h3 id=\"這樣會產生什麼問題\"><a href=\"#這樣會產生什麼問題\" class=\"headerlink\" title=\"這樣會產生什麼問題\"></a>這樣會產生什麼問題</h3><p>這樣的方式有可能讓我們在寫檔或寫入資料庫時，造成資料遺漏問題</p>\n<h3 id=\"如何預防\"><a href=\"#如何預防\" class=\"headerlink\" title=\"如何預防\"></a>如何預防</h3><p>以下讓我們看一個模擬web trace服務</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Tracker <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Tracker)</span> <span class=\"title\">Event</span><span class=\"params\">(data <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  time.Sleep(time.Second)</span><br><span class=\"line\">  fmt.Println(data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> App <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  tracker Tracker</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *App)</span> <span class=\"title\">Handle</span><span class=\"params\">(text <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(text + <span class=\"string\">&quot; App.Handle()&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">go</span> a.tracker.Event(text + <span class=\"string\">&quot; Tracker.Event()&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a App</span><br><span class=\"line\"></span><br><span class=\"line\">  a.Handle(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">  a.Handle(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>執行結果:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 App.Handle()</span><br><span class=\"line\">2 App.Handle()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法一-使用-sync-WaitGroup-改寫\"><a href=\"#方法一-使用-sync-WaitGroup-改寫\" class=\"headerlink\" title=\"方法一: 使用 sync.WaitGroup 改寫\"></a>方法一: 使用 sync.WaitGroup 改寫</h4><p>我們可以使用<code>sync.WaitGroup</code>來追蹤每一個創建的 goroutine</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Tracker <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  wg sync.WaitGroup</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Tracker)</span> <span class=\"title\">Event</span><span class=\"params\">(data <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  t.wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"keyword\">defer</span> t.wg.Done()</span><br><span class=\"line\"></span><br><span class=\"line\">    time.Sleep(time.Second)</span><br><span class=\"line\">    fmt.Println(data)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Tracker)</span> <span class=\"title\">Showdown</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  t.wg.Wait()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> App <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  tracker Tracker</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *App)</span> <span class=\"title\">Handle</span><span class=\"params\">(text <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(text + <span class=\"string\">&quot; App.Handle()&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  a.tracker.Event(text + <span class=\"string\">&quot; Tracker.Event()&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a App</span><br><span class=\"line\">  a.Handle(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">  a.Handle(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  a.tracker.Showdown()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>執行結果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 App.Handle()</span><br><span class=\"line\">2 App.Handle()</span><br><span class=\"line\">2 Tracker.Event()</span><br><span class=\"line\">1 Tracker.Event()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法二-設置超時時間\"><a href=\"#方法二-設置超時時間\" class=\"headerlink\" title=\"方法二: 設置超時時間\"></a>方法二: 設置超時時間</h4><p><strong>方法一</strong>可以等待 goroutine 將任務完成再進行關閉，但這樣等待的時間並沒有限制</p>\n<p>有可能造成等待的時間過長，一直無限的等待下去</p>\n<p>為了預防這個問題，我們接著給<code>Showdown()</code>加上超時時間</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Tracker)</span> <span class=\"title\">Showdown</span><span class=\"params\">(ctx context.Context)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    t.wg.Wait()</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> &lt;-ch:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> &lt;-ctx.Done():</span><br><span class=\"line\">    <span class=\"keyword\">return</span> errors.New(<span class=\"string\">&quot;timeout&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我們接著改寫<code>main()</code>，並將<code>Event()</code>延長停止時間，故意讓它發生超時</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Tracker)</span> <span class=\"title\">Event</span><span class=\"params\">(data <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  t.wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> t.wg.Done()</span><br><span class=\"line\">    <span class=\"comment\">// 延長至6秒</span></span><br><span class=\"line\">    time.Sleep(<span class=\"number\">6</span> * time.Second)</span><br><span class=\"line\">    fmt.Println(data)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a App</span><br><span class=\"line\">  a.Handle(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">  a.Handle(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 設置超時時間5秒</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> timeout = <span class=\"number\">5</span> * time.Second</span><br><span class=\"line\">  ctx, cancel := context.WithTimeout(context.Background(), timeout)</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> cancel()</span><br><span class=\"line\"></span><br><span class=\"line\">  err := a.tracker.Showdown(ctx)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Println(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>執行結果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 App.Handle()</span><br><span class=\"line\">2 App.Handle()</span><br><span class=\"line\">xxxx/xx/xx xx:xx:xx timeout</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"補充\"><a href=\"#補充\" class=\"headerlink\" title=\"補充\"></a>補充</h4><p>方法二的改法，會有<code>goroutine</code>過多的問題。我們再多一個<code>stop</code> <code>channel</code>來避免這個問題。詳細代碼如下:</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Tracker <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  ch   <span class=\"keyword\">chan</span> <span class=\"keyword\">string</span></span><br><span class=\"line\">  stop <span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewTracker</span><span class=\"params\">()</span> *<span class=\"title\">Tracker</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;Tracker&#123;</span><br><span class=\"line\">    ch: <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>, <span class=\"number\">10</span>),</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Tracker)</span> <span class=\"title\">Event</span><span class=\"params\">(ctx context.Context, data <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> t.ch &lt;- data:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> &lt;-ctx.Done():</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ctx.Err()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Tracker)</span> <span class=\"title\">Run</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> data := <span class=\"keyword\">range</span> t.ch &#123;</span><br><span class=\"line\">    time.Sleep(<span class=\"number\">1</span> * time.Second)</span><br><span class=\"line\">    fmt.Println(data)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  t.stop &lt;- <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Tracker)</span> <span class=\"title\">Showdown</span><span class=\"params\">(ctx context.Context)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">close</span>(t.ch) <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> &lt;-t.stop:</span><br><span class=\"line\">  <span class=\"keyword\">case</span> &lt;-ctx.Done():</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  tr := NewTracker()</span><br><span class=\"line\">  <span class=\"keyword\">go</span> tr.Run()</span><br><span class=\"line\"></span><br><span class=\"line\">  _ = tr.Event(context.Background(), <span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">  _ = tr.Event(context.Background(), <span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">  _ = tr.Event(context.Background(), <span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(<span class=\"number\">5</span>*time.Second))</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> cancel()</span><br><span class=\"line\"></span><br><span class=\"line\">  tr.Showdown(ctx)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"總結\"><a href=\"#總結\" class=\"headerlink\" title=\"總結\"></a>總結</h2><ol>\n<li>將使用 goroutine 的選擇權交給調用者</li>\n<li>知道所使用的 goroutine 的生命週期(何時開始、何時退出、控制如何退出)，避免 goroutine leak</li>\n<li>調用 goroutine 請加上 <code>panic</code> <code>recovery</code>機制，避免整個服務直接退出</li>\n<li><strong>如果有大量請求，避免直接創建 goroutine處理</strong>，應該使用<code>worker</code>模式來處理，可以避免調oom問題。若請求量很小的話，可以不用理會這個問題</li>\n</ol>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><p><a href=\"https://lailin.xyz/post/go-training-week3-goroutine.html\">https://lailin.xyz/post/go-training-week3-goroutine.html</a><br><a href=\"https://dave.cheney.net/practical-go/presentations/qcon-china.html\">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a><br><a href=\"https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html\">https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html</a><br><a href=\"https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html\">https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html</a></p>\n","site":{"data":{}},"excerpt":"<p>在Golang中使用簡單的<code>go</code>關鍵字開啟一個goroutine，但這樣可能會造成開啟過多的goroutine，造成一些無可避免的bug。以下內容會針對golang使用goroutine的一些注意事項</p>","more":"<h2 id=\"常見例子\"><a href=\"#常見例子\" class=\"headerlink\" title=\"常見例子\"></a>常見例子</h2><p>我們很常看見以下例子，就讓我們看看這樣會有什麼問題吧</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serveApp</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    mux := http.NewServeMux()</span><br><span class=\"line\">    mux.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class=\"line\">      fmt.Fprintln(resp, <span class=\"string\">&quot;Hello World!&quot;</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := http.ListenAndServe(<span class=\"string\">&quot;:8080&quot;</span>, mux); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      log.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serveDebug</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">go</span> http.ListenAndServe(<span class=\"string\">&quot;:8081&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  serveApp()</span><br><span class=\"line\"></span><br><span class=\"line\">  serveDebug()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">select</span> &#123;&#125; <span class=\"comment\">// 空的select會阻塞</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Leave-concurrency-to-the-caller\"><a href=\"#Leave-concurrency-to-the-caller\" class=\"headerlink\" title=\"Leave concurrency to the caller\"></a>Leave concurrency to the caller</h2><p>請將是否併發的選擇權交給調用者，而不是自己默默加上<code>goroutine</code>，不然這樣調用者不知道調用的函數裡使用goroutine</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serveApp</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  mux := http.NewServeMux()</span><br><span class=\"line\">  mux.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintln(resp, <span class=\"string\">&quot;Hello World!&quot;</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := http.ListenAndServe(<span class=\"string\">&quot;:8080&quot;</span>, mux); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatal(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serveDebug</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  http.ListenAndServe(<span class=\"string\">&quot;:8081&quot;</span>, http.DefaultServeMux)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">go</span> serveDebug()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">go</span> serveApp()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">select</span> &#123;&#125; <span class=\"comment\">// 空的select會阻塞</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Keep-yourself-busy-or-do-the-work-yourself\"><a href=\"#Keep-yourself-busy-or-do-the-work-yourself\" class=\"headerlink\" title=\"Keep yourself busy or do the work yourself\"></a>Keep yourself busy or do the work yourself</h2><p>如果你的 goroutine 無法明確取得進展，這樣通常需要自己做而不是委託給 goroutine 。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serveApp</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  mux := http.NewServeMux()</span><br><span class=\"line\">  mux.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintln(resp, <span class=\"string\">&quot;Hello World!&quot;</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := http.ListenAndServe(<span class=\"string\">&quot;:8080&quot;</span>, mux); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatal(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serveDebug</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  http.ListenAndServe(<span class=\"string\">&quot;:8081&quot;</span>, http.DefaultServeMux)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">go</span> serveDebug()</span><br><span class=\"line\">  </span><br><span class=\"line\">  serveApp()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>這樣消除了將結果從 goroutine 返回到其發起者所需的大量狀態跟踪和通道操作。</p>\n<h2 id=\"Never-start-a-goroutine-without-knowning-when-it-will-stop\"><a href=\"#Never-start-a-goroutine-without-knowning-when-it-will-stop\" class=\"headerlink\" title=\"Never start a goroutine without knowning when it will stop\"></a>Never start a goroutine without knowning when it will stop</h2><p>上面的修改還是存在一些問題，當serveDebug發生中斷時，main並不會知道<br>我們使用<code>channel</code>進行改寫通知，詳細代碼如下</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 啟動一個http服務</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">server</span><span class=\"params\">(handler http.Handler, addr <span class=\"keyword\">string</span>, stop &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  s := http.Server&#123;</span><br><span class=\"line\">    Handler: handler,</span><br><span class=\"line\">    Addr:    addr,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 我們可以控制這個goroutine退出，只要 stop 這個 channel close或寫入數據，這裡就會退出</span></span><br><span class=\"line\">  <span class=\"comment\">// 同時也調用 s.Shutdown，server這個func調用的http服務也會優雅下線</span></span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    &lt;-stop</span><br><span class=\"line\">    log.Printf(<span class=\"string\">&quot;server will exiting, addr: %s&quot;</span>, addr)</span><br><span class=\"line\">    s.Shutdown(context.Background())</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> s.ListenAndServe()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serveApp</span><span class=\"params\">(stop &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  mux := http.NewServeMux()</span><br><span class=\"line\">  mux.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintln(resp, <span class=\"string\">&quot;Hello World!&quot;</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> server(mux, <span class=\"string\">&quot;:8080&quot;</span>, stop)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serveDebug</span><span class=\"params\">(stop &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    server(http.DefaultServeMux, <span class=\"string\">&quot;:8001&quot;</span>, stop)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">  <span class=\"comment\">// 這邊模擬debug服務退出</span></span><br><span class=\"line\">  time.Sleep(<span class=\"number\">5</span> * time.Second)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;mock debug exit&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 用於監聽服務是否有錯誤</span></span><br><span class=\"line\">  done := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> error, <span class=\"number\">2</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 用於控制其他的服務退出，只要其中有一個服務退出，其他服務跟著退出</span></span><br><span class=\"line\">  stop := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;, <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    done &lt;- serveDebug(stop)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    done &lt;- serveApp(stop)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 用於判斷當前服務是否停止的狀態</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> stopped <span class=\"keyword\">bool</span></span><br><span class=\"line\">  <span class=\"comment\">// 循環讀取done這個channel</span></span><br><span class=\"line\">  <span class=\"comment\">// 只要有一個錯誤，我們就關閉stop這個channel</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">cap</span>(done); i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := &lt;-done; err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      log.Printf(<span class=\"string\">&quot;server exit err: %+v&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> !stopped &#123;</span><br><span class=\"line\">      stopped = <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"built_in\">close</span>(stop)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>close(chan)的時候，channel還可以讀取，但不能寫入</p>\n</blockquote>\n<p>測試結果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2022/02/11 11:32:40 server <span class=\"built_in\">exit</span> err: mock debug <span class=\"built_in\">exit</span></span><br><span class=\"line\">2022/02/11 11:32:40 server will exiting, addr: :8001</span><br><span class=\"line\">2022/02/11 11:32:40 server will exiting, addr: :8080</span><br><span class=\"line\">2022/02/11 11:32:40 server <span class=\"built_in\">exit</span> err: http: Server closed</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"goroutine-leak\"><a href=\"#goroutine-leak\" class=\"headerlink\" title=\"goroutine leak\"></a>goroutine leak</h2><p>goroutine leak顧名思義就是goroutine一直佔用著資源，無法退出</p>\n<h3 id=\"造成原因\"><a href=\"#造成原因\" class=\"headerlink\" title=\"造成原因\"></a>造成原因</h3><p>大部分的goroutine leak通常是<code>sync</code>、<code>channel</code>操作不當造成的，而且調用方無法控制此 goroutine 退出的方法</p>\n<blockquote>\n<p><code>sync</code>、<code>channel</code>造成 goroutine leak具體內容會在後續文章繼續探討</p>\n</blockquote>\n<p>簡單的範例：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 計算剛開始的 goroutine 數量</span></span><br><span class=\"line\">  startingGs := runtime.NumGoroutine()</span><br><span class=\"line\"></span><br><span class=\"line\">  leak()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 暫停一秒觀察leak()停止後的狀況</span></span><br><span class=\"line\">  time.Sleep(time.Second)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 計算結束後的 goroutine 數量</span></span><br><span class=\"line\">  endingGs := runtime.NumGoroutine()</span><br><span class=\"line\"></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;Number of goroutines before: &quot;</span>, startingGs)</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;Number of goroutines after: &quot;</span>, endingGs)</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;Number of goroutines leaked: &quot;</span>, endingGs-startingGs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 此方法模擬當 channel 一直沒有值進來</span></span><br><span class=\"line\"><span class=\"comment\">// 此 goroutine 會一直阻塞</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">leak</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;We received a value: &quot;</span>, &lt;-ch)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Incomplete-Work\"><a href=\"#Incomplete-Work\" class=\"headerlink\" title=\"Incomplete Work\"></a>Incomplete Work</h2><p>當我們程序中止時，並未等 goroutine 完成它應該完成的工作(非 main goroutine)，就會發生<code>Incomplete work</code></p>\n<p>可以執行以下程式，看看會有什麼結果</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">&quot;Hello&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> fmt.Println(<span class=\"string\">&quot;Goodbye&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以發現console只有印出<code>Hello</code>，並沒有等待<code>Goodbye</code>印出再退出程序</p>\n<h3 id=\"這樣會產生什麼問題\"><a href=\"#這樣會產生什麼問題\" class=\"headerlink\" title=\"這樣會產生什麼問題\"></a>這樣會產生什麼問題</h3><p>這樣的方式有可能讓我們在寫檔或寫入資料庫時，造成資料遺漏問題</p>\n<h3 id=\"如何預防\"><a href=\"#如何預防\" class=\"headerlink\" title=\"如何預防\"></a>如何預防</h3><p>以下讓我們看一個模擬web trace服務</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Tracker <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Tracker)</span> <span class=\"title\">Event</span><span class=\"params\">(data <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  time.Sleep(time.Second)</span><br><span class=\"line\">  fmt.Println(data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> App <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  tracker Tracker</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *App)</span> <span class=\"title\">Handle</span><span class=\"params\">(text <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(text + <span class=\"string\">&quot; App.Handle()&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">go</span> a.tracker.Event(text + <span class=\"string\">&quot; Tracker.Event()&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a App</span><br><span class=\"line\"></span><br><span class=\"line\">  a.Handle(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">  a.Handle(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>執行結果:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 App.Handle()</span><br><span class=\"line\">2 App.Handle()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法一-使用-sync-WaitGroup-改寫\"><a href=\"#方法一-使用-sync-WaitGroup-改寫\" class=\"headerlink\" title=\"方法一: 使用 sync.WaitGroup 改寫\"></a>方法一: 使用 sync.WaitGroup 改寫</h4><p>我們可以使用<code>sync.WaitGroup</code>來追蹤每一個創建的 goroutine</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Tracker <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  wg sync.WaitGroup</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Tracker)</span> <span class=\"title\">Event</span><span class=\"params\">(data <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  t.wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"keyword\">defer</span> t.wg.Done()</span><br><span class=\"line\"></span><br><span class=\"line\">    time.Sleep(time.Second)</span><br><span class=\"line\">    fmt.Println(data)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Tracker)</span> <span class=\"title\">Showdown</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  t.wg.Wait()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> App <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  tracker Tracker</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *App)</span> <span class=\"title\">Handle</span><span class=\"params\">(text <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(text + <span class=\"string\">&quot; App.Handle()&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  a.tracker.Event(text + <span class=\"string\">&quot; Tracker.Event()&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a App</span><br><span class=\"line\">  a.Handle(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">  a.Handle(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  a.tracker.Showdown()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>執行結果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 App.Handle()</span><br><span class=\"line\">2 App.Handle()</span><br><span class=\"line\">2 Tracker.Event()</span><br><span class=\"line\">1 Tracker.Event()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法二-設置超時時間\"><a href=\"#方法二-設置超時時間\" class=\"headerlink\" title=\"方法二: 設置超時時間\"></a>方法二: 設置超時時間</h4><p><strong>方法一</strong>可以等待 goroutine 將任務完成再進行關閉，但這樣等待的時間並沒有限制</p>\n<p>有可能造成等待的時間過長，一直無限的等待下去</p>\n<p>為了預防這個問題，我們接著給<code>Showdown()</code>加上超時時間</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Tracker)</span> <span class=\"title\">Showdown</span><span class=\"params\">(ctx context.Context)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    t.wg.Wait()</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> &lt;-ch:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> &lt;-ctx.Done():</span><br><span class=\"line\">    <span class=\"keyword\">return</span> errors.New(<span class=\"string\">&quot;timeout&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我們接著改寫<code>main()</code>，並將<code>Event()</code>延長停止時間，故意讓它發生超時</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Tracker)</span> <span class=\"title\">Event</span><span class=\"params\">(data <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  t.wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> t.wg.Done()</span><br><span class=\"line\">    <span class=\"comment\">// 延長至6秒</span></span><br><span class=\"line\">    time.Sleep(<span class=\"number\">6</span> * time.Second)</span><br><span class=\"line\">    fmt.Println(data)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a App</span><br><span class=\"line\">  a.Handle(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">  a.Handle(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 設置超時時間5秒</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> timeout = <span class=\"number\">5</span> * time.Second</span><br><span class=\"line\">  ctx, cancel := context.WithTimeout(context.Background(), timeout)</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> cancel()</span><br><span class=\"line\"></span><br><span class=\"line\">  err := a.tracker.Showdown(ctx)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Println(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>執行結果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 App.Handle()</span><br><span class=\"line\">2 App.Handle()</span><br><span class=\"line\">xxxx/xx/xx xx:xx:xx timeout</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"補充\"><a href=\"#補充\" class=\"headerlink\" title=\"補充\"></a>補充</h4><p>方法二的改法，會有<code>goroutine</code>過多的問題。我們再多一個<code>stop</code> <code>channel</code>來避免這個問題。詳細代碼如下:</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Tracker <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  ch   <span class=\"keyword\">chan</span> <span class=\"keyword\">string</span></span><br><span class=\"line\">  stop <span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewTracker</span><span class=\"params\">()</span> *<span class=\"title\">Tracker</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;Tracker&#123;</span><br><span class=\"line\">    ch: <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>, <span class=\"number\">10</span>),</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Tracker)</span> <span class=\"title\">Event</span><span class=\"params\">(ctx context.Context, data <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> t.ch &lt;- data:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> &lt;-ctx.Done():</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ctx.Err()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Tracker)</span> <span class=\"title\">Run</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> data := <span class=\"keyword\">range</span> t.ch &#123;</span><br><span class=\"line\">    time.Sleep(<span class=\"number\">1</span> * time.Second)</span><br><span class=\"line\">    fmt.Println(data)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  t.stop &lt;- <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Tracker)</span> <span class=\"title\">Showdown</span><span class=\"params\">(ctx context.Context)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">close</span>(t.ch) <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> &lt;-t.stop:</span><br><span class=\"line\">  <span class=\"keyword\">case</span> &lt;-ctx.Done():</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  tr := NewTracker()</span><br><span class=\"line\">  <span class=\"keyword\">go</span> tr.Run()</span><br><span class=\"line\"></span><br><span class=\"line\">  _ = tr.Event(context.Background(), <span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">  _ = tr.Event(context.Background(), <span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">  _ = tr.Event(context.Background(), <span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(<span class=\"number\">5</span>*time.Second))</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> cancel()</span><br><span class=\"line\"></span><br><span class=\"line\">  tr.Showdown(ctx)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"總結\"><a href=\"#總結\" class=\"headerlink\" title=\"總結\"></a>總結</h2><ol>\n<li>將使用 goroutine 的選擇權交給調用者</li>\n<li>知道所使用的 goroutine 的生命週期(何時開始、何時退出、控制如何退出)，避免 goroutine leak</li>\n<li>調用 goroutine 請加上 <code>panic</code> <code>recovery</code>機制，避免整個服務直接退出</li>\n<li><strong>如果有大量請求，避免直接創建 goroutine處理</strong>，應該使用<code>worker</code>模式來處理，可以避免調oom問題。若請求量很小的話，可以不用理會這個問題</li>\n</ol>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><p><a href=\"https://lailin.xyz/post/go-training-week3-goroutine.html\">https://lailin.xyz/post/go-training-week3-goroutine.html</a><br><a href=\"https://dave.cheney.net/practical-go/presentations/qcon-china.html\">https://dave.cheney.net/practical-go/presentations/qcon-china.html</a><br><a href=\"https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html\">https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html</a><br><a href=\"https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html\">https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html</a></p>"},{"title":"[Golang] Memory Model","date":"2022-02-21T06:36:01.000Z","toc":true,"_content":"\nMemory Modle在goroutine裡是非常重要的一環，理解它才能明白許多競爭問題。Go官方文章：[\"The Go Memory Model\"](https://go.dev/ref/mem)裡有精確的解說。建議多看幾遍官方文章，再看這篇文章，會有更多的收穫\n\n<!-- more -->\n\n## Happens Before\n\n### 定義\n\n在文章中`Happens Before`的定義如下:\n\n> To specify the requirements of reads and writes, we define happens before, a partial order on the execution of memory operations in a Go program. If event `e1` happens before event `e2`, then we say that `e2` happens after `e1`. Also, if `e1` does not happen before `e2` and does not happen after `e2`, then we say that `e1` and `e2` happen concurrently.\n\n意思就是說，如果`e1`發生在`e2`之前，我們也可以說`e2`發生在`e1`之後，如果`e1`既不在`e2`前，也不在`e2`後，我們就說我們就說`e1`與`e2`是併發狀態\n\n> Within a single goroutine, the happens-before order is the order expressed by the program.\n\n在單個goroutine中，事件發生的順序，就是程式執行的順序\n\n> A read r of a variable `v` is allowed to observe a write `w` to `v` if both of the following hold:\n>\n> 1. r does not happen before `w`.\n> 2. There is no other write `w'` to v that happens after w but before `r`.\n\n我們現在有一個變量`v`，如果以下兩個條件都成立，則**允許**對變量 `v` 的讀操作`r` 觀察到對 `v` 的寫操作`w`：\n\n1. 讀操作`r`發生在寫操作`w`之後\n2. 在寫操作`w`之後讀操作`r`之前，沒有其他對`v`的寫操作\n\n> To guarantee that a read `r` of a variable `v` observes a particular write `w` to `v`, ensure that `w` is the only write `r` is allowed to observe. That is, `r` is guaranteed to observe `w` if both of the following hold:\n>\n> 1. `w` happens before `r`.\n> 2. Any other write to the shared variable `v` either happens before `w` or after `r`.\n\n為了保證對變量`v`的讀操作`r`看到對`v`的寫操作`w`，要確保`w`是`r`允許看到的唯一寫操作。即當下面條件滿足時，`r`**保證**看到`w`:\n\n1. `w`發生在`r`之前\n2. 其他對共享變量`v`的寫操前只能發生在`w`之前`r`之後\n\n這一個條件比前面的條件更嚴格，需要確保沒有其他的寫操作與`w`或`r`併發\n\n+ 在單個goroutine中，這兩個條件式相等的，因為單個goroutine中不存在併發\n+ 在多個goroutine中就必須使用同步來確保順序，這樣才能保證能夠監測到預期的寫入\n\n### 圖示\n\n#### 單個goroutine\n\n我們可以發現在單個goroutine中，讀操作`r`總是可以讀取到上一次`w`寫入的值\n![單個goroutine](/images/golang/memory-model/single-goroutine.png)\n\n#### 多個goroutine\n\n但在多個goroutine的狀況下舊部一定了，`r0`讀到的會是哪一個寫入的值？如果單純看圖像是`w4`，但其實不一定，因為每條goroutine執行的時間都不一定，因此這兩條goroutine在邏輯上並無先後順序\n\n所以`r0`可能讀到的是`w0 w3 w4`甚至`w5`的結果，若是按照我們前面說的理論，讀到的不可能是`w1`的結果\n\n![多個goroutine](/images/golang/memory-model/multi-goroutine.png)\n\n#### 增加同步點\n\n在下圖中為兩個goroutine增加3個同步點。這樣的話，對於`r1`來說晚於`w4`且早於`w1`和`w5`執行，所以`r1`讀取到的值確定是`w4`\n\n`r2`之前的寫操作為`w4`，與其併發的有`w1`，所以`r2`的值是不確定。有可能是`w1`也可能是`w4`\n\n![增加同步點](/images/golang/memory-model/sync.png)\n\n### 建議\n\n> Programs that modify data being simultaneously accessed by multiple goroutines must serialize such access.\nTo serialize access, protect the data with `channel` operations or other synchronization primitives such as those in the `sync` and `sync/atomic` packages.\n\n如果程式中存在多個goroutine去訪問數據時，必須**序列化訪問**，如何保證序列化呢？ 我們可以使用`channel`或者`sync`以及`sync/auomic`所提供的同步語法來保證\n\n## Memory Reordering\n\n我們所寫下的程式都會經過編譯才能運行到CPU上，而為了有效利用CPU最高的性能，通常使用流水線(Pipeline)、分支預測(Branch predictor)等等。為了提高讀寫memory的效率，會對讀寫指令進行重新排列，這就是所謂的`Memory Reordering`\n\n### 編輯器重排(Compiler Reordering)\n\n我們來看一個例子：\n\n```bash\nX = 0\nfor i in range(100):\n  X = 1\n  print X\n```\n\n在這段程式碼中，X在for循環中重複被賦值了100次1，這簡直沒有必要。於是編譯器就會幫我們優化成下面的程式碼\n\n```bash\nX = 1\nfor i in range(100):\n  print X\n```\n\n這樣的優化，減少了100次的賦值，同樣也輸出100個1。\n\n在單個goroutin中這樣並不會改變執行的順序。\n\n但在多個goroutine中，如果有一個goroutine做了 X = 0，這個輸出就有可能變成111100110111101111100000111...這樣的結果。\n\n所以在多個goroutine裡為了訪問數據的正確性，需要前面所說的**序列化訪問**\n\n> 在多核心場景下，沒有辦法輕易判斷兩段程式是否`等價`\n\n### CPU reordering\n\nCPU為了弭平Kernel、memory、disk之間的速度差異，使用了各種方式，三級緩存就是其中一種。這種為了加速所設計的緩存系統，有可能會帶來數據不一致的問題\n\n![CPU store buffer](/images/golang/memory-model/cpu-store-buffer.png)\n\n1. 先執行①跟③，Core1將A=1寫入Core1的store buffer，Core2將B=1寫入Core2的store buffer\n2. 接著執行②、④\n3. ②看了store buffer沒有發現B的值，於是從Memory讀出了0\n4. ④同樣從Memory讀出了0\n5. 最後輸出了00\n\n因此對多執行緒的程式，所有CPU都會提供\"鎖\"的支持，稱為`barrier`或`fence`。\n更多內容可參考: <https://cch123.github.io/ooo/>\n\n## 總結\n\n此篇文章稍微解釋了一下，在程式運行中變量是如何會有競爭關係。以及再稍為提一下程式在編譯與運行在機器上會幫我們進行優化動作所產生的問題。所以當我們在寫goroutine邏輯時需要特別小心，有使用到共用變量的話，可以使用Go官方所提供的同步方法\n\n## 參考資料\n\n+ <https://lailin.xyz/post/go-training-week3-go-memory-model.html>\n+ <https://go.dev/ref/mem>\n+ <https://go-zh.org/ref/mem>\n+ <https://cch123.github.io/ooo/>\n","source":"_posts/golang/memory-model.md","raw":"---\ntitle: '[Golang] Memory Model'\ndate: 2022-02-21 14:36:01\ntags: golang\ncategories: 學習\ntoc: true\n# cover: /images/golang/grpc-icon-color.png\n---\n\nMemory Modle在goroutine裡是非常重要的一環，理解它才能明白許多競爭問題。Go官方文章：[\"The Go Memory Model\"](https://go.dev/ref/mem)裡有精確的解說。建議多看幾遍官方文章，再看這篇文章，會有更多的收穫\n\n<!-- more -->\n\n## Happens Before\n\n### 定義\n\n在文章中`Happens Before`的定義如下:\n\n> To specify the requirements of reads and writes, we define happens before, a partial order on the execution of memory operations in a Go program. If event `e1` happens before event `e2`, then we say that `e2` happens after `e1`. Also, if `e1` does not happen before `e2` and does not happen after `e2`, then we say that `e1` and `e2` happen concurrently.\n\n意思就是說，如果`e1`發生在`e2`之前，我們也可以說`e2`發生在`e1`之後，如果`e1`既不在`e2`前，也不在`e2`後，我們就說我們就說`e1`與`e2`是併發狀態\n\n> Within a single goroutine, the happens-before order is the order expressed by the program.\n\n在單個goroutine中，事件發生的順序，就是程式執行的順序\n\n> A read r of a variable `v` is allowed to observe a write `w` to `v` if both of the following hold:\n>\n> 1. r does not happen before `w`.\n> 2. There is no other write `w'` to v that happens after w but before `r`.\n\n我們現在有一個變量`v`，如果以下兩個條件都成立，則**允許**對變量 `v` 的讀操作`r` 觀察到對 `v` 的寫操作`w`：\n\n1. 讀操作`r`發生在寫操作`w`之後\n2. 在寫操作`w`之後讀操作`r`之前，沒有其他對`v`的寫操作\n\n> To guarantee that a read `r` of a variable `v` observes a particular write `w` to `v`, ensure that `w` is the only write `r` is allowed to observe. That is, `r` is guaranteed to observe `w` if both of the following hold:\n>\n> 1. `w` happens before `r`.\n> 2. Any other write to the shared variable `v` either happens before `w` or after `r`.\n\n為了保證對變量`v`的讀操作`r`看到對`v`的寫操作`w`，要確保`w`是`r`允許看到的唯一寫操作。即當下面條件滿足時，`r`**保證**看到`w`:\n\n1. `w`發生在`r`之前\n2. 其他對共享變量`v`的寫操前只能發生在`w`之前`r`之後\n\n這一個條件比前面的條件更嚴格，需要確保沒有其他的寫操作與`w`或`r`併發\n\n+ 在單個goroutine中，這兩個條件式相等的，因為單個goroutine中不存在併發\n+ 在多個goroutine中就必須使用同步來確保順序，這樣才能保證能夠監測到預期的寫入\n\n### 圖示\n\n#### 單個goroutine\n\n我們可以發現在單個goroutine中，讀操作`r`總是可以讀取到上一次`w`寫入的值\n![單個goroutine](/images/golang/memory-model/single-goroutine.png)\n\n#### 多個goroutine\n\n但在多個goroutine的狀況下舊部一定了，`r0`讀到的會是哪一個寫入的值？如果單純看圖像是`w4`，但其實不一定，因為每條goroutine執行的時間都不一定，因此這兩條goroutine在邏輯上並無先後順序\n\n所以`r0`可能讀到的是`w0 w3 w4`甚至`w5`的結果，若是按照我們前面說的理論，讀到的不可能是`w1`的結果\n\n![多個goroutine](/images/golang/memory-model/multi-goroutine.png)\n\n#### 增加同步點\n\n在下圖中為兩個goroutine增加3個同步點。這樣的話，對於`r1`來說晚於`w4`且早於`w1`和`w5`執行，所以`r1`讀取到的值確定是`w4`\n\n`r2`之前的寫操作為`w4`，與其併發的有`w1`，所以`r2`的值是不確定。有可能是`w1`也可能是`w4`\n\n![增加同步點](/images/golang/memory-model/sync.png)\n\n### 建議\n\n> Programs that modify data being simultaneously accessed by multiple goroutines must serialize such access.\nTo serialize access, protect the data with `channel` operations or other synchronization primitives such as those in the `sync` and `sync/atomic` packages.\n\n如果程式中存在多個goroutine去訪問數據時，必須**序列化訪問**，如何保證序列化呢？ 我們可以使用`channel`或者`sync`以及`sync/auomic`所提供的同步語法來保證\n\n## Memory Reordering\n\n我們所寫下的程式都會經過編譯才能運行到CPU上，而為了有效利用CPU最高的性能，通常使用流水線(Pipeline)、分支預測(Branch predictor)等等。為了提高讀寫memory的效率，會對讀寫指令進行重新排列，這就是所謂的`Memory Reordering`\n\n### 編輯器重排(Compiler Reordering)\n\n我們來看一個例子：\n\n```bash\nX = 0\nfor i in range(100):\n  X = 1\n  print X\n```\n\n在這段程式碼中，X在for循環中重複被賦值了100次1，這簡直沒有必要。於是編譯器就會幫我們優化成下面的程式碼\n\n```bash\nX = 1\nfor i in range(100):\n  print X\n```\n\n這樣的優化，減少了100次的賦值，同樣也輸出100個1。\n\n在單個goroutin中這樣並不會改變執行的順序。\n\n但在多個goroutine中，如果有一個goroutine做了 X = 0，這個輸出就有可能變成111100110111101111100000111...這樣的結果。\n\n所以在多個goroutine裡為了訪問數據的正確性，需要前面所說的**序列化訪問**\n\n> 在多核心場景下，沒有辦法輕易判斷兩段程式是否`等價`\n\n### CPU reordering\n\nCPU為了弭平Kernel、memory、disk之間的速度差異，使用了各種方式，三級緩存就是其中一種。這種為了加速所設計的緩存系統，有可能會帶來數據不一致的問題\n\n![CPU store buffer](/images/golang/memory-model/cpu-store-buffer.png)\n\n1. 先執行①跟③，Core1將A=1寫入Core1的store buffer，Core2將B=1寫入Core2的store buffer\n2. 接著執行②、④\n3. ②看了store buffer沒有發現B的值，於是從Memory讀出了0\n4. ④同樣從Memory讀出了0\n5. 最後輸出了00\n\n因此對多執行緒的程式，所有CPU都會提供\"鎖\"的支持，稱為`barrier`或`fence`。\n更多內容可參考: <https://cch123.github.io/ooo/>\n\n## 總結\n\n此篇文章稍微解釋了一下，在程式運行中變量是如何會有競爭關係。以及再稍為提一下程式在編譯與運行在機器上會幫我們進行優化動作所產生的問題。所以當我們在寫goroutine邏輯時需要特別小心，有使用到共用變量的話，可以使用Go官方所提供的同步方法\n\n## 參考資料\n\n+ <https://lailin.xyz/post/go-training-week3-go-memory-model.html>\n+ <https://go.dev/ref/mem>\n+ <https://go-zh.org/ref/mem>\n+ <https://cch123.github.io/ooo/>\n","slug":"golang/memory-model","published":1,"updated":"2022-09-04T07:43:39.090Z","_id":"ckzz01d5e00003kze372d9o15","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Memory Modle在goroutine裡是非常重要的一環，理解它才能明白許多競爭問題。Go官方文章：<a href=\"https://go.dev/ref/mem\">“The Go Memory Model”</a>裡有精確的解說。建議多看幾遍官方文章，再看這篇文章，會有更多的收穫</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Happens-Before\"><a href=\"#Happens-Before\" class=\"headerlink\" title=\"Happens Before\"></a>Happens Before</h2><h3 id=\"定義\"><a href=\"#定義\" class=\"headerlink\" title=\"定義\"></a>定義</h3><p>在文章中<code>Happens Before</code>的定義如下:</p>\n<blockquote>\n<p>To specify the requirements of reads and writes, we define happens before, a partial order on the execution of memory operations in a Go program. If event <code>e1</code> happens before event <code>e2</code>, then we say that <code>e2</code> happens after <code>e1</code>. Also, if <code>e1</code> does not happen before <code>e2</code> and does not happen after <code>e2</code>, then we say that <code>e1</code> and <code>e2</code> happen concurrently.</p>\n</blockquote>\n<p>意思就是說，如果<code>e1</code>發生在<code>e2</code>之前，我們也可以說<code>e2</code>發生在<code>e1</code>之後，如果<code>e1</code>既不在<code>e2</code>前，也不在<code>e2</code>後，我們就說我們就說<code>e1</code>與<code>e2</code>是併發狀態</p>\n<blockquote>\n<p>Within a single goroutine, the happens-before order is the order expressed by the program.</p>\n</blockquote>\n<p>在單個goroutine中，事件發生的順序，就是程式執行的順序</p>\n<blockquote>\n<p>A read r of a variable <code>v</code> is allowed to observe a write <code>w</code> to <code>v</code> if both of the following hold:</p>\n<ol>\n<li>r does not happen before <code>w</code>.</li>\n<li>There is no other write <code>w&#39;</code> to v that happens after w but before <code>r</code>.</li>\n</ol>\n</blockquote>\n<p>我們現在有一個變量<code>v</code>，如果以下兩個條件都成立，則<strong>允許</strong>對變量 <code>v</code> 的讀操作<code>r</code> 觀察到對 <code>v</code> 的寫操作<code>w</code>：</p>\n<ol>\n<li>讀操作<code>r</code>發生在寫操作<code>w</code>之後</li>\n<li>在寫操作<code>w</code>之後讀操作<code>r</code>之前，沒有其他對<code>v</code>的寫操作</li>\n</ol>\n<blockquote>\n<p>To guarantee that a read <code>r</code> of a variable <code>v</code> observes a particular write <code>w</code> to <code>v</code>, ensure that <code>w</code> is the only write <code>r</code> is allowed to observe. That is, <code>r</code> is guaranteed to observe <code>w</code> if both of the following hold:</p>\n<ol>\n<li><code>w</code> happens before <code>r</code>.</li>\n<li>Any other write to the shared variable <code>v</code> either happens before <code>w</code> or after <code>r</code>.</li>\n</ol>\n</blockquote>\n<p>為了保證對變量<code>v</code>的讀操作<code>r</code>看到對<code>v</code>的寫操作<code>w</code>，要確保<code>w</code>是<code>r</code>允許看到的唯一寫操作。即當下面條件滿足時，<code>r</code><strong>保證</strong>看到<code>w</code>:</p>\n<ol>\n<li><code>w</code>發生在<code>r</code>之前</li>\n<li>其他對共享變量<code>v</code>的寫操前只能發生在<code>w</code>之前<code>r</code>之後</li>\n</ol>\n<p>這一個條件比前面的條件更嚴格，需要確保沒有其他的寫操作與<code>w</code>或<code>r</code>併發</p>\n<ul>\n<li>在單個goroutine中，這兩個條件式相等的，因為單個goroutine中不存在併發</li>\n<li>在多個goroutine中就必須使用同步來確保順序，這樣才能保證能夠監測到預期的寫入</li>\n</ul>\n<h3 id=\"圖示\"><a href=\"#圖示\" class=\"headerlink\" title=\"圖示\"></a>圖示</h3><h4 id=\"單個goroutine\"><a href=\"#單個goroutine\" class=\"headerlink\" title=\"單個goroutine\"></a>單個goroutine</h4><p>我們可以發現在單個goroutine中，讀操作<code>r</code>總是可以讀取到上一次<code>w</code>寫入的值<br><img src=\"/images/golang/memory-model/single-goroutine.png\" alt=\"單個goroutine\"></p>\n<h4 id=\"多個goroutine\"><a href=\"#多個goroutine\" class=\"headerlink\" title=\"多個goroutine\"></a>多個goroutine</h4><p>但在多個goroutine的狀況下舊部一定了，<code>r0</code>讀到的會是哪一個寫入的值？如果單純看圖像是<code>w4</code>，但其實不一定，因為每條goroutine執行的時間都不一定，因此這兩條goroutine在邏輯上並無先後順序</p>\n<p>所以<code>r0</code>可能讀到的是<code>w0 w3 w4</code>甚至<code>w5</code>的結果，若是按照我們前面說的理論，讀到的不可能是<code>w1</code>的結果</p>\n<p><img src=\"/images/golang/memory-model/multi-goroutine.png\" alt=\"多個goroutine\"></p>\n<h4 id=\"增加同步點\"><a href=\"#增加同步點\" class=\"headerlink\" title=\"增加同步點\"></a>增加同步點</h4><p>在下圖中為兩個goroutine增加3個同步點。這樣的話，對於<code>r1</code>來說晚於<code>w4</code>且早於<code>w1</code>和<code>w5</code>執行，所以<code>r1</code>讀取到的值確定是<code>w4</code></p>\n<p><code>r2</code>之前的寫操作為<code>w4</code>，與其併發的有<code>w1</code>，所以<code>r2</code>的值是不確定。有可能是<code>w1</code>也可能是<code>w4</code></p>\n<p><img src=\"/images/golang/memory-model/sync.png\" alt=\"增加同步點\"></p>\n<h3 id=\"建議\"><a href=\"#建議\" class=\"headerlink\" title=\"建議\"></a>建議</h3><blockquote>\n<p>Programs that modify data being simultaneously accessed by multiple goroutines must serialize such access.<br>To serialize access, protect the data with <code>channel</code> operations or other synchronization primitives such as those in the <code>sync</code> and <code>sync/atomic</code> packages.</p>\n</blockquote>\n<p>如果程式中存在多個goroutine去訪問數據時，必須<strong>序列化訪問</strong>，如何保證序列化呢？ 我們可以使用<code>channel</code>或者<code>sync</code>以及<code>sync/auomic</code>所提供的同步語法來保證</p>\n<h2 id=\"Memory-Reordering\"><a href=\"#Memory-Reordering\" class=\"headerlink\" title=\"Memory Reordering\"></a>Memory Reordering</h2><p>我們所寫下的程式都會經過編譯才能運行到CPU上，而為了有效利用CPU最高的性能，通常使用流水線(Pipeline)、分支預測(Branch predictor)等等。為了提高讀寫memory的效率，會對讀寫指令進行重新排列，這就是所謂的<code>Memory Reordering</code></p>\n<h3 id=\"編輯器重排-Compiler-Reordering\"><a href=\"#編輯器重排-Compiler-Reordering\" class=\"headerlink\" title=\"編輯器重排(Compiler Reordering)\"></a>編輯器重排(Compiler Reordering)</h3><p>我們來看一個例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X = 0</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(100):</span><br><span class=\"line\">  X = 1</span><br><span class=\"line\">  <span class=\"built_in\">print</span> X</span><br></pre></td></tr></table></figure>\n\n<p>在這段程式碼中，X在for循環中重複被賦值了100次1，這簡直沒有必要。於是編譯器就會幫我們優化成下面的程式碼</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X = 1</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(100):</span><br><span class=\"line\">  <span class=\"built_in\">print</span> X</span><br></pre></td></tr></table></figure>\n\n<p>這樣的優化，減少了100次的賦值，同樣也輸出100個1。</p>\n<p>在單個goroutin中這樣並不會改變執行的順序。</p>\n<p>但在多個goroutine中，如果有一個goroutine做了 X &#x3D; 0，這個輸出就有可能變成111100110111101111100000111…這樣的結果。</p>\n<p>所以在多個goroutine裡為了訪問數據的正確性，需要前面所說的<strong>序列化訪問</strong></p>\n<blockquote>\n<p>在多核心場景下，沒有辦法輕易判斷兩段程式是否<code>等價</code></p>\n</blockquote>\n<h3 id=\"CPU-reordering\"><a href=\"#CPU-reordering\" class=\"headerlink\" title=\"CPU reordering\"></a>CPU reordering</h3><p>CPU為了弭平Kernel、memory、disk之間的速度差異，使用了各種方式，三級緩存就是其中一種。這種為了加速所設計的緩存系統，有可能會帶來數據不一致的問題</p>\n<p><img src=\"/images/golang/memory-model/cpu-store-buffer.png\" alt=\"CPU store buffer\"></p>\n<ol>\n<li>先執行①跟③，Core1將A&#x3D;1寫入Core1的store buffer，Core2將B&#x3D;1寫入Core2的store buffer</li>\n<li>接著執行②、④</li>\n<li>②看了store buffer沒有發現B的值，於是從Memory讀出了0</li>\n<li>④同樣從Memory讀出了0</li>\n<li>最後輸出了00</li>\n</ol>\n<p>因此對多執行緒的程式，所有CPU都會提供”鎖”的支持，稱為<code>barrier</code>或<code>fence</code>。<br>更多內容可參考: <a href=\"https://cch123.github.io/ooo/\">https://cch123.github.io/ooo/</a></p>\n<h2 id=\"總結\"><a href=\"#總結\" class=\"headerlink\" title=\"總結\"></a>總結</h2><p>此篇文章稍微解釋了一下，在程式運行中變量是如何會有競爭關係。以及再稍為提一下程式在編譯與運行在機器上會幫我們進行優化動作所產生的問題。所以當我們在寫goroutine邏輯時需要特別小心，有使用到共用變量的話，可以使用Go官方所提供的同步方法</p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://lailin.xyz/post/go-training-week3-go-memory-model.html\">https://lailin.xyz/post/go-training-week3-go-memory-model.html</a></li>\n<li><a href=\"https://go.dev/ref/mem\">https://go.dev/ref/mem</a></li>\n<li><a href=\"https://go-zh.org/ref/mem\">https://go-zh.org/ref/mem</a></li>\n<li><a href=\"https://cch123.github.io/ooo/\">https://cch123.github.io/ooo/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Memory Modle在goroutine裡是非常重要的一環，理解它才能明白許多競爭問題。Go官方文章：<a href=\"https://go.dev/ref/mem\">“The Go Memory Model”</a>裡有精確的解說。建議多看幾遍官方文章，再看這篇文章，會有更多的收穫</p>","more":"<h2 id=\"Happens-Before\"><a href=\"#Happens-Before\" class=\"headerlink\" title=\"Happens Before\"></a>Happens Before</h2><h3 id=\"定義\"><a href=\"#定義\" class=\"headerlink\" title=\"定義\"></a>定義</h3><p>在文章中<code>Happens Before</code>的定義如下:</p>\n<blockquote>\n<p>To specify the requirements of reads and writes, we define happens before, a partial order on the execution of memory operations in a Go program. If event <code>e1</code> happens before event <code>e2</code>, then we say that <code>e2</code> happens after <code>e1</code>. Also, if <code>e1</code> does not happen before <code>e2</code> and does not happen after <code>e2</code>, then we say that <code>e1</code> and <code>e2</code> happen concurrently.</p>\n</blockquote>\n<p>意思就是說，如果<code>e1</code>發生在<code>e2</code>之前，我們也可以說<code>e2</code>發生在<code>e1</code>之後，如果<code>e1</code>既不在<code>e2</code>前，也不在<code>e2</code>後，我們就說我們就說<code>e1</code>與<code>e2</code>是併發狀態</p>\n<blockquote>\n<p>Within a single goroutine, the happens-before order is the order expressed by the program.</p>\n</blockquote>\n<p>在單個goroutine中，事件發生的順序，就是程式執行的順序</p>\n<blockquote>\n<p>A read r of a variable <code>v</code> is allowed to observe a write <code>w</code> to <code>v</code> if both of the following hold:</p>\n<ol>\n<li>r does not happen before <code>w</code>.</li>\n<li>There is no other write <code>w&#39;</code> to v that happens after w but before <code>r</code>.</li>\n</ol>\n</blockquote>\n<p>我們現在有一個變量<code>v</code>，如果以下兩個條件都成立，則<strong>允許</strong>對變量 <code>v</code> 的讀操作<code>r</code> 觀察到對 <code>v</code> 的寫操作<code>w</code>：</p>\n<ol>\n<li>讀操作<code>r</code>發生在寫操作<code>w</code>之後</li>\n<li>在寫操作<code>w</code>之後讀操作<code>r</code>之前，沒有其他對<code>v</code>的寫操作</li>\n</ol>\n<blockquote>\n<p>To guarantee that a read <code>r</code> of a variable <code>v</code> observes a particular write <code>w</code> to <code>v</code>, ensure that <code>w</code> is the only write <code>r</code> is allowed to observe. That is, <code>r</code> is guaranteed to observe <code>w</code> if both of the following hold:</p>\n<ol>\n<li><code>w</code> happens before <code>r</code>.</li>\n<li>Any other write to the shared variable <code>v</code> either happens before <code>w</code> or after <code>r</code>.</li>\n</ol>\n</blockquote>\n<p>為了保證對變量<code>v</code>的讀操作<code>r</code>看到對<code>v</code>的寫操作<code>w</code>，要確保<code>w</code>是<code>r</code>允許看到的唯一寫操作。即當下面條件滿足時，<code>r</code><strong>保證</strong>看到<code>w</code>:</p>\n<ol>\n<li><code>w</code>發生在<code>r</code>之前</li>\n<li>其他對共享變量<code>v</code>的寫操前只能發生在<code>w</code>之前<code>r</code>之後</li>\n</ol>\n<p>這一個條件比前面的條件更嚴格，需要確保沒有其他的寫操作與<code>w</code>或<code>r</code>併發</p>\n<ul>\n<li>在單個goroutine中，這兩個條件式相等的，因為單個goroutine中不存在併發</li>\n<li>在多個goroutine中就必須使用同步來確保順序，這樣才能保證能夠監測到預期的寫入</li>\n</ul>\n<h3 id=\"圖示\"><a href=\"#圖示\" class=\"headerlink\" title=\"圖示\"></a>圖示</h3><h4 id=\"單個goroutine\"><a href=\"#單個goroutine\" class=\"headerlink\" title=\"單個goroutine\"></a>單個goroutine</h4><p>我們可以發現在單個goroutine中，讀操作<code>r</code>總是可以讀取到上一次<code>w</code>寫入的值<br><img src=\"/images/golang/memory-model/single-goroutine.png\" alt=\"單個goroutine\"></p>\n<h4 id=\"多個goroutine\"><a href=\"#多個goroutine\" class=\"headerlink\" title=\"多個goroutine\"></a>多個goroutine</h4><p>但在多個goroutine的狀況下舊部一定了，<code>r0</code>讀到的會是哪一個寫入的值？如果單純看圖像是<code>w4</code>，但其實不一定，因為每條goroutine執行的時間都不一定，因此這兩條goroutine在邏輯上並無先後順序</p>\n<p>所以<code>r0</code>可能讀到的是<code>w0 w3 w4</code>甚至<code>w5</code>的結果，若是按照我們前面說的理論，讀到的不可能是<code>w1</code>的結果</p>\n<p><img src=\"/images/golang/memory-model/multi-goroutine.png\" alt=\"多個goroutine\"></p>\n<h4 id=\"增加同步點\"><a href=\"#增加同步點\" class=\"headerlink\" title=\"增加同步點\"></a>增加同步點</h4><p>在下圖中為兩個goroutine增加3個同步點。這樣的話，對於<code>r1</code>來說晚於<code>w4</code>且早於<code>w1</code>和<code>w5</code>執行，所以<code>r1</code>讀取到的值確定是<code>w4</code></p>\n<p><code>r2</code>之前的寫操作為<code>w4</code>，與其併發的有<code>w1</code>，所以<code>r2</code>的值是不確定。有可能是<code>w1</code>也可能是<code>w4</code></p>\n<p><img src=\"/images/golang/memory-model/sync.png\" alt=\"增加同步點\"></p>\n<h3 id=\"建議\"><a href=\"#建議\" class=\"headerlink\" title=\"建議\"></a>建議</h3><blockquote>\n<p>Programs that modify data being simultaneously accessed by multiple goroutines must serialize such access.<br>To serialize access, protect the data with <code>channel</code> operations or other synchronization primitives such as those in the <code>sync</code> and <code>sync/atomic</code> packages.</p>\n</blockquote>\n<p>如果程式中存在多個goroutine去訪問數據時，必須<strong>序列化訪問</strong>，如何保證序列化呢？ 我們可以使用<code>channel</code>或者<code>sync</code>以及<code>sync/auomic</code>所提供的同步語法來保證</p>\n<h2 id=\"Memory-Reordering\"><a href=\"#Memory-Reordering\" class=\"headerlink\" title=\"Memory Reordering\"></a>Memory Reordering</h2><p>我們所寫下的程式都會經過編譯才能運行到CPU上，而為了有效利用CPU最高的性能，通常使用流水線(Pipeline)、分支預測(Branch predictor)等等。為了提高讀寫memory的效率，會對讀寫指令進行重新排列，這就是所謂的<code>Memory Reordering</code></p>\n<h3 id=\"編輯器重排-Compiler-Reordering\"><a href=\"#編輯器重排-Compiler-Reordering\" class=\"headerlink\" title=\"編輯器重排(Compiler Reordering)\"></a>編輯器重排(Compiler Reordering)</h3><p>我們來看一個例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X = 0</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(100):</span><br><span class=\"line\">  X = 1</span><br><span class=\"line\">  <span class=\"built_in\">print</span> X</span><br></pre></td></tr></table></figure>\n\n<p>在這段程式碼中，X在for循環中重複被賦值了100次1，這簡直沒有必要。於是編譯器就會幫我們優化成下面的程式碼</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X = 1</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(100):</span><br><span class=\"line\">  <span class=\"built_in\">print</span> X</span><br></pre></td></tr></table></figure>\n\n<p>這樣的優化，減少了100次的賦值，同樣也輸出100個1。</p>\n<p>在單個goroutin中這樣並不會改變執行的順序。</p>\n<p>但在多個goroutine中，如果有一個goroutine做了 X &#x3D; 0，這個輸出就有可能變成111100110111101111100000111…這樣的結果。</p>\n<p>所以在多個goroutine裡為了訪問數據的正確性，需要前面所說的<strong>序列化訪問</strong></p>\n<blockquote>\n<p>在多核心場景下，沒有辦法輕易判斷兩段程式是否<code>等價</code></p>\n</blockquote>\n<h3 id=\"CPU-reordering\"><a href=\"#CPU-reordering\" class=\"headerlink\" title=\"CPU reordering\"></a>CPU reordering</h3><p>CPU為了弭平Kernel、memory、disk之間的速度差異，使用了各種方式，三級緩存就是其中一種。這種為了加速所設計的緩存系統，有可能會帶來數據不一致的問題</p>\n<p><img src=\"/images/golang/memory-model/cpu-store-buffer.png\" alt=\"CPU store buffer\"></p>\n<ol>\n<li>先執行①跟③，Core1將A&#x3D;1寫入Core1的store buffer，Core2將B&#x3D;1寫入Core2的store buffer</li>\n<li>接著執行②、④</li>\n<li>②看了store buffer沒有發現B的值，於是從Memory讀出了0</li>\n<li>④同樣從Memory讀出了0</li>\n<li>最後輸出了00</li>\n</ol>\n<p>因此對多執行緒的程式，所有CPU都會提供”鎖”的支持，稱為<code>barrier</code>或<code>fence</code>。<br>更多內容可參考: <a href=\"https://cch123.github.io/ooo/\">https://cch123.github.io/ooo/</a></p>\n<h2 id=\"總結\"><a href=\"#總結\" class=\"headerlink\" title=\"總結\"></a>總結</h2><p>此篇文章稍微解釋了一下，在程式運行中變量是如何會有競爭關係。以及再稍為提一下程式在編譯與運行在機器上會幫我們進行優化動作所產生的問題。所以當我們在寫goroutine邏輯時需要特別小心，有使用到共用變量的話，可以使用Go官方所提供的同步方法</p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://lailin.xyz/post/go-training-week3-go-memory-model.html\">https://lailin.xyz/post/go-training-week3-go-memory-model.html</a></li>\n<li><a href=\"https://go.dev/ref/mem\">https://go.dev/ref/mem</a></li>\n<li><a href=\"https://go-zh.org/ref/mem\">https://go-zh.org/ref/mem</a></li>\n<li><a href=\"https://cch123.github.io/ooo/\">https://cch123.github.io/ooo/</a></li>\n</ul>"},{"title":"[Postgresql]Row-Level Security(RLS)","date":"2022-03-22T08:33:29.000Z","toc":true,"_content":"\n我們在一般的database對使用者的權限只能到table級別，例如某個使用者始能查詢到哪些table。PostgreSQL從9.5版本開始支援Row及別的權限控管，允許不同的使用者在同一個table上查詢到不同的數據。\n\n<!-- more -->\n\n## 如何建立RLS\n\n### table開啟RLS\n\n第一步，我們在想要設定RLS的table輸入以下指令\n\n```sql\nALTER TABLE ... ENABLE ROW LEVEL SECURITY\n```\n\n### 建立安全原則\n\n接下來，我們需要制定此RLS的安全原則來限制使用者能有什麼相關的動作\n\n```sql\nCREATE POLICY name ON table_name\n    [ AS { PERMISSIVE | RESTRICTIVE } ]\n    [ FOR { ALL | SELECT | INSERT | UPDATE | DELETE } ]\n    [ TO { role_name | PUBLIC | CURRENT_USER | SESSION_USER } [, ...] ]\n    [ USING ( using_expression ) ]\n    [ WITH CHECK ( check_expression ) ]\n```\n\n對於 create policy 中，需要注意:\n\n1. **using**針對已經存在的紀錄驗證，可以實施在select、update、delete、ALL上\n2. **with check**針對將要新增的紀錄驗證上，可以實施在insert、update、ALL上\n\n- Policies Applied by Command Type\n\n| | Command | `SELECT/ALL policy` | `INSERT/ALL policy` | `UPDATE/ALL policy` | `DELETE/ALL policy` |\n| - | - | - | - | - | - |\n| | `USING expression` | `WITH CHECK expression` | `USING expression` | `WITH CHECK expression` | `USING expression`|\n| `SELECT` | Existing row | — | — | — | — |\n| `SELECT FOR UPDATE/SHARE` | Existing row | — | Existing row | — | — |\n| `INSERT` | — | New row | — | — | — |\n| `INSERT ... RETURNING` | New row | New row | — | — | — |\n| `UPDATE` | Existing & new rows | — | Existing row | New row | — |\n| `DELETE` | Existing row | — | — | — | Existing row |\n| `ON CONFLICT DO UPDATE` | Existing & new rows | — | Existing row | New row | — |\n\n> If read access is required to the existing or new row (for example, a `WHERE` or `RETURNING` clause that refers to columns from the relation).\n\n更多內容可參閱： [Create Policy](https://docs.postgresql.tw/reference/sql-commands/create-policy)\n\n## 例子\n\n我們通過一個簡單的例子來看如何使用\n\n1. 首先建立測試的table\n\n   ```sql\n   test=# create table t1 (id int, name text);\n   CREATE TABLE\n   test=# insert into t1 values(1, 'user01');\n   INSERT 0 1\n   test=# insert into t1 values(2, 'user02');\n   INSERT 0 1\n   test=# select * from t1;\n    id |  name  \n   ----+--------\n     1 | user01\n     2 | user02\n   (2 rows)\n   ```\n\n2. 新建一個使用者\n\n   ```sql\n   test=# create user user01;\n   CREATE ROLE\n   test=# GRANT SELECT, INSERT, UPDATE, DELETE ON public.t1 TO user01;\n   GRANT\n   ```\n\n3. 開啟RLS\n\n   ```sql\n   test=# ALTER TABLE t1 ENABLE ROW LEVEL SECURITY;\n   ALTER TABLE\n   ```\n\n4. 建立安全原則: `使用者名稱`與table裡的`name`相同，才能有權限對此資料做選取動作\n\n   ```sql\n   test=# CREATE POLICY select_on_t1 ON t1 FOR select USING (current_user=name);\n   CREATE POLICY\n   test=# \\d t1\n                    Table \"public.t1\"\n    Column |  Type   | Collation | Nullable | Default \n   --------+---------+-----------+----------+---------\n    id     | integer |           |          | \n    name   | text    |           |          | \n   Policies:\n    POLICY \"select_on_t1\" FOR SELECT\n      USING ((CURRENT_USER = name))\n   ```\n\n5. 切換使用者並選取\n\n   ```sql\n   test=# \\c - user01;\n   Password for user user01: \n   You are now connected to database \"test\" as user \"user01\".\n   test=> select * from t1;\n    id |  name  \n   ----+--------\n     1 | user01\n   (1 row)\n   ```\n\n   可以看到使用者`user01`只能查看到name=user01的資料\n\n6. 測試新增\n\n   ```sql\n   test=> insert into t1 values(3, 'user01');\n   ERROR:  new row violates row-level security policy for table \"t1\"\n   ```\n\n   可以看到user01會被RLS規則擋住，這時就要新建一個新增的安全法則\n\n   ```sql\n   test=> \\c - postgres -- 切換postgres使用者\n   Password for user postgres:\n   You are now connected to database \"test\" as user \"postgres\".\n\n   test=# CREATE POLICY user_add_t1 ON t1 FOR INSERT WITH CHECK(true); -- 建立policy\n   CREATE POLICY\n\n   test=# \\c - user01 -- 切換回user01\n   Password for user user01: \n   You are now connected to database \"test\" as user \"user01\".\n\n   test=> insert into t1 values(3, 'user01'); -- 新增資料到t1\n   INSERT 0 1\n\n   test=> select * from t1; -- 可以看到剛剛的資料有新增成功\n   id |  name  \n   ----+--------\n   1 | user01\n   3 | user01\n   (2 rows)\n   ```\n  \n   > `with check`在創建insert的policy時一定要加\n\n7. 測試修改\n\n   ```sql\n   test=> update t1 set id=4 where id=3; -- 無法更新\n   UPDATE 0\n\n   test=> \\c - postgres\n   Password for user postgres: \n   You are now connected to database \"test\" as user \"postgres\".\n\n   test=# CREATE POLICY user_mod_t1 ON t1 FOR update USING(CURRENT_USER=name); -- 創建更新的安全策略\n\n   CREATE POLICY\n   \n   test=# \\c - user01\n   Password for user user01: \n   You are now connected to database \"test\" as user \"user01\".\n\n   test=> update t1 set id=4 where id=3; -- 可以更新了\n   UPDATE 1\n\n   test=> select * from t1; -- 查看資料\n    id |  name  \n   ----+--------\n     1 | user01\n     4 | user01\n   (2 rows)\n\n   test=> update t1 set id=5 where id=2; -- 無法修改user02的資料\n   UPDATE 0\n   ```\n\n## 參考資料\n\n- <https://docs.postgresql.tw/the-sql-language/ddl/row-security-policies>\n- <https://docs.postgresql.tw/reference/sql-commands/create-policy>\n- <https://foucus.blog.csdn.net/article/details/117331707>\n","source":"_posts/sql/postgresql-row-level-security.md","raw":"---\ntitle: '[Postgresql]Row-Level Security(RLS)'\ndate: 2022-03-22 16:33:29\ntags:\n  - PostgreSQL\n  - sql\ncategories: 工作\ntoc: true\n---\n\n我們在一般的database對使用者的權限只能到table級別，例如某個使用者始能查詢到哪些table。PostgreSQL從9.5版本開始支援Row及別的權限控管，允許不同的使用者在同一個table上查詢到不同的數據。\n\n<!-- more -->\n\n## 如何建立RLS\n\n### table開啟RLS\n\n第一步，我們在想要設定RLS的table輸入以下指令\n\n```sql\nALTER TABLE ... ENABLE ROW LEVEL SECURITY\n```\n\n### 建立安全原則\n\n接下來，我們需要制定此RLS的安全原則來限制使用者能有什麼相關的動作\n\n```sql\nCREATE POLICY name ON table_name\n    [ AS { PERMISSIVE | RESTRICTIVE } ]\n    [ FOR { ALL | SELECT | INSERT | UPDATE | DELETE } ]\n    [ TO { role_name | PUBLIC | CURRENT_USER | SESSION_USER } [, ...] ]\n    [ USING ( using_expression ) ]\n    [ WITH CHECK ( check_expression ) ]\n```\n\n對於 create policy 中，需要注意:\n\n1. **using**針對已經存在的紀錄驗證，可以實施在select、update、delete、ALL上\n2. **with check**針對將要新增的紀錄驗證上，可以實施在insert、update、ALL上\n\n- Policies Applied by Command Type\n\n| | Command | `SELECT/ALL policy` | `INSERT/ALL policy` | `UPDATE/ALL policy` | `DELETE/ALL policy` |\n| - | - | - | - | - | - |\n| | `USING expression` | `WITH CHECK expression` | `USING expression` | `WITH CHECK expression` | `USING expression`|\n| `SELECT` | Existing row | — | — | — | — |\n| `SELECT FOR UPDATE/SHARE` | Existing row | — | Existing row | — | — |\n| `INSERT` | — | New row | — | — | — |\n| `INSERT ... RETURNING` | New row | New row | — | — | — |\n| `UPDATE` | Existing & new rows | — | Existing row | New row | — |\n| `DELETE` | Existing row | — | — | — | Existing row |\n| `ON CONFLICT DO UPDATE` | Existing & new rows | — | Existing row | New row | — |\n\n> If read access is required to the existing or new row (for example, a `WHERE` or `RETURNING` clause that refers to columns from the relation).\n\n更多內容可參閱： [Create Policy](https://docs.postgresql.tw/reference/sql-commands/create-policy)\n\n## 例子\n\n我們通過一個簡單的例子來看如何使用\n\n1. 首先建立測試的table\n\n   ```sql\n   test=# create table t1 (id int, name text);\n   CREATE TABLE\n   test=# insert into t1 values(1, 'user01');\n   INSERT 0 1\n   test=# insert into t1 values(2, 'user02');\n   INSERT 0 1\n   test=# select * from t1;\n    id |  name  \n   ----+--------\n     1 | user01\n     2 | user02\n   (2 rows)\n   ```\n\n2. 新建一個使用者\n\n   ```sql\n   test=# create user user01;\n   CREATE ROLE\n   test=# GRANT SELECT, INSERT, UPDATE, DELETE ON public.t1 TO user01;\n   GRANT\n   ```\n\n3. 開啟RLS\n\n   ```sql\n   test=# ALTER TABLE t1 ENABLE ROW LEVEL SECURITY;\n   ALTER TABLE\n   ```\n\n4. 建立安全原則: `使用者名稱`與table裡的`name`相同，才能有權限對此資料做選取動作\n\n   ```sql\n   test=# CREATE POLICY select_on_t1 ON t1 FOR select USING (current_user=name);\n   CREATE POLICY\n   test=# \\d t1\n                    Table \"public.t1\"\n    Column |  Type   | Collation | Nullable | Default \n   --------+---------+-----------+----------+---------\n    id     | integer |           |          | \n    name   | text    |           |          | \n   Policies:\n    POLICY \"select_on_t1\" FOR SELECT\n      USING ((CURRENT_USER = name))\n   ```\n\n5. 切換使用者並選取\n\n   ```sql\n   test=# \\c - user01;\n   Password for user user01: \n   You are now connected to database \"test\" as user \"user01\".\n   test=> select * from t1;\n    id |  name  \n   ----+--------\n     1 | user01\n   (1 row)\n   ```\n\n   可以看到使用者`user01`只能查看到name=user01的資料\n\n6. 測試新增\n\n   ```sql\n   test=> insert into t1 values(3, 'user01');\n   ERROR:  new row violates row-level security policy for table \"t1\"\n   ```\n\n   可以看到user01會被RLS規則擋住，這時就要新建一個新增的安全法則\n\n   ```sql\n   test=> \\c - postgres -- 切換postgres使用者\n   Password for user postgres:\n   You are now connected to database \"test\" as user \"postgres\".\n\n   test=# CREATE POLICY user_add_t1 ON t1 FOR INSERT WITH CHECK(true); -- 建立policy\n   CREATE POLICY\n\n   test=# \\c - user01 -- 切換回user01\n   Password for user user01: \n   You are now connected to database \"test\" as user \"user01\".\n\n   test=> insert into t1 values(3, 'user01'); -- 新增資料到t1\n   INSERT 0 1\n\n   test=> select * from t1; -- 可以看到剛剛的資料有新增成功\n   id |  name  \n   ----+--------\n   1 | user01\n   3 | user01\n   (2 rows)\n   ```\n  \n   > `with check`在創建insert的policy時一定要加\n\n7. 測試修改\n\n   ```sql\n   test=> update t1 set id=4 where id=3; -- 無法更新\n   UPDATE 0\n\n   test=> \\c - postgres\n   Password for user postgres: \n   You are now connected to database \"test\" as user \"postgres\".\n\n   test=# CREATE POLICY user_mod_t1 ON t1 FOR update USING(CURRENT_USER=name); -- 創建更新的安全策略\n\n   CREATE POLICY\n   \n   test=# \\c - user01\n   Password for user user01: \n   You are now connected to database \"test\" as user \"user01\".\n\n   test=> update t1 set id=4 where id=3; -- 可以更新了\n   UPDATE 1\n\n   test=> select * from t1; -- 查看資料\n    id |  name  \n   ----+--------\n     1 | user01\n     4 | user01\n   (2 rows)\n\n   test=> update t1 set id=5 where id=2; -- 無法修改user02的資料\n   UPDATE 0\n   ```\n\n## 參考資料\n\n- <https://docs.postgresql.tw/the-sql-language/ddl/row-security-policies>\n- <https://docs.postgresql.tw/reference/sql-commands/create-policy>\n- <https://foucus.blog.csdn.net/article/details/117331707>\n","slug":"sql/postgresql-row-level-security","published":1,"updated":"2022-03-22T05:03:56.540Z","_id":"cl10gxoz20001pzze42iqgpw8","comments":1,"layout":"post","photos":[],"link":"","content":"<p>我們在一般的database對使用者的權限只能到table級別，例如某個使用者始能查詢到哪些table。PostgreSQL從9.5版本開始支援Row及別的權限控管，允許不同的使用者在同一個table上查詢到不同的數據。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"如何建立RLS\"><a href=\"#如何建立RLS\" class=\"headerlink\" title=\"如何建立RLS\"></a>如何建立RLS</h2><h3 id=\"table開啟RLS\"><a href=\"#table開啟RLS\" class=\"headerlink\" title=\"table開啟RLS\"></a>table開啟RLS</h3><p>第一步，我們在想要設定RLS的table輸入以下指令</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> ... ENABLE <span class=\"type\">ROW</span> LEVEL SECURITY</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"建立安全原則\"><a href=\"#建立安全原則\" class=\"headerlink\" title=\"建立安全原則\"></a>建立安全原則</h3><p>接下來，我們需要制定此RLS的安全原則來限制使用者能有什麼相關的動作</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> POLICY name <span class=\"keyword\">ON</span> table_name</span><br><span class=\"line\">    [ <span class=\"keyword\">AS</span> &#123; PERMISSIVE <span class=\"operator\">|</span> RESTRICTIVE &#125; ]</span><br><span class=\"line\">    [ <span class=\"keyword\">FOR</span> &#123; <span class=\"keyword\">ALL</span> <span class=\"operator\">|</span> <span class=\"keyword\">SELECT</span> <span class=\"operator\">|</span> <span class=\"keyword\">INSERT</span> <span class=\"operator\">|</span> UPDATE <span class=\"operator\">|</span> <span class=\"keyword\">DELETE</span> &#125; ]</span><br><span class=\"line\">    [ <span class=\"keyword\">TO</span> &#123; role_name <span class=\"operator\">|</span> PUBLIC <span class=\"operator\">|</span> <span class=\"built_in\">CURRENT_USER</span> <span class=\"operator\">|</span> <span class=\"built_in\">SESSION_USER</span> &#125; [, ...] ]</span><br><span class=\"line\">    [ <span class=\"keyword\">USING</span> ( using_expression ) ]</span><br><span class=\"line\">    [ <span class=\"keyword\">WITH</span> <span class=\"keyword\">CHECK</span> ( check_expression ) ]</span><br></pre></td></tr></table></figure>\n\n<p>對於 create policy 中，需要注意:</p>\n<ol>\n<li><strong>using</strong>針對已經存在的紀錄驗證，可以實施在select、update、delete、ALL上</li>\n<li><strong>with check</strong>針對將要新增的紀錄驗證上，可以實施在insert、update、ALL上</li>\n</ol>\n<ul>\n<li>Policies Applied by Command Type</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Command</th>\n<th><code>SELECT/ALL policy</code></th>\n<th><code>INSERT/ALL policy</code></th>\n<th><code>UPDATE/ALL policy</code></th>\n<th><code>DELETE/ALL policy</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td><code>USING expression</code></td>\n<td><code>WITH CHECK expression</code></td>\n<td><code>USING expression</code></td>\n<td><code>WITH CHECK expression</code></td>\n<td><code>USING expression</code></td>\n</tr>\n<tr>\n<td><code>SELECT</code></td>\n<td>Existing row</td>\n<td>—</td>\n<td>—</td>\n<td>—</td>\n<td>—</td>\n</tr>\n<tr>\n<td><code>SELECT FOR UPDATE/SHARE</code></td>\n<td>Existing row</td>\n<td>—</td>\n<td>Existing row</td>\n<td>—</td>\n<td>—</td>\n</tr>\n<tr>\n<td><code>INSERT</code></td>\n<td>—</td>\n<td>New row</td>\n<td>—</td>\n<td>—</td>\n<td>—</td>\n</tr>\n<tr>\n<td><code>INSERT ... RETURNING</code></td>\n<td>New row</td>\n<td>New row</td>\n<td>—</td>\n<td>—</td>\n<td>—</td>\n</tr>\n<tr>\n<td><code>UPDATE</code></td>\n<td>Existing &amp; new rows</td>\n<td>—</td>\n<td>Existing row</td>\n<td>New row</td>\n<td>—</td>\n</tr>\n<tr>\n<td><code>DELETE</code></td>\n<td>Existing row</td>\n<td>—</td>\n<td>—</td>\n<td>—</td>\n<td>Existing row</td>\n</tr>\n<tr>\n<td><code>ON CONFLICT DO UPDATE</code></td>\n<td>Existing &amp; new rows</td>\n<td>—</td>\n<td>Existing row</td>\n<td>New row</td>\n<td>—</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>If read access is required to the existing or new row (for example, a <code>WHERE</code> or <code>RETURNING</code> clause that refers to columns from the relation).</p>\n</blockquote>\n<p>更多內容可參閱： <a href=\"https://docs.postgresql.tw/reference/sql-commands/create-policy\">Create Policy</a></p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>我們通過一個簡單的例子來看如何使用</p>\n<ol>\n<li><p>首先建立測試的table</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test<span class=\"operator\">=</span># <span class=\"keyword\">create</span> <span class=\"keyword\">table</span> t1 (id <span class=\"type\">int</span>, name text);</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span></span><br><span class=\"line\">test<span class=\"operator\">=</span># <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> t1 <span class=\"keyword\">values</span>(<span class=\"number\">1</span>, <span class=\"string\">&#x27;user01&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"number\">0</span> <span class=\"number\">1</span></span><br><span class=\"line\">test<span class=\"operator\">=</span># <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> t1 <span class=\"keyword\">values</span>(<span class=\"number\">2</span>, <span class=\"string\">&#x27;user02&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"number\">0</span> <span class=\"number\">1</span></span><br><span class=\"line\">test<span class=\"operator\">=</span># <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> t1;</span><br><span class=\"line\"> id <span class=\"operator\">|</span>  name  </span><br><span class=\"line\"><span class=\"comment\">----+--------</span></span><br><span class=\"line\">  <span class=\"number\">1</span> <span class=\"operator\">|</span> user01</span><br><span class=\"line\">  <span class=\"number\">2</span> <span class=\"operator\">|</span> user02</span><br><span class=\"line\">(<span class=\"number\">2</span> <span class=\"keyword\">rows</span>)</span><br></pre></td></tr></table></figure></li>\n<li><p>新建一個使用者</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test<span class=\"operator\">=</span># <span class=\"keyword\">create</span> <span class=\"keyword\">user</span> user01;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> ROLE</span><br><span class=\"line\">test<span class=\"operator\">=</span># <span class=\"keyword\">GRANT</span> <span class=\"keyword\">SELECT</span>, <span class=\"keyword\">INSERT</span>, UPDATE, <span class=\"keyword\">DELETE</span> <span class=\"keyword\">ON</span> public.t1 <span class=\"keyword\">TO</span> user01;</span><br><span class=\"line\"><span class=\"keyword\">GRANT</span></span><br></pre></td></tr></table></figure></li>\n<li><p>開啟RLS</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test<span class=\"operator\">=</span># <span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> t1 ENABLE <span class=\"type\">ROW</span> LEVEL SECURITY;</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span></span><br></pre></td></tr></table></figure></li>\n<li><p>建立安全原則: <code>使用者名稱</code>與table裡的<code>name</code>相同，才能有權限對此資料做選取動作</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test<span class=\"operator\">=</span># <span class=\"keyword\">CREATE</span> POLICY select_on_t1 <span class=\"keyword\">ON</span> t1 <span class=\"keyword\">FOR</span> <span class=\"keyword\">select</span> <span class=\"keyword\">USING</span> (<span class=\"built_in\">current_user</span><span class=\"operator\">=</span>name);</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> POLICY</span><br><span class=\"line\">test<span class=\"operator\">=</span># \\d t1</span><br><span class=\"line\">                 <span class=\"keyword\">Table</span> &quot;public.t1&quot;</span><br><span class=\"line\"> <span class=\"keyword\">Column</span> <span class=\"operator\">|</span>  Type   <span class=\"operator\">|</span> <span class=\"keyword\">Collation</span> <span class=\"operator\">|</span> Nullable <span class=\"operator\">|</span> <span class=\"keyword\">Default</span> </span><br><span class=\"line\"><span class=\"comment\">--------+---------+-----------+----------+---------</span></span><br><span class=\"line\"> id     <span class=\"operator\">|</span> <span class=\"type\">integer</span> <span class=\"operator\">|</span>           <span class=\"operator\">|</span>          <span class=\"operator\">|</span> </span><br><span class=\"line\"> name   <span class=\"operator\">|</span> text    <span class=\"operator\">|</span>           <span class=\"operator\">|</span>          <span class=\"operator\">|</span> </span><br><span class=\"line\">Policies:</span><br><span class=\"line\"> POLICY &quot;select_on_t1&quot; <span class=\"keyword\">FOR</span> <span class=\"keyword\">SELECT</span></span><br><span class=\"line\">   <span class=\"keyword\">USING</span> ((<span class=\"built_in\">CURRENT_USER</span> <span class=\"operator\">=</span> name))</span><br></pre></td></tr></table></figure></li>\n<li><p>切換使用者並選取</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test<span class=\"operator\">=</span># \\c <span class=\"operator\">-</span> user01;</span><br><span class=\"line\">Password <span class=\"keyword\">for</span> <span class=\"keyword\">user</span> user01: </span><br><span class=\"line\">You <span class=\"keyword\">are</span> now connected <span class=\"keyword\">to</span> database &quot;test&quot; <span class=\"keyword\">as</span> <span class=\"keyword\">user</span> &quot;user01&quot;.</span><br><span class=\"line\">test<span class=\"operator\">=</span><span class=\"operator\">&gt;</span> <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> t1;</span><br><span class=\"line\"> id <span class=\"operator\">|</span>  name  </span><br><span class=\"line\"><span class=\"comment\">----+--------</span></span><br><span class=\"line\">  <span class=\"number\">1</span> <span class=\"operator\">|</span> user01</span><br><span class=\"line\">(<span class=\"number\">1</span> <span class=\"type\">row</span>)</span><br></pre></td></tr></table></figure>\n\n<p>可以看到使用者<code>user01</code>只能查看到name=user01的資料</p>\n</li>\n<li><p>測試新增</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test<span class=\"operator\">=</span><span class=\"operator\">&gt;</span> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> t1 <span class=\"keyword\">values</span>(<span class=\"number\">3</span>, <span class=\"string\">&#x27;user01&#x27;</span>);</span><br><span class=\"line\">ERROR:  <span class=\"keyword\">new</span> <span class=\"type\">row</span> violates <span class=\"type\">row</span><span class=\"operator\">-</span>level security policy <span class=\"keyword\">for</span> <span class=\"keyword\">table</span> &quot;t1&quot;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到user01會被RLS規則擋住，這時就要新建一個新增的安全法則</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test<span class=\"operator\">=</span><span class=\"operator\">&gt;</span> \\c <span class=\"operator\">-</span> postgres <span class=\"comment\">-- 切換postgres使用者</span></span><br><span class=\"line\">Password <span class=\"keyword\">for</span> <span class=\"keyword\">user</span> postgres:</span><br><span class=\"line\">You <span class=\"keyword\">are</span> now connected <span class=\"keyword\">to</span> database &quot;test&quot; <span class=\"keyword\">as</span> <span class=\"keyword\">user</span> &quot;postgres&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">test<span class=\"operator\">=</span># <span class=\"keyword\">CREATE</span> POLICY user_add_t1 <span class=\"keyword\">ON</span> t1 <span class=\"keyword\">FOR</span> <span class=\"keyword\">INSERT</span> <span class=\"keyword\">WITH</span> <span class=\"keyword\">CHECK</span>(<span class=\"literal\">true</span>); <span class=\"comment\">-- 建立policy</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> POLICY</span><br><span class=\"line\"></span><br><span class=\"line\">test<span class=\"operator\">=</span># \\c <span class=\"operator\">-</span> user01 <span class=\"comment\">-- 切換回user01</span></span><br><span class=\"line\">Password <span class=\"keyword\">for</span> <span class=\"keyword\">user</span> user01: </span><br><span class=\"line\">You <span class=\"keyword\">are</span> now connected <span class=\"keyword\">to</span> database &quot;test&quot; <span class=\"keyword\">as</span> <span class=\"keyword\">user</span> &quot;user01&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">test<span class=\"operator\">=</span><span class=\"operator\">&gt;</span> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> t1 <span class=\"keyword\">values</span>(<span class=\"number\">3</span>, <span class=\"string\">&#x27;user01&#x27;</span>); <span class=\"comment\">-- 新增資料到t1</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"number\">0</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">test<span class=\"operator\">=</span><span class=\"operator\">&gt;</span> <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> t1; <span class=\"comment\">-- 可以看到剛剛的資料有新增成功</span></span><br><span class=\"line\">id <span class=\"operator\">|</span>  name  </span><br><span class=\"line\"><span class=\"comment\">----+--------</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"operator\">|</span> user01</span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"operator\">|</span> user01</span><br><span class=\"line\">(<span class=\"number\">2</span> <span class=\"keyword\">rows</span>)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>with check</code>在創建insert的policy時一定要加</p>\n</blockquote>\n</li>\n<li><p>測試修改</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test<span class=\"operator\">=</span><span class=\"operator\">&gt;</span> update t1 <span class=\"keyword\">set</span> id<span class=\"operator\">=</span><span class=\"number\">4</span> <span class=\"keyword\">where</span> id<span class=\"operator\">=</span><span class=\"number\">3</span>; <span class=\"comment\">-- 無法更新</span></span><br><span class=\"line\">UPDATE <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">test<span class=\"operator\">=</span><span class=\"operator\">&gt;</span> \\c <span class=\"operator\">-</span> postgres</span><br><span class=\"line\">Password <span class=\"keyword\">for</span> <span class=\"keyword\">user</span> postgres: </span><br><span class=\"line\">You <span class=\"keyword\">are</span> now connected <span class=\"keyword\">to</span> database &quot;test&quot; <span class=\"keyword\">as</span> <span class=\"keyword\">user</span> &quot;postgres&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">test<span class=\"operator\">=</span># <span class=\"keyword\">CREATE</span> POLICY user_mod_t1 <span class=\"keyword\">ON</span> t1 <span class=\"keyword\">FOR</span> update <span class=\"keyword\">USING</span>(<span class=\"built_in\">CURRENT_USER</span><span class=\"operator\">=</span>name); <span class=\"comment\">-- 創建更新的安全策略</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> POLICY</span><br><span class=\"line\"></span><br><span class=\"line\">test<span class=\"operator\">=</span># \\c <span class=\"operator\">-</span> user01</span><br><span class=\"line\">Password <span class=\"keyword\">for</span> <span class=\"keyword\">user</span> user01: </span><br><span class=\"line\">You <span class=\"keyword\">are</span> now connected <span class=\"keyword\">to</span> database &quot;test&quot; <span class=\"keyword\">as</span> <span class=\"keyword\">user</span> &quot;user01&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">test<span class=\"operator\">=</span><span class=\"operator\">&gt;</span> update t1 <span class=\"keyword\">set</span> id<span class=\"operator\">=</span><span class=\"number\">4</span> <span class=\"keyword\">where</span> id<span class=\"operator\">=</span><span class=\"number\">3</span>; <span class=\"comment\">-- 可以更新了</span></span><br><span class=\"line\">UPDATE <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">test<span class=\"operator\">=</span><span class=\"operator\">&gt;</span> <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> t1; <span class=\"comment\">-- 查看資料</span></span><br><span class=\"line\"> id <span class=\"operator\">|</span>  name  </span><br><span class=\"line\"><span class=\"comment\">----+--------</span></span><br><span class=\"line\">  <span class=\"number\">1</span> <span class=\"operator\">|</span> user01</span><br><span class=\"line\">  <span class=\"number\">4</span> <span class=\"operator\">|</span> user01</span><br><span class=\"line\">(<span class=\"number\">2</span> <span class=\"keyword\">rows</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">test<span class=\"operator\">=</span><span class=\"operator\">&gt;</span> update t1 <span class=\"keyword\">set</span> id<span class=\"operator\">=</span><span class=\"number\">5</span> <span class=\"keyword\">where</span> id<span class=\"operator\">=</span><span class=\"number\">2</span>; <span class=\"comment\">-- 無法修改user02的資料</span></span><br><span class=\"line\">UPDATE <span class=\"number\">0</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://docs.postgresql.tw/the-sql-language/ddl/row-security-policies\">https://docs.postgresql.tw/the-sql-language/ddl/row-security-policies</a></li>\n<li><a href=\"https://docs.postgresql.tw/reference/sql-commands/create-policy\">https://docs.postgresql.tw/reference/sql-commands/create-policy</a></li>\n<li><a href=\"https://foucus.blog.csdn.net/article/details/117331707\">https://foucus.blog.csdn.net/article/details/117331707</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>我們在一般的database對使用者的權限只能到table級別，例如某個使用者始能查詢到哪些table。PostgreSQL從9.5版本開始支援Row及別的權限控管，允許不同的使用者在同一個table上查詢到不同的數據。</p>","more":"<h2 id=\"如何建立RLS\"><a href=\"#如何建立RLS\" class=\"headerlink\" title=\"如何建立RLS\"></a>如何建立RLS</h2><h3 id=\"table開啟RLS\"><a href=\"#table開啟RLS\" class=\"headerlink\" title=\"table開啟RLS\"></a>table開啟RLS</h3><p>第一步，我們在想要設定RLS的table輸入以下指令</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> ... ENABLE <span class=\"type\">ROW</span> LEVEL SECURITY</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"建立安全原則\"><a href=\"#建立安全原則\" class=\"headerlink\" title=\"建立安全原則\"></a>建立安全原則</h3><p>接下來，我們需要制定此RLS的安全原則來限制使用者能有什麼相關的動作</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> POLICY name <span class=\"keyword\">ON</span> table_name</span><br><span class=\"line\">    [ <span class=\"keyword\">AS</span> &#123; PERMISSIVE <span class=\"operator\">|</span> RESTRICTIVE &#125; ]</span><br><span class=\"line\">    [ <span class=\"keyword\">FOR</span> &#123; <span class=\"keyword\">ALL</span> <span class=\"operator\">|</span> <span class=\"keyword\">SELECT</span> <span class=\"operator\">|</span> <span class=\"keyword\">INSERT</span> <span class=\"operator\">|</span> UPDATE <span class=\"operator\">|</span> <span class=\"keyword\">DELETE</span> &#125; ]</span><br><span class=\"line\">    [ <span class=\"keyword\">TO</span> &#123; role_name <span class=\"operator\">|</span> PUBLIC <span class=\"operator\">|</span> <span class=\"built_in\">CURRENT_USER</span> <span class=\"operator\">|</span> <span class=\"built_in\">SESSION_USER</span> &#125; [, ...] ]</span><br><span class=\"line\">    [ <span class=\"keyword\">USING</span> ( using_expression ) ]</span><br><span class=\"line\">    [ <span class=\"keyword\">WITH</span> <span class=\"keyword\">CHECK</span> ( check_expression ) ]</span><br></pre></td></tr></table></figure>\n\n<p>對於 create policy 中，需要注意:</p>\n<ol>\n<li><strong>using</strong>針對已經存在的紀錄驗證，可以實施在select、update、delete、ALL上</li>\n<li><strong>with check</strong>針對將要新增的紀錄驗證上，可以實施在insert、update、ALL上</li>\n</ol>\n<ul>\n<li>Policies Applied by Command Type</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Command</th>\n<th><code>SELECT/ALL policy</code></th>\n<th><code>INSERT/ALL policy</code></th>\n<th><code>UPDATE/ALL policy</code></th>\n<th><code>DELETE/ALL policy</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td><code>USING expression</code></td>\n<td><code>WITH CHECK expression</code></td>\n<td><code>USING expression</code></td>\n<td><code>WITH CHECK expression</code></td>\n<td><code>USING expression</code></td>\n</tr>\n<tr>\n<td><code>SELECT</code></td>\n<td>Existing row</td>\n<td>—</td>\n<td>—</td>\n<td>—</td>\n<td>—</td>\n</tr>\n<tr>\n<td><code>SELECT FOR UPDATE/SHARE</code></td>\n<td>Existing row</td>\n<td>—</td>\n<td>Existing row</td>\n<td>—</td>\n<td>—</td>\n</tr>\n<tr>\n<td><code>INSERT</code></td>\n<td>—</td>\n<td>New row</td>\n<td>—</td>\n<td>—</td>\n<td>—</td>\n</tr>\n<tr>\n<td><code>INSERT ... RETURNING</code></td>\n<td>New row</td>\n<td>New row</td>\n<td>—</td>\n<td>—</td>\n<td>—</td>\n</tr>\n<tr>\n<td><code>UPDATE</code></td>\n<td>Existing &amp; new rows</td>\n<td>—</td>\n<td>Existing row</td>\n<td>New row</td>\n<td>—</td>\n</tr>\n<tr>\n<td><code>DELETE</code></td>\n<td>Existing row</td>\n<td>—</td>\n<td>—</td>\n<td>—</td>\n<td>Existing row</td>\n</tr>\n<tr>\n<td><code>ON CONFLICT DO UPDATE</code></td>\n<td>Existing &amp; new rows</td>\n<td>—</td>\n<td>Existing row</td>\n<td>New row</td>\n<td>—</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>If read access is required to the existing or new row (for example, a <code>WHERE</code> or <code>RETURNING</code> clause that refers to columns from the relation).</p>\n</blockquote>\n<p>更多內容可參閱： <a href=\"https://docs.postgresql.tw/reference/sql-commands/create-policy\">Create Policy</a></p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>我們通過一個簡單的例子來看如何使用</p>\n<ol>\n<li><p>首先建立測試的table</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test<span class=\"operator\">=</span># <span class=\"keyword\">create</span> <span class=\"keyword\">table</span> t1 (id <span class=\"type\">int</span>, name text);</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span></span><br><span class=\"line\">test<span class=\"operator\">=</span># <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> t1 <span class=\"keyword\">values</span>(<span class=\"number\">1</span>, <span class=\"string\">&#x27;user01&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"number\">0</span> <span class=\"number\">1</span></span><br><span class=\"line\">test<span class=\"operator\">=</span># <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> t1 <span class=\"keyword\">values</span>(<span class=\"number\">2</span>, <span class=\"string\">&#x27;user02&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"number\">0</span> <span class=\"number\">1</span></span><br><span class=\"line\">test<span class=\"operator\">=</span># <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> t1;</span><br><span class=\"line\"> id <span class=\"operator\">|</span>  name  </span><br><span class=\"line\"><span class=\"comment\">----+--------</span></span><br><span class=\"line\">  <span class=\"number\">1</span> <span class=\"operator\">|</span> user01</span><br><span class=\"line\">  <span class=\"number\">2</span> <span class=\"operator\">|</span> user02</span><br><span class=\"line\">(<span class=\"number\">2</span> <span class=\"keyword\">rows</span>)</span><br></pre></td></tr></table></figure></li>\n<li><p>新建一個使用者</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test<span class=\"operator\">=</span># <span class=\"keyword\">create</span> <span class=\"keyword\">user</span> user01;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> ROLE</span><br><span class=\"line\">test<span class=\"operator\">=</span># <span class=\"keyword\">GRANT</span> <span class=\"keyword\">SELECT</span>, <span class=\"keyword\">INSERT</span>, UPDATE, <span class=\"keyword\">DELETE</span> <span class=\"keyword\">ON</span> public.t1 <span class=\"keyword\">TO</span> user01;</span><br><span class=\"line\"><span class=\"keyword\">GRANT</span></span><br></pre></td></tr></table></figure></li>\n<li><p>開啟RLS</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test<span class=\"operator\">=</span># <span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> t1 ENABLE <span class=\"type\">ROW</span> LEVEL SECURITY;</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span></span><br></pre></td></tr></table></figure></li>\n<li><p>建立安全原則: <code>使用者名稱</code>與table裡的<code>name</code>相同，才能有權限對此資料做選取動作</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test<span class=\"operator\">=</span># <span class=\"keyword\">CREATE</span> POLICY select_on_t1 <span class=\"keyword\">ON</span> t1 <span class=\"keyword\">FOR</span> <span class=\"keyword\">select</span> <span class=\"keyword\">USING</span> (<span class=\"built_in\">current_user</span><span class=\"operator\">=</span>name);</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> POLICY</span><br><span class=\"line\">test<span class=\"operator\">=</span># \\d t1</span><br><span class=\"line\">                 <span class=\"keyword\">Table</span> &quot;public.t1&quot;</span><br><span class=\"line\"> <span class=\"keyword\">Column</span> <span class=\"operator\">|</span>  Type   <span class=\"operator\">|</span> <span class=\"keyword\">Collation</span> <span class=\"operator\">|</span> Nullable <span class=\"operator\">|</span> <span class=\"keyword\">Default</span> </span><br><span class=\"line\"><span class=\"comment\">--------+---------+-----------+----------+---------</span></span><br><span class=\"line\"> id     <span class=\"operator\">|</span> <span class=\"type\">integer</span> <span class=\"operator\">|</span>           <span class=\"operator\">|</span>          <span class=\"operator\">|</span> </span><br><span class=\"line\"> name   <span class=\"operator\">|</span> text    <span class=\"operator\">|</span>           <span class=\"operator\">|</span>          <span class=\"operator\">|</span> </span><br><span class=\"line\">Policies:</span><br><span class=\"line\"> POLICY &quot;select_on_t1&quot; <span class=\"keyword\">FOR</span> <span class=\"keyword\">SELECT</span></span><br><span class=\"line\">   <span class=\"keyword\">USING</span> ((<span class=\"built_in\">CURRENT_USER</span> <span class=\"operator\">=</span> name))</span><br></pre></td></tr></table></figure></li>\n<li><p>切換使用者並選取</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test<span class=\"operator\">=</span># \\c <span class=\"operator\">-</span> user01;</span><br><span class=\"line\">Password <span class=\"keyword\">for</span> <span class=\"keyword\">user</span> user01: </span><br><span class=\"line\">You <span class=\"keyword\">are</span> now connected <span class=\"keyword\">to</span> database &quot;test&quot; <span class=\"keyword\">as</span> <span class=\"keyword\">user</span> &quot;user01&quot;.</span><br><span class=\"line\">test<span class=\"operator\">=</span><span class=\"operator\">&gt;</span> <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> t1;</span><br><span class=\"line\"> id <span class=\"operator\">|</span>  name  </span><br><span class=\"line\"><span class=\"comment\">----+--------</span></span><br><span class=\"line\">  <span class=\"number\">1</span> <span class=\"operator\">|</span> user01</span><br><span class=\"line\">(<span class=\"number\">1</span> <span class=\"type\">row</span>)</span><br></pre></td></tr></table></figure>\n\n<p>可以看到使用者<code>user01</code>只能查看到name=user01的資料</p>\n</li>\n<li><p>測試新增</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test<span class=\"operator\">=</span><span class=\"operator\">&gt;</span> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> t1 <span class=\"keyword\">values</span>(<span class=\"number\">3</span>, <span class=\"string\">&#x27;user01&#x27;</span>);</span><br><span class=\"line\">ERROR:  <span class=\"keyword\">new</span> <span class=\"type\">row</span> violates <span class=\"type\">row</span><span class=\"operator\">-</span>level security policy <span class=\"keyword\">for</span> <span class=\"keyword\">table</span> &quot;t1&quot;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到user01會被RLS規則擋住，這時就要新建一個新增的安全法則</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test<span class=\"operator\">=</span><span class=\"operator\">&gt;</span> \\c <span class=\"operator\">-</span> postgres <span class=\"comment\">-- 切換postgres使用者</span></span><br><span class=\"line\">Password <span class=\"keyword\">for</span> <span class=\"keyword\">user</span> postgres:</span><br><span class=\"line\">You <span class=\"keyword\">are</span> now connected <span class=\"keyword\">to</span> database &quot;test&quot; <span class=\"keyword\">as</span> <span class=\"keyword\">user</span> &quot;postgres&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">test<span class=\"operator\">=</span># <span class=\"keyword\">CREATE</span> POLICY user_add_t1 <span class=\"keyword\">ON</span> t1 <span class=\"keyword\">FOR</span> <span class=\"keyword\">INSERT</span> <span class=\"keyword\">WITH</span> <span class=\"keyword\">CHECK</span>(<span class=\"literal\">true</span>); <span class=\"comment\">-- 建立policy</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> POLICY</span><br><span class=\"line\"></span><br><span class=\"line\">test<span class=\"operator\">=</span># \\c <span class=\"operator\">-</span> user01 <span class=\"comment\">-- 切換回user01</span></span><br><span class=\"line\">Password <span class=\"keyword\">for</span> <span class=\"keyword\">user</span> user01: </span><br><span class=\"line\">You <span class=\"keyword\">are</span> now connected <span class=\"keyword\">to</span> database &quot;test&quot; <span class=\"keyword\">as</span> <span class=\"keyword\">user</span> &quot;user01&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">test<span class=\"operator\">=</span><span class=\"operator\">&gt;</span> <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> t1 <span class=\"keyword\">values</span>(<span class=\"number\">3</span>, <span class=\"string\">&#x27;user01&#x27;</span>); <span class=\"comment\">-- 新增資料到t1</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"number\">0</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">test<span class=\"operator\">=</span><span class=\"operator\">&gt;</span> <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> t1; <span class=\"comment\">-- 可以看到剛剛的資料有新增成功</span></span><br><span class=\"line\">id <span class=\"operator\">|</span>  name  </span><br><span class=\"line\"><span class=\"comment\">----+--------</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"operator\">|</span> user01</span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"operator\">|</span> user01</span><br><span class=\"line\">(<span class=\"number\">2</span> <span class=\"keyword\">rows</span>)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>with check</code>在創建insert的policy時一定要加</p>\n</blockquote>\n</li>\n<li><p>測試修改</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test<span class=\"operator\">=</span><span class=\"operator\">&gt;</span> update t1 <span class=\"keyword\">set</span> id<span class=\"operator\">=</span><span class=\"number\">4</span> <span class=\"keyword\">where</span> id<span class=\"operator\">=</span><span class=\"number\">3</span>; <span class=\"comment\">-- 無法更新</span></span><br><span class=\"line\">UPDATE <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">test<span class=\"operator\">=</span><span class=\"operator\">&gt;</span> \\c <span class=\"operator\">-</span> postgres</span><br><span class=\"line\">Password <span class=\"keyword\">for</span> <span class=\"keyword\">user</span> postgres: </span><br><span class=\"line\">You <span class=\"keyword\">are</span> now connected <span class=\"keyword\">to</span> database &quot;test&quot; <span class=\"keyword\">as</span> <span class=\"keyword\">user</span> &quot;postgres&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">test<span class=\"operator\">=</span># <span class=\"keyword\">CREATE</span> POLICY user_mod_t1 <span class=\"keyword\">ON</span> t1 <span class=\"keyword\">FOR</span> update <span class=\"keyword\">USING</span>(<span class=\"built_in\">CURRENT_USER</span><span class=\"operator\">=</span>name); <span class=\"comment\">-- 創建更新的安全策略</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> POLICY</span><br><span class=\"line\"></span><br><span class=\"line\">test<span class=\"operator\">=</span># \\c <span class=\"operator\">-</span> user01</span><br><span class=\"line\">Password <span class=\"keyword\">for</span> <span class=\"keyword\">user</span> user01: </span><br><span class=\"line\">You <span class=\"keyword\">are</span> now connected <span class=\"keyword\">to</span> database &quot;test&quot; <span class=\"keyword\">as</span> <span class=\"keyword\">user</span> &quot;user01&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">test<span class=\"operator\">=</span><span class=\"operator\">&gt;</span> update t1 <span class=\"keyword\">set</span> id<span class=\"operator\">=</span><span class=\"number\">4</span> <span class=\"keyword\">where</span> id<span class=\"operator\">=</span><span class=\"number\">3</span>; <span class=\"comment\">-- 可以更新了</span></span><br><span class=\"line\">UPDATE <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">test<span class=\"operator\">=</span><span class=\"operator\">&gt;</span> <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> t1; <span class=\"comment\">-- 查看資料</span></span><br><span class=\"line\"> id <span class=\"operator\">|</span>  name  </span><br><span class=\"line\"><span class=\"comment\">----+--------</span></span><br><span class=\"line\">  <span class=\"number\">1</span> <span class=\"operator\">|</span> user01</span><br><span class=\"line\">  <span class=\"number\">4</span> <span class=\"operator\">|</span> user01</span><br><span class=\"line\">(<span class=\"number\">2</span> <span class=\"keyword\">rows</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">test<span class=\"operator\">=</span><span class=\"operator\">&gt;</span> update t1 <span class=\"keyword\">set</span> id<span class=\"operator\">=</span><span class=\"number\">5</span> <span class=\"keyword\">where</span> id<span class=\"operator\">=</span><span class=\"number\">2</span>; <span class=\"comment\">-- 無法修改user02的資料</span></span><br><span class=\"line\">UPDATE <span class=\"number\">0</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://docs.postgresql.tw/the-sql-language/ddl/row-security-policies\">https://docs.postgresql.tw/the-sql-language/ddl/row-security-policies</a></li>\n<li><a href=\"https://docs.postgresql.tw/reference/sql-commands/create-policy\">https://docs.postgresql.tw/reference/sql-commands/create-policy</a></li>\n<li><a href=\"https://foucus.blog.csdn.net/article/details/117331707\">https://foucus.blog.csdn.net/article/details/117331707</a></li>\n</ul>"},{"title":"[Java] 併發程式核心問題","date":"2022-08-30T05:27:01.000Z","toc":true,"_content":"\n併發程式的三個核心問題: 分工、同步和互斥\n\n<!-- more -->\n\n## 分工\n\n> 所謂的分工，類似於現實生活中一個組織完成一個項目，項目經理要拆分任務，安排合適的成員去完成。\n\n在併發程式的領域，你就是項目經理，Thread就是項目成員。任務的分解和分工對於項目成敗非常關鍵，不過在併發領域裡，分工更為重要，他直接決定了併發程式的性能。\n\n`java.util.concurrent` package裡的**Exuecutor、Fork/Join、Future**本質上是一種分工方法。\n\n併發程式領域還總結一些設計模式，基本上都是和分工方法相關的，例如**生產者-消費者、Thread Pre-Message、Worker Thread**等模型都是用來指導如何分工。\n\n## 同步\n\n> 在併發程式領域中的同步，主要指的就Thread之間的協作。本質上和現實生活中的協作相同，就是**一個Thread執行完了一個任務，如何通知執行後續任務的Thread開工而已**。\n\n分工好之後，就是具體執行了。在項目的執行中，任務之間會有依賴，一個任務結束後，依賴它的後續任務就可以開工，後續任務怎麼知道可以開工了？這個就是靠溝通協作了。\n\n協作一般與分工相關。`java.util.concurrent` package裡的**Exuecutor、Fork/Join、Future**本質上都是分工方法，但同時也能解決Thread協作的問題。\n\n> 例如，用Future可以發起一個異步調用，當Main Thread通過get()方法取結果時，Main Thread就會進行等待，等到異步執行的結果返回時，get()方法就會自動返回了。\n\nMain Thread與異步Thread之間的協作，Future Class已經幫我們解決了。如此之外，`java.util.concurrent` package裡提供的**CountDownLatch、CyclicBarrier、Phaser、Exchanger**也都是用來解決Thread協作的問題。\n\n工作中遇到的Thread協作問題，很多時候都是需要程式員自己來處理Thread之間的協作。基本上都可以簡單敘述成這樣的問題: **當某個條件不滿足時，Thread需要等待。當某個條件滿足時，Thread需要被喚醒執行**。\n\n> 例如，在生產者-消費者模型(Producer-Consumers pattern)裡。\n> 當queue滿時，Producer Thread等待，當queue不滿時，Producer Thread需要被喚醒執行。\n> 當queue為空時，Consumer Thread等待，當queue不為空時，Consumer Thread需要被喚醒執行。\n\n### Monitor\n\n在Java併發領域中，解決協作問題的核心技術是[Monitor](https://zh.wikipedia.org/zh-tw/%E7%9B%A3%E8%A6%96%E5%99%A8_(%E7%A8%8B%E5%BA%8F%E5%90%8C%E6%AD%A5%E5%8C%96))，上面提到的所有Thread協作技術底層都是利用Monitor解決的。\n\nMonitor是一種解決併發問題的通用模型，除了能解決Thread協作問題，還能解決下面要介紹的`互斥`問題。可以這麼說，**Monitor是解決併發問題的萬能鑰匙**。\n\n這部份的關鍵是理解Monitor模型，學好它就可以解決所有問題。其次是了解`java.util.concurrent` package裡提供的Thread協作的class應用場景。\n\n## 互斥\n\n> 所謂互斥，指的是同一時間，只允許一個Thread訪問共享變量。\n\n分工、同步主要強調的是性能，但在併發程式中還有一部份是關於正確性，用專業術語叫**Thread safe**。當併發程式裡，多個Thread同時訪問同一個共享變數時，結果是不一定的：意味著可能正確，也可能錯誤。\n\n導致這種不確定的主要源頭是**可見性、有序性和原子性問題**。為了解決這些問題，Java引入了`Memory Model`。Java Memory Model提供了一系列的規則。利用這些規則可以避免可見性、有序性問題，但是還是不能完全解決Thread safe問題。確保Thread safe的最佳方案還是**互斥**。\n\n實現互斥的核心技術就是`lock`，Java提供的synchronized以及SDK提供的各種Lock都能解決互斥問題。lock解決了安全性問題，但也帶來了性能問題，那如何保證安全性的同時又盡量提高性能呢？\n\n可以依照使用場景優化，Java SDK裡提供的ReadWriteLock、StampedLockdk可以優化`讀多寫少`場景下的lock的性能。還可以使用無鎖的數據結構，例如Java SDK提供的`Atomic class`都是基於無鎖技術實現的。\n\n除此之外，還有一些其他的方案，原理是`不共享变量`或者`變數只允許讀`。這方面，Java提供了Thread Local和final關鍵字，還有一種Copy-on-write的模式。\n\n> 使用lock除了要注意性能問題之外，還需要注意`dead lock`問題。\n\n## 結語\n\n以上簡單的介紹併發程式中會遇到的問題，以及稍微提到Java SDK裡提供的工具能解決什麼樣的問題與何種應用場景方便使用。\n\n之後會有更加詳細的介紹各項工具與併發問題。\n\n## 參考資料\n\n- <https://time.geekbang.org/column/159>\n- <https://zh.wikipedia.org/zh-tw/%E7%9B%A3%E8%A6%96%E5%99%A8_(%E7%A8%8B%E5%BA%8F%E5%90%8C%E6%AD%A5%E5%8C%96)>\n","source":"_posts/java/thread-core-question.md","raw":"---\ntitle: '[Java] 併發程式核心問題'\ndate: 2022-08-30 13:27:01\ntags: \n  - java \n  - Thread\ncategories: 學習\ntoc: true\n---\n\n併發程式的三個核心問題: 分工、同步和互斥\n\n<!-- more -->\n\n## 分工\n\n> 所謂的分工，類似於現實生活中一個組織完成一個項目，項目經理要拆分任務，安排合適的成員去完成。\n\n在併發程式的領域，你就是項目經理，Thread就是項目成員。任務的分解和分工對於項目成敗非常關鍵，不過在併發領域裡，分工更為重要，他直接決定了併發程式的性能。\n\n`java.util.concurrent` package裡的**Exuecutor、Fork/Join、Future**本質上是一種分工方法。\n\n併發程式領域還總結一些設計模式，基本上都是和分工方法相關的，例如**生產者-消費者、Thread Pre-Message、Worker Thread**等模型都是用來指導如何分工。\n\n## 同步\n\n> 在併發程式領域中的同步，主要指的就Thread之間的協作。本質上和現實生活中的協作相同，就是**一個Thread執行完了一個任務，如何通知執行後續任務的Thread開工而已**。\n\n分工好之後，就是具體執行了。在項目的執行中，任務之間會有依賴，一個任務結束後，依賴它的後續任務就可以開工，後續任務怎麼知道可以開工了？這個就是靠溝通協作了。\n\n協作一般與分工相關。`java.util.concurrent` package裡的**Exuecutor、Fork/Join、Future**本質上都是分工方法，但同時也能解決Thread協作的問題。\n\n> 例如，用Future可以發起一個異步調用，當Main Thread通過get()方法取結果時，Main Thread就會進行等待，等到異步執行的結果返回時，get()方法就會自動返回了。\n\nMain Thread與異步Thread之間的協作，Future Class已經幫我們解決了。如此之外，`java.util.concurrent` package裡提供的**CountDownLatch、CyclicBarrier、Phaser、Exchanger**也都是用來解決Thread協作的問題。\n\n工作中遇到的Thread協作問題，很多時候都是需要程式員自己來處理Thread之間的協作。基本上都可以簡單敘述成這樣的問題: **當某個條件不滿足時，Thread需要等待。當某個條件滿足時，Thread需要被喚醒執行**。\n\n> 例如，在生產者-消費者模型(Producer-Consumers pattern)裡。\n> 當queue滿時，Producer Thread等待，當queue不滿時，Producer Thread需要被喚醒執行。\n> 當queue為空時，Consumer Thread等待，當queue不為空時，Consumer Thread需要被喚醒執行。\n\n### Monitor\n\n在Java併發領域中，解決協作問題的核心技術是[Monitor](https://zh.wikipedia.org/zh-tw/%E7%9B%A3%E8%A6%96%E5%99%A8_(%E7%A8%8B%E5%BA%8F%E5%90%8C%E6%AD%A5%E5%8C%96))，上面提到的所有Thread協作技術底層都是利用Monitor解決的。\n\nMonitor是一種解決併發問題的通用模型，除了能解決Thread協作問題，還能解決下面要介紹的`互斥`問題。可以這麼說，**Monitor是解決併發問題的萬能鑰匙**。\n\n這部份的關鍵是理解Monitor模型，學好它就可以解決所有問題。其次是了解`java.util.concurrent` package裡提供的Thread協作的class應用場景。\n\n## 互斥\n\n> 所謂互斥，指的是同一時間，只允許一個Thread訪問共享變量。\n\n分工、同步主要強調的是性能，但在併發程式中還有一部份是關於正確性，用專業術語叫**Thread safe**。當併發程式裡，多個Thread同時訪問同一個共享變數時，結果是不一定的：意味著可能正確，也可能錯誤。\n\n導致這種不確定的主要源頭是**可見性、有序性和原子性問題**。為了解決這些問題，Java引入了`Memory Model`。Java Memory Model提供了一系列的規則。利用這些規則可以避免可見性、有序性問題，但是還是不能完全解決Thread safe問題。確保Thread safe的最佳方案還是**互斥**。\n\n實現互斥的核心技術就是`lock`，Java提供的synchronized以及SDK提供的各種Lock都能解決互斥問題。lock解決了安全性問題，但也帶來了性能問題，那如何保證安全性的同時又盡量提高性能呢？\n\n可以依照使用場景優化，Java SDK裡提供的ReadWriteLock、StampedLockdk可以優化`讀多寫少`場景下的lock的性能。還可以使用無鎖的數據結構，例如Java SDK提供的`Atomic class`都是基於無鎖技術實現的。\n\n除此之外，還有一些其他的方案，原理是`不共享变量`或者`變數只允許讀`。這方面，Java提供了Thread Local和final關鍵字，還有一種Copy-on-write的模式。\n\n> 使用lock除了要注意性能問題之外，還需要注意`dead lock`問題。\n\n## 結語\n\n以上簡單的介紹併發程式中會遇到的問題，以及稍微提到Java SDK裡提供的工具能解決什麼樣的問題與何種應用場景方便使用。\n\n之後會有更加詳細的介紹各項工具與併發問題。\n\n## 參考資料\n\n- <https://time.geekbang.org/column/159>\n- <https://zh.wikipedia.org/zh-tw/%E7%9B%A3%E8%A6%96%E5%99%A8_(%E7%A8%8B%E5%BA%8F%E5%90%8C%E6%AD%A5%E5%8C%96)>\n","slug":"java/thread-core-question","published":1,"updated":"2022-09-04T16:22:23.814Z","_id":"cl7fz5o3200008szegp1473g5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>併發程式的三個核心問題: 分工、同步和互斥</p>\n<span id=\"more\"></span>\n\n<h2 id=\"分工\"><a href=\"#分工\" class=\"headerlink\" title=\"分工\"></a>分工</h2><blockquote>\n<p>所謂的分工，類似於現實生活中一個組織完成一個項目，項目經理要拆分任務，安排合適的成員去完成。</p>\n</blockquote>\n<p>在併發程式的領域，你就是項目經理，Thread就是項目成員。任務的分解和分工對於項目成敗非常關鍵，不過在併發領域裡，分工更為重要，他直接決定了併發程式的性能。</p>\n<p><code>java.util.concurrent</code> package裡的<strong>Exuecutor、Fork&#x2F;Join、Future</strong>本質上是一種分工方法。</p>\n<p>併發程式領域還總結一些設計模式，基本上都是和分工方法相關的，例如<strong>生產者-消費者、Thread Pre-Message、Worker Thread</strong>等模型都是用來指導如何分工。</p>\n<h2 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h2><blockquote>\n<p>在併發程式領域中的同步，主要指的就Thread之間的協作。本質上和現實生活中的協作相同，就是<strong>一個Thread執行完了一個任務，如何通知執行後續任務的Thread開工而已</strong>。</p>\n</blockquote>\n<p>分工好之後，就是具體執行了。在項目的執行中，任務之間會有依賴，一個任務結束後，依賴它的後續任務就可以開工，後續任務怎麼知道可以開工了？這個就是靠溝通協作了。</p>\n<p>協作一般與分工相關。<code>java.util.concurrent</code> package裡的<strong>Exuecutor、Fork&#x2F;Join、Future</strong>本質上都是分工方法，但同時也能解決Thread協作的問題。</p>\n<blockquote>\n<p>例如，用Future可以發起一個異步調用，當Main Thread通過get()方法取結果時，Main Thread就會進行等待，等到異步執行的結果返回時，get()方法就會自動返回了。</p>\n</blockquote>\n<p>Main Thread與異步Thread之間的協作，Future Class已經幫我們解決了。如此之外，<code>java.util.concurrent</code> package裡提供的<strong>CountDownLatch、CyclicBarrier、Phaser、Exchanger</strong>也都是用來解決Thread協作的問題。</p>\n<p>工作中遇到的Thread協作問題，很多時候都是需要程式員自己來處理Thread之間的協作。基本上都可以簡單敘述成這樣的問題: <strong>當某個條件不滿足時，Thread需要等待。當某個條件滿足時，Thread需要被喚醒執行</strong>。</p>\n<blockquote>\n<p>例如，在生產者-消費者模型(Producer-Consumers pattern)裡。<br>當queue滿時，Producer Thread等待，當queue不滿時，Producer Thread需要被喚醒執行。<br>當queue為空時，Consumer Thread等待，當queue不為空時，Consumer Thread需要被喚醒執行。</p>\n</blockquote>\n<h3 id=\"Monitor\"><a href=\"#Monitor\" class=\"headerlink\" title=\"Monitor\"></a>Monitor</h3><p>在Java併發領域中，解決協作問題的核心技術是<a href=\"https://zh.wikipedia.org/zh-tw/%E7%9B%A3%E8%A6%96%E5%99%A8_(%E7%A8%8B%E5%BA%8F%E5%90%8C%E6%AD%A5%E5%8C%96)\">Monitor</a>，上面提到的所有Thread協作技術底層都是利用Monitor解決的。</p>\n<p>Monitor是一種解決併發問題的通用模型，除了能解決Thread協作問題，還能解決下面要介紹的<code>互斥</code>問題。可以這麼說，<strong>Monitor是解決併發問題的萬能鑰匙</strong>。</p>\n<p>這部份的關鍵是理解Monitor模型，學好它就可以解決所有問題。其次是了解<code>java.util.concurrent</code> package裡提供的Thread協作的class應用場景。</p>\n<h2 id=\"互斥\"><a href=\"#互斥\" class=\"headerlink\" title=\"互斥\"></a>互斥</h2><blockquote>\n<p>所謂互斥，指的是同一時間，只允許一個Thread訪問共享變量。</p>\n</blockquote>\n<p>分工、同步主要強調的是性能，但在併發程式中還有一部份是關於正確性，用專業術語叫<strong>Thread safe</strong>。當併發程式裡，多個Thread同時訪問同一個共享變數時，結果是不一定的：意味著可能正確，也可能錯誤。</p>\n<p>導致這種不確定的主要源頭是<strong>可見性、有序性和原子性問題</strong>。為了解決這些問題，Java引入了<code>Memory Model</code>。Java Memory Model提供了一系列的規則。利用這些規則可以避免可見性、有序性問題，但是還是不能完全解決Thread safe問題。確保Thread safe的最佳方案還是<strong>互斥</strong>。</p>\n<p>實現互斥的核心技術就是<code>lock</code>，Java提供的synchronized以及SDK提供的各種Lock都能解決互斥問題。lock解決了安全性問題，但也帶來了性能問題，那如何保證安全性的同時又盡量提高性能呢？</p>\n<p>可以依照使用場景優化，Java SDK裡提供的ReadWriteLock、StampedLockdk可以優化<code>讀多寫少</code>場景下的lock的性能。還可以使用無鎖的數據結構，例如Java SDK提供的<code>Atomic class</code>都是基於無鎖技術實現的。</p>\n<p>除此之外，還有一些其他的方案，原理是<code>不共享变量</code>或者<code>變數只允許讀</code>。這方面，Java提供了Thread Local和final關鍵字，還有一種Copy-on-write的模式。</p>\n<blockquote>\n<p>使用lock除了要注意性能問題之外，還需要注意<code>dead lock</code>問題。</p>\n</blockquote>\n<h2 id=\"結語\"><a href=\"#結語\" class=\"headerlink\" title=\"結語\"></a>結語</h2><p>以上簡單的介紹併發程式中會遇到的問題，以及稍微提到Java SDK裡提供的工具能解決什麼樣的問題與何種應用場景方便使用。</p>\n<p>之後會有更加詳細的介紹各項工具與併發問題。</p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://time.geekbang.org/column/159\">https://time.geekbang.org/column/159</a></li>\n<li><a href=\"https://zh.wikipedia.org/zh-tw/%E7%9B%A3%E8%A6%96%E5%99%A8_(%E7%A8%8B%E5%BA%8F%E5%90%8C%E6%AD%A5%E5%8C%96)\">https://zh.wikipedia.org/zh-tw/%E7%9B%A3%E8%A6%96%E5%99%A8_(%E7%A8%8B%E5%BA%8F%E5%90%8C%E6%AD%A5%E5%8C%96)</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>併發程式的三個核心問題: 分工、同步和互斥</p>","more":"<h2 id=\"分工\"><a href=\"#分工\" class=\"headerlink\" title=\"分工\"></a>分工</h2><blockquote>\n<p>所謂的分工，類似於現實生活中一個組織完成一個項目，項目經理要拆分任務，安排合適的成員去完成。</p>\n</blockquote>\n<p>在併發程式的領域，你就是項目經理，Thread就是項目成員。任務的分解和分工對於項目成敗非常關鍵，不過在併發領域裡，分工更為重要，他直接決定了併發程式的性能。</p>\n<p><code>java.util.concurrent</code> package裡的<strong>Exuecutor、Fork&#x2F;Join、Future</strong>本質上是一種分工方法。</p>\n<p>併發程式領域還總結一些設計模式，基本上都是和分工方法相關的，例如<strong>生產者-消費者、Thread Pre-Message、Worker Thread</strong>等模型都是用來指導如何分工。</p>\n<h2 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h2><blockquote>\n<p>在併發程式領域中的同步，主要指的就Thread之間的協作。本質上和現實生活中的協作相同，就是<strong>一個Thread執行完了一個任務，如何通知執行後續任務的Thread開工而已</strong>。</p>\n</blockquote>\n<p>分工好之後，就是具體執行了。在項目的執行中，任務之間會有依賴，一個任務結束後，依賴它的後續任務就可以開工，後續任務怎麼知道可以開工了？這個就是靠溝通協作了。</p>\n<p>協作一般與分工相關。<code>java.util.concurrent</code> package裡的<strong>Exuecutor、Fork&#x2F;Join、Future</strong>本質上都是分工方法，但同時也能解決Thread協作的問題。</p>\n<blockquote>\n<p>例如，用Future可以發起一個異步調用，當Main Thread通過get()方法取結果時，Main Thread就會進行等待，等到異步執行的結果返回時，get()方法就會自動返回了。</p>\n</blockquote>\n<p>Main Thread與異步Thread之間的協作，Future Class已經幫我們解決了。如此之外，<code>java.util.concurrent</code> package裡提供的<strong>CountDownLatch、CyclicBarrier、Phaser、Exchanger</strong>也都是用來解決Thread協作的問題。</p>\n<p>工作中遇到的Thread協作問題，很多時候都是需要程式員自己來處理Thread之間的協作。基本上都可以簡單敘述成這樣的問題: <strong>當某個條件不滿足時，Thread需要等待。當某個條件滿足時，Thread需要被喚醒執行</strong>。</p>\n<blockquote>\n<p>例如，在生產者-消費者模型(Producer-Consumers pattern)裡。<br>當queue滿時，Producer Thread等待，當queue不滿時，Producer Thread需要被喚醒執行。<br>當queue為空時，Consumer Thread等待，當queue不為空時，Consumer Thread需要被喚醒執行。</p>\n</blockquote>\n<h3 id=\"Monitor\"><a href=\"#Monitor\" class=\"headerlink\" title=\"Monitor\"></a>Monitor</h3><p>在Java併發領域中，解決協作問題的核心技術是<a href=\"https://zh.wikipedia.org/zh-tw/%E7%9B%A3%E8%A6%96%E5%99%A8_(%E7%A8%8B%E5%BA%8F%E5%90%8C%E6%AD%A5%E5%8C%96)\">Monitor</a>，上面提到的所有Thread協作技術底層都是利用Monitor解決的。</p>\n<p>Monitor是一種解決併發問題的通用模型，除了能解決Thread協作問題，還能解決下面要介紹的<code>互斥</code>問題。可以這麼說，<strong>Monitor是解決併發問題的萬能鑰匙</strong>。</p>\n<p>這部份的關鍵是理解Monitor模型，學好它就可以解決所有問題。其次是了解<code>java.util.concurrent</code> package裡提供的Thread協作的class應用場景。</p>\n<h2 id=\"互斥\"><a href=\"#互斥\" class=\"headerlink\" title=\"互斥\"></a>互斥</h2><blockquote>\n<p>所謂互斥，指的是同一時間，只允許一個Thread訪問共享變量。</p>\n</blockquote>\n<p>分工、同步主要強調的是性能，但在併發程式中還有一部份是關於正確性，用專業術語叫<strong>Thread safe</strong>。當併發程式裡，多個Thread同時訪問同一個共享變數時，結果是不一定的：意味著可能正確，也可能錯誤。</p>\n<p>導致這種不確定的主要源頭是<strong>可見性、有序性和原子性問題</strong>。為了解決這些問題，Java引入了<code>Memory Model</code>。Java Memory Model提供了一系列的規則。利用這些規則可以避免可見性、有序性問題，但是還是不能完全解決Thread safe問題。確保Thread safe的最佳方案還是<strong>互斥</strong>。</p>\n<p>實現互斥的核心技術就是<code>lock</code>，Java提供的synchronized以及SDK提供的各種Lock都能解決互斥問題。lock解決了安全性問題，但也帶來了性能問題，那如何保證安全性的同時又盡量提高性能呢？</p>\n<p>可以依照使用場景優化，Java SDK裡提供的ReadWriteLock、StampedLockdk可以優化<code>讀多寫少</code>場景下的lock的性能。還可以使用無鎖的數據結構，例如Java SDK提供的<code>Atomic class</code>都是基於無鎖技術實現的。</p>\n<p>除此之外，還有一些其他的方案，原理是<code>不共享变量</code>或者<code>變數只允許讀</code>。這方面，Java提供了Thread Local和final關鍵字，還有一種Copy-on-write的模式。</p>\n<blockquote>\n<p>使用lock除了要注意性能問題之外，還需要注意<code>dead lock</code>問題。</p>\n</blockquote>\n<h2 id=\"結語\"><a href=\"#結語\" class=\"headerlink\" title=\"結語\"></a>結語</h2><p>以上簡單的介紹併發程式中會遇到的問題，以及稍微提到Java SDK裡提供的工具能解決什麼樣的問題與何種應用場景方便使用。</p>\n<p>之後會有更加詳細的介紹各項工具與併發問題。</p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://time.geekbang.org/column/159\">https://time.geekbang.org/column/159</a></li>\n<li><a href=\"https://zh.wikipedia.org/zh-tw/%E7%9B%A3%E8%A6%96%E5%99%A8_(%E7%A8%8B%E5%BA%8F%E5%90%8C%E6%AD%A5%E5%8C%96)\">https://zh.wikipedia.org/zh-tw/%E7%9B%A3%E8%A6%96%E5%99%A8_(%E7%A8%8B%E5%BA%8F%E5%90%8C%E6%AD%A5%E5%8C%96)</a></li>\n</ul>"},{"title":"[Java] ThreadLocal","date":"2022-04-06T01:27:01.000Z","toc":true,"_content":"\nThreadLocal是執行緒的區域變數，跟普通變數不同之處在於:\n每個執行緒持有這個變數的一個copy，可以獨立修改(set)和訪問(get)這個變數，而且執行緒之間不會發生衝突，實現了**執行緒之間的數據隔離**\n\n簡單來說，在ThreadLocal裡中所放入的變數屬於**當前**執行緒，該變數對其他執行緒是隔離的\n\n<!-- more -->\n\n## 如何使用\n\n為了更\n\n## 參考資料\n\n- <https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484118&idx=1&sn=da3e4c4cfd0642687c5d7bcef543fe5b>\n- <https://iter01.com/433173.html>\n- <http://www.jasongj.com/java/threadlocal/>\n","source":"_posts/java/threadlocal.md","raw":"---\ntitle: '[Java] ThreadLocal'\ndate: 2022-04-06 09:27:01\ntags: java\ncategories: 學習\ntoc: true\n---\n\nThreadLocal是執行緒的區域變數，跟普通變數不同之處在於:\n每個執行緒持有這個變數的一個copy，可以獨立修改(set)和訪問(get)這個變數，而且執行緒之間不會發生衝突，實現了**執行緒之間的數據隔離**\n\n簡單來說，在ThreadLocal裡中所放入的變數屬於**當前**執行緒，該變數對其他執行緒是隔離的\n\n<!-- more -->\n\n## 如何使用\n\n為了更\n\n## 參考資料\n\n- <https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484118&idx=1&sn=da3e4c4cfd0642687c5d7bcef543fe5b>\n- <https://iter01.com/433173.html>\n- <http://www.jasongj.com/java/threadlocal/>\n","slug":"java/threadlocal","published":1,"updated":"2022-08-30T06:25:17.719Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7fz5o3a00028szegwsigysf","content":"<p>ThreadLocal是執行緒的區域變數，跟普通變數不同之處在於:<br>每個執行緒持有這個變數的一個copy，可以獨立修改(set)和訪問(get)這個變數，而且執行緒之間不會發生衝突，實現了<strong>執行緒之間的數據隔離</strong></p>\n<p>簡單來說，在ThreadLocal裡中所放入的變數屬於<strong>當前</strong>執行緒，該變數對其他執行緒是隔離的</p>\n<span id=\"more\"></span>\n\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p>為了更</p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484118&amp;idx=1&amp;sn=da3e4c4cfd0642687c5d7bcef543fe5b\">https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484118&amp;idx=1&amp;sn=da3e4c4cfd0642687c5d7bcef543fe5b</a></li>\n<li><a href=\"https://iter01.com/433173.html\">https://iter01.com/433173.html</a></li>\n<li><a href=\"http://www.jasongj.com/java/threadlocal/\">http://www.jasongj.com/java/threadlocal/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>ThreadLocal是執行緒的區域變數，跟普通變數不同之處在於:<br>每個執行緒持有這個變數的一個copy，可以獨立修改(set)和訪問(get)這個變數，而且執行緒之間不會發生衝突，實現了<strong>執行緒之間的數據隔離</strong></p>\n<p>簡單來說，在ThreadLocal裡中所放入的變數屬於<strong>當前</strong>執行緒，該變數對其他執行緒是隔離的</p>","more":"<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p>為了更</p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484118&amp;idx=1&amp;sn=da3e4c4cfd0642687c5d7bcef543fe5b\">https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484118&amp;idx=1&amp;sn=da3e4c4cfd0642687c5d7bcef543fe5b</a></li>\n<li><a href=\"https://iter01.com/433173.html\">https://iter01.com/433173.html</a></li>\n<li><a href=\"http://www.jasongj.com/java/threadlocal/\">http://www.jasongj.com/java/threadlocal/</a></li>\n</ul>"},{"title":"[Java] 可見性、原子性和有序性","date":"2022-09-03T05:18:01.000Z","toc":true,"_content":"\n在撰寫併發程式時，Bug往往會詭異的出現，然後又詭異的消失，很難重現，也很難追蹤。但想要快速且精準的解決併發出現的問題，就要理解出現這些事件的本質，追本朔源，深入分析這些問題的源頭在哪裡。\n\n那為什麼併發程式會很容易出問題？它又是怎麼出現問題的？今天就讓我們聊聊這些問題吧!\n\n<!-- more -->\n\n## 併發程式背後的故事\n\nCPU、Memory、IO設備在這些年內不斷的迭代更新。但是在這快速發展的過程中，有一個**核心矛盾一直存在，就是這三者的速度差異**。\n\n> 速度差異(快&rarr;慢)： CPU > Memory > IO\n\n為了合理利用CPU的高性能，平衡這三者的速度差異，電腦體系結構、OS、程式編譯器都做出了貢獻，主要體現為：\n\n1. CPU增加了`快取(cache)`，來均衡與Memory的速度差異。\n2. OS增加了Process、Thread，以[分時系統](https://zh.wikipedia.org/zh-tw/%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1)來復用CPU，進而均衡CPU與IO的速度差異。\n3. 程式編譯器優化程式執行順序，使得快取能夠得到更加合理的利用。\n\n現在我們所有程式都默默享受著這些成果，但是天下沒有免費的午餐，併發的許多詭異問題的根源也在這裡。\n\n## 源頭一： CPU快取導致的可見性問題\n\n> 一個Thread對共享變量的修改，另外一個Thread能夠立刻看到，我們成為**可見性**。\n\n多核時期，每個CPU都有自己的快取，這時CPU快取與Memory的數據一致性就沒那麼容易解決了，當多個Thread在不同的CPU執行時，這些Thread操作的是不同的CPU快取。\n\n比如下圖中，Thread A操作的是CPU-1上的快取，而Thread B操作的是CPU-2上的快取，這時候Thread A對變數V的操作對於Thread B而言就不具備可見性了。\n\n![多core CPU的快取與Memory關係圖](/images/java/concurrentcy/visibility-atomic-ordering/cpu-cache.png)\n\n下面我們再用一段程式驗證一下多核場景下的可見性問題。\n\n下面代碼，每執行一次add10K()方法，都會循環10000次count+=1操作。在calc()方法中我們建立的兩個Thread，每個Thread調用一次add10K()方法。\n\n```java\npublic class Test {\n\n  private long count = 0;\n\n  private void add10K() {\n    int idx = 0;\n    while (idx++ < 10000) {\n      count += 1;\n    }\n  }\n\n  public long calc() throws InterruptedException {\n    // 創建兩個Thread，執行add操作\n    Thread thA = new Thread(this::add10K);\n    Thread thB = new Thread(this::add10K);\n    // 啟動兩個Thread\n    thA.start();\n    thB.start();\n    // 等待兩個Thread執行結束\n    thA.join();\n    thB.join();\n    return count;\n  }\n}\n```\n\n我們設想的執行結果20000，因為在單一Thread裡調用兩次add10K()方法，count的值就是20000，但是實際上calc()的執行結果是介於10000到20000之間的隨機數，為什麼會這樣呢？\n\n我們假設Thread A和Thread B同時開始執行，在一開始時都會將*count=0讀到各自的CPU快取中*，執行完count+=1之後，各自的CPU快取中的值都是1，同時寫入Memory後，我們會發現Memory中的值會是1，而不是我們預期的2。之後由於各自的CPU快取裡都有count的值，兩個Thread都是基於CPU快取裡的count值來計算，所以導致最後count的值都會是小於20000。\n\n這就是CPU快取的可見性問題。\n\n## 源頭二: Thread切換帶來的原子性問題\n\n由於IO太慢，早期的OS就發明了Multi-Processing，即便在單核CPU上我們也可以一邊聽著歌，一邊寫程式，這個就是Multi-Processing的功勞。\n\nOS允許某一個某個Process執行一小段時間，例如50毫秒，過了50毫秒OS就會重新選擇一個Process來執行(俗稱:[任務切換Task Switching](https://en.wikipedia.org/wiki/Task_switching_(psychology))，這個50毫秒稱為[時間片](https://zh.wikipedia.org/zh-tw/%E6%97%B6%E9%97%B4%E7%89%87)。\n\nJava的併發程式都是基於多執行緒的，自然也會涉及到任務切換，但這也是會產生bug的源頭之一。\n\n任務切換的時機大多是在時間片結束的時候，我們現在基本都使用高級語言程式，高級語言裡一條執行語句往往需要多條CPU指令來完成，例如上方代碼中的count+=1，至少需要3條CPU指令。\n\n- 指令1: 先把變數count從內存加載到CPU的[暫存器](https://zh.wikipedia.org/zh-tw/%E5%AF%84%E5%AD%98%E5%99%A8)。\n- 指令2: 接著，在暫存器中執行+1操作。\n- 指令3: 把結果寫入Memory(CPU快取機制有可能寫入的是CPU快取而不是Memory)\n\nOS做任務切換，可以發生在任何一條**CPU指令**執行完。沒錯，是CPU指令，而不是高級語言裡的一條語句。對於上面的三條指令來說，對於上面的三條指令來說，我們假設count=0，如果Thread A在指令1執行完做任務切換，Thread A和Thread B按照下圖的順序執行，那麼我們會發現兩個Thread都執行了count+=1的操作，但是得到的結果不是我們所預期的2，而是1。\n\n![非原子操作的執行路徑示意圖](/images/java/concurrentcy/visibility-atomic-ordering/cpu-cache.png)\n\n我們的直覺會覺得count+=1這個操作是一個不可分割的整體，就像一個原子一樣，Thread的切換可以發生在count+=1之前，也可以發生在count+=1之後，但就是不會發生在中間。\n\n> 我們把一個或多個操作**在CPU執行的過程中不被中斷**的特性稱為`原子性`\n\n## 源頭三: 編譯優化帶來的有序性問題\n\n編譯器為了優化效能，有時候會改變程式中的程式先後順序，讓我們看看下面例子:\n\n```java\nint x = 0;\nfor (i = 0; i < 100;i++) {\n  x = 1;\n  System.out.println(x);\n}\n```\n\n在這段程式碼中，x在for循環裡重複被賦值了100次的1，但這簡直沒有必要。於是編譯器幫我們優化成下面的程式碼:\n\n```java\nint x = 1;\nfor (i = 0; i < 100;i++) {\n  System.out.println(x);\n}\n```\n\n我們接著來看在Java領域中一個經典的案例，來看如果編譯器幫我們優化程式會發生什麼問題。\n\n單例模式的雙重檢查: 在getInstance()方法中，我們先判斷instance是否為null。如果是null，則鎖定Singleton.class並再次檢查instance是否為null，如果還是null則建立Singleton的一個實體。\n\n```java\npublic class Singleton {\n  static Singleton instance;\n\n  static Singleton getInstance(){\n  if (instance == null) {\n    synchronized(Singleton.class) {\n      if (instance == null)\n        instance = new Singleton();\n      }\n    }\n    return instance;\n  }\n}\n```\n\n假設有兩個Tread A、B同時調用getInstance()方法，會同時發現instance==null，於是同時對Singleton.class加鎖，此時JVM能保證只有一個Thread能加鎖成功(假設是Thread A)，另一條Thread就會處於等待狀態。接著Thread A會建立一個Singleton實體，之後釋放鎖。鎖釋放後，Thread B被喚醒，然後嘗試加鎖，此時可以加鎖成功，Thread B接著檢查instance == null會發現已經有Singleton實體了，所以Thread B就不會再建立一個Singleton實體了。\n\n理論上這一切都很完美，但是實際上getInstance()方法卻有遐疵。\n問題出在new操作上，我們以為的new操作是：\n\n1. 分配一塊記憶體M\n2. 在記憶體M上初始化Singleton物件\n3. 然後將M的地址賦值給instance變數\n\n然而實際優化過的執行路徑卻是如下：\n\n1. 分配一塊記憶體M\n2. 將M的地址賦值給instance變數\n3. 最後在記憶體M上初始化Singleton物件\n\n優化後會產生什麼問題？我們假設Thread A先執行getInstance()方法，當執行完指令2時，剛好發生Thread切換到Thread B，如果此時Thread B執行getInstance()方法時，Thread B會判斷到`instance != null`，所以直接返回instance，但是此時的instance是還沒有初始化過的。如果我們現在使用instance就發生NullPointerException。\n\n![單例模式的雙重檢查異常執行路徑](/images/java/concurrentcy/visibility-atomic-ordering/order-problem.jpg)\n\n## 結語\n\n以上在介紹可見性、原子性、有序性時，特地介紹**CPU快取**帶來的可見性問題，**Thread切換**帶來的原子性問題，**編譯優化**帶來的有序性問題，其實CPU快取、Thread切換以及編譯優化的目的都是提高效能。技術解決一個問題，同時也帶來了一個新的問題，所以在**採用一項技術的同時，一定要清楚它帶來的問題是什麼，以及如何規避**。\n\n## 參考資料\n\n- <https://time.geekbang.org/column/159>(01)\n- <https://www.jianshu.com/p/45885e50d1c4>\n- <https://zh.wikipedia.org/zh-tw/%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1>\n- <https://en.wikipedia.org/wiki/Task_switching_(psychology)>\n- <https://zh.wikipedia.org/zh-tw/%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1>\n","source":"_posts/java/visibility-atomic-ordering.md","raw":"---\ntitle: '[Java] 可見性、原子性和有序性'\ndate: 2022-09-03 13:18:01\ntags: \n  - java \n  - Thread\ncategories: 學習\ntoc: true\n---\n\n在撰寫併發程式時，Bug往往會詭異的出現，然後又詭異的消失，很難重現，也很難追蹤。但想要快速且精準的解決併發出現的問題，就要理解出現這些事件的本質，追本朔源，深入分析這些問題的源頭在哪裡。\n\n那為什麼併發程式會很容易出問題？它又是怎麼出現問題的？今天就讓我們聊聊這些問題吧!\n\n<!-- more -->\n\n## 併發程式背後的故事\n\nCPU、Memory、IO設備在這些年內不斷的迭代更新。但是在這快速發展的過程中，有一個**核心矛盾一直存在，就是這三者的速度差異**。\n\n> 速度差異(快&rarr;慢)： CPU > Memory > IO\n\n為了合理利用CPU的高性能，平衡這三者的速度差異，電腦體系結構、OS、程式編譯器都做出了貢獻，主要體現為：\n\n1. CPU增加了`快取(cache)`，來均衡與Memory的速度差異。\n2. OS增加了Process、Thread，以[分時系統](https://zh.wikipedia.org/zh-tw/%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1)來復用CPU，進而均衡CPU與IO的速度差異。\n3. 程式編譯器優化程式執行順序，使得快取能夠得到更加合理的利用。\n\n現在我們所有程式都默默享受著這些成果，但是天下沒有免費的午餐，併發的許多詭異問題的根源也在這裡。\n\n## 源頭一： CPU快取導致的可見性問題\n\n> 一個Thread對共享變量的修改，另外一個Thread能夠立刻看到，我們成為**可見性**。\n\n多核時期，每個CPU都有自己的快取，這時CPU快取與Memory的數據一致性就沒那麼容易解決了，當多個Thread在不同的CPU執行時，這些Thread操作的是不同的CPU快取。\n\n比如下圖中，Thread A操作的是CPU-1上的快取，而Thread B操作的是CPU-2上的快取，這時候Thread A對變數V的操作對於Thread B而言就不具備可見性了。\n\n![多core CPU的快取與Memory關係圖](/images/java/concurrentcy/visibility-atomic-ordering/cpu-cache.png)\n\n下面我們再用一段程式驗證一下多核場景下的可見性問題。\n\n下面代碼，每執行一次add10K()方法，都會循環10000次count+=1操作。在calc()方法中我們建立的兩個Thread，每個Thread調用一次add10K()方法。\n\n```java\npublic class Test {\n\n  private long count = 0;\n\n  private void add10K() {\n    int idx = 0;\n    while (idx++ < 10000) {\n      count += 1;\n    }\n  }\n\n  public long calc() throws InterruptedException {\n    // 創建兩個Thread，執行add操作\n    Thread thA = new Thread(this::add10K);\n    Thread thB = new Thread(this::add10K);\n    // 啟動兩個Thread\n    thA.start();\n    thB.start();\n    // 等待兩個Thread執行結束\n    thA.join();\n    thB.join();\n    return count;\n  }\n}\n```\n\n我們設想的執行結果20000，因為在單一Thread裡調用兩次add10K()方法，count的值就是20000，但是實際上calc()的執行結果是介於10000到20000之間的隨機數，為什麼會這樣呢？\n\n我們假設Thread A和Thread B同時開始執行，在一開始時都會將*count=0讀到各自的CPU快取中*，執行完count+=1之後，各自的CPU快取中的值都是1，同時寫入Memory後，我們會發現Memory中的值會是1，而不是我們預期的2。之後由於各自的CPU快取裡都有count的值，兩個Thread都是基於CPU快取裡的count值來計算，所以導致最後count的值都會是小於20000。\n\n這就是CPU快取的可見性問題。\n\n## 源頭二: Thread切換帶來的原子性問題\n\n由於IO太慢，早期的OS就發明了Multi-Processing，即便在單核CPU上我們也可以一邊聽著歌，一邊寫程式，這個就是Multi-Processing的功勞。\n\nOS允許某一個某個Process執行一小段時間，例如50毫秒，過了50毫秒OS就會重新選擇一個Process來執行(俗稱:[任務切換Task Switching](https://en.wikipedia.org/wiki/Task_switching_(psychology))，這個50毫秒稱為[時間片](https://zh.wikipedia.org/zh-tw/%E6%97%B6%E9%97%B4%E7%89%87)。\n\nJava的併發程式都是基於多執行緒的，自然也會涉及到任務切換，但這也是會產生bug的源頭之一。\n\n任務切換的時機大多是在時間片結束的時候，我們現在基本都使用高級語言程式，高級語言裡一條執行語句往往需要多條CPU指令來完成，例如上方代碼中的count+=1，至少需要3條CPU指令。\n\n- 指令1: 先把變數count從內存加載到CPU的[暫存器](https://zh.wikipedia.org/zh-tw/%E5%AF%84%E5%AD%98%E5%99%A8)。\n- 指令2: 接著，在暫存器中執行+1操作。\n- 指令3: 把結果寫入Memory(CPU快取機制有可能寫入的是CPU快取而不是Memory)\n\nOS做任務切換，可以發生在任何一條**CPU指令**執行完。沒錯，是CPU指令，而不是高級語言裡的一條語句。對於上面的三條指令來說，對於上面的三條指令來說，我們假設count=0，如果Thread A在指令1執行完做任務切換，Thread A和Thread B按照下圖的順序執行，那麼我們會發現兩個Thread都執行了count+=1的操作，但是得到的結果不是我們所預期的2，而是1。\n\n![非原子操作的執行路徑示意圖](/images/java/concurrentcy/visibility-atomic-ordering/cpu-cache.png)\n\n我們的直覺會覺得count+=1這個操作是一個不可分割的整體，就像一個原子一樣，Thread的切換可以發生在count+=1之前，也可以發生在count+=1之後，但就是不會發生在中間。\n\n> 我們把一個或多個操作**在CPU執行的過程中不被中斷**的特性稱為`原子性`\n\n## 源頭三: 編譯優化帶來的有序性問題\n\n編譯器為了優化效能，有時候會改變程式中的程式先後順序，讓我們看看下面例子:\n\n```java\nint x = 0;\nfor (i = 0; i < 100;i++) {\n  x = 1;\n  System.out.println(x);\n}\n```\n\n在這段程式碼中，x在for循環裡重複被賦值了100次的1，但這簡直沒有必要。於是編譯器幫我們優化成下面的程式碼:\n\n```java\nint x = 1;\nfor (i = 0; i < 100;i++) {\n  System.out.println(x);\n}\n```\n\n我們接著來看在Java領域中一個經典的案例，來看如果編譯器幫我們優化程式會發生什麼問題。\n\n單例模式的雙重檢查: 在getInstance()方法中，我們先判斷instance是否為null。如果是null，則鎖定Singleton.class並再次檢查instance是否為null，如果還是null則建立Singleton的一個實體。\n\n```java\npublic class Singleton {\n  static Singleton instance;\n\n  static Singleton getInstance(){\n  if (instance == null) {\n    synchronized(Singleton.class) {\n      if (instance == null)\n        instance = new Singleton();\n      }\n    }\n    return instance;\n  }\n}\n```\n\n假設有兩個Tread A、B同時調用getInstance()方法，會同時發現instance==null，於是同時對Singleton.class加鎖，此時JVM能保證只有一個Thread能加鎖成功(假設是Thread A)，另一條Thread就會處於等待狀態。接著Thread A會建立一個Singleton實體，之後釋放鎖。鎖釋放後，Thread B被喚醒，然後嘗試加鎖，此時可以加鎖成功，Thread B接著檢查instance == null會發現已經有Singleton實體了，所以Thread B就不會再建立一個Singleton實體了。\n\n理論上這一切都很完美，但是實際上getInstance()方法卻有遐疵。\n問題出在new操作上，我們以為的new操作是：\n\n1. 分配一塊記憶體M\n2. 在記憶體M上初始化Singleton物件\n3. 然後將M的地址賦值給instance變數\n\n然而實際優化過的執行路徑卻是如下：\n\n1. 分配一塊記憶體M\n2. 將M的地址賦值給instance變數\n3. 最後在記憶體M上初始化Singleton物件\n\n優化後會產生什麼問題？我們假設Thread A先執行getInstance()方法，當執行完指令2時，剛好發生Thread切換到Thread B，如果此時Thread B執行getInstance()方法時，Thread B會判斷到`instance != null`，所以直接返回instance，但是此時的instance是還沒有初始化過的。如果我們現在使用instance就發生NullPointerException。\n\n![單例模式的雙重檢查異常執行路徑](/images/java/concurrentcy/visibility-atomic-ordering/order-problem.jpg)\n\n## 結語\n\n以上在介紹可見性、原子性、有序性時，特地介紹**CPU快取**帶來的可見性問題，**Thread切換**帶來的原子性問題，**編譯優化**帶來的有序性問題，其實CPU快取、Thread切換以及編譯優化的目的都是提高效能。技術解決一個問題，同時也帶來了一個新的問題，所以在**採用一項技術的同時，一定要清楚它帶來的問題是什麼，以及如何規避**。\n\n## 參考資料\n\n- <https://time.geekbang.org/column/159>(01)\n- <https://www.jianshu.com/p/45885e50d1c4>\n- <https://zh.wikipedia.org/zh-tw/%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1>\n- <https://en.wikipedia.org/wiki/Task_switching_(psychology)>\n- <https://zh.wikipedia.org/zh-tw/%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1>\n","slug":"java/visibility-atomic-ordering","published":1,"updated":"2022-09-06T15:46:19.236Z","_id":"cl7qd525d0000b5zehbv733aq","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在撰寫併發程式時，Bug往往會詭異的出現，然後又詭異的消失，很難重現，也很難追蹤。但想要快速且精準的解決併發出現的問題，就要理解出現這些事件的本質，追本朔源，深入分析這些問題的源頭在哪裡。</p>\n<p>那為什麼併發程式會很容易出問題？它又是怎麼出現問題的？今天就讓我們聊聊這些問題吧!</p>\n<span id=\"more\"></span>\n\n<h2 id=\"併發程式背後的故事\"><a href=\"#併發程式背後的故事\" class=\"headerlink\" title=\"併發程式背後的故事\"></a>併發程式背後的故事</h2><p>CPU、Memory、IO設備在這些年內不斷的迭代更新。但是在這快速發展的過程中，有一個<strong>核心矛盾一直存在，就是這三者的速度差異</strong>。</p>\n<blockquote>\n<p>速度差異(快&amp;rarr;慢)： CPU &gt; Memory &gt; IO</p>\n</blockquote>\n<p>為了合理利用CPU的高性能，平衡這三者的速度差異，電腦體系結構、OS、程式編譯器都做出了貢獻，主要體現為：</p>\n<ol>\n<li>CPU增加了<code>快取(cache)</code>，來均衡與Memory的速度差異。</li>\n<li>OS增加了Process、Thread，以<a href=\"https://zh.wikipedia.org/zh-tw/%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1\">分時系統</a>來復用CPU，進而均衡CPU與IO的速度差異。</li>\n<li>程式編譯器優化程式執行順序，使得快取能夠得到更加合理的利用。</li>\n</ol>\n<p>現在我們所有程式都默默享受著這些成果，但是天下沒有免費的午餐，併發的許多詭異問題的根源也在這裡。</p>\n<h2 id=\"源頭一：-CPU快取導致的可見性問題\"><a href=\"#源頭一：-CPU快取導致的可見性問題\" class=\"headerlink\" title=\"源頭一： CPU快取導致的可見性問題\"></a>源頭一： CPU快取導致的可見性問題</h2><blockquote>\n<p>一個Thread對共享變量的修改，另外一個Thread能夠立刻看到，我們成為<strong>可見性</strong>。</p>\n</blockquote>\n<p>多核時期，每個CPU都有自己的快取，這時CPU快取與Memory的數據一致性就沒那麼容易解決了，當多個Thread在不同的CPU執行時，這些Thread操作的是不同的CPU快取。</p>\n<p>比如下圖中，Thread A操作的是CPU-1上的快取，而Thread B操作的是CPU-2上的快取，這時候Thread A對變數V的操作對於Thread B而言就不具備可見性了。</p>\n<p><img src=\"/images/java/concurrentcy/visibility-atomic-ordering/cpu-cache.png\" alt=\"多core CPU的快取與Memory關係圖\"></p>\n<p>下面我們再用一段程式驗證一下多核場景下的可見性問題。</p>\n<p>下面代碼，每執行一次add10K()方法，都會循環10000次count+&#x3D;1操作。在calc()方法中我們建立的兩個Thread，每個Thread調用一次add10K()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add10K</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">idx</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (idx++ &lt; <span class=\"number\">10000</span>) &#123;</span><br><span class=\"line\">      count += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">calc</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 創建兩個Thread，執行add操作</span></span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">thA</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"built_in\">this</span>::add10K);</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">thB</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"built_in\">this</span>::add10K);</span><br><span class=\"line\">    <span class=\"comment\">// 啟動兩個Thread</span></span><br><span class=\"line\">    thA.start();</span><br><span class=\"line\">    thB.start();</span><br><span class=\"line\">    <span class=\"comment\">// 等待兩個Thread執行結束</span></span><br><span class=\"line\">    thA.join();</span><br><span class=\"line\">    thB.join();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我們設想的執行結果20000，因為在單一Thread裡調用兩次add10K()方法，count的值就是20000，但是實際上calc()的執行結果是介於10000到20000之間的隨機數，為什麼會這樣呢？</p>\n<p>我們假設Thread A和Thread B同時開始執行，在一開始時都會將<em>count&#x3D;0讀到各自的CPU快取中</em>，執行完count+&#x3D;1之後，各自的CPU快取中的值都是1，同時寫入Memory後，我們會發現Memory中的值會是1，而不是我們預期的2。之後由於各自的CPU快取裡都有count的值，兩個Thread都是基於CPU快取裡的count值來計算，所以導致最後count的值都會是小於20000。</p>\n<p>這就是CPU快取的可見性問題。</p>\n<h2 id=\"源頭二-Thread切換帶來的原子性問題\"><a href=\"#源頭二-Thread切換帶來的原子性問題\" class=\"headerlink\" title=\"源頭二: Thread切換帶來的原子性問題\"></a>源頭二: Thread切換帶來的原子性問題</h2><p>由於IO太慢，早期的OS就發明了Multi-Processing，即便在單核CPU上我們也可以一邊聽著歌，一邊寫程式，這個就是Multi-Processing的功勞。</p>\n<p>OS允許某一個某個Process執行一小段時間，例如50毫秒，過了50毫秒OS就會重新選擇一個Process來執行(俗稱:<a href=\"https://en.wikipedia.org/wiki/Task_switching_(psychology)\">任務切換Task Switching</a>，這個50毫秒稱為<a href=\"https://zh.wikipedia.org/zh-tw/%E6%97%B6%E9%97%B4%E7%89%87\">時間片</a>。</p>\n<p>Java的併發程式都是基於多執行緒的，自然也會涉及到任務切換，但這也是會產生bug的源頭之一。</p>\n<p>任務切換的時機大多是在時間片結束的時候，我們現在基本都使用高級語言程式，高級語言裡一條執行語句往往需要多條CPU指令來完成，例如上方代碼中的count+&#x3D;1，至少需要3條CPU指令。</p>\n<ul>\n<li>指令1: 先把變數count從內存加載到CPU的<a href=\"https://zh.wikipedia.org/zh-tw/%E5%AF%84%E5%AD%98%E5%99%A8\">暫存器</a>。</li>\n<li>指令2: 接著，在暫存器中執行+1操作。</li>\n<li>指令3: 把結果寫入Memory(CPU快取機制有可能寫入的是CPU快取而不是Memory)</li>\n</ul>\n<p>OS做任務切換，可以發生在任何一條<strong>CPU指令</strong>執行完。沒錯，是CPU指令，而不是高級語言裡的一條語句。對於上面的三條指令來說，對於上面的三條指令來說，我們假設count&#x3D;0，如果Thread A在指令1執行完做任務切換，Thread A和Thread B按照下圖的順序執行，那麼我們會發現兩個Thread都執行了count+&#x3D;1的操作，但是得到的結果不是我們所預期的2，而是1。</p>\n<p><img src=\"/images/java/concurrentcy/visibility-atomic-ordering/cpu-cache.png\" alt=\"非原子操作的執行路徑示意圖\"></p>\n<p>我們的直覺會覺得count+&#x3D;1這個操作是一個不可分割的整體，就像一個原子一樣，Thread的切換可以發生在count+&#x3D;1之前，也可以發生在count+&#x3D;1之後，但就是不會發生在中間。</p>\n<blockquote>\n<p>我們把一個或多個操作<strong>在CPU執行的過程中不被中斷</strong>的特性稱為<code>原子性</code></p>\n</blockquote>\n<h2 id=\"源頭三-編譯優化帶來的有序性問題\"><a href=\"#源頭三-編譯優化帶來的有序性問題\" class=\"headerlink\" title=\"源頭三: 編譯優化帶來的有序性問題\"></a>源頭三: 編譯優化帶來的有序性問題</h2><p>編譯器為了優化效能，有時候會改變程式中的程式先後順序，讓我們看看下面例子:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>;i++) &#123;</span><br><span class=\"line\">  x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  System.out.println(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在這段程式碼中，x在for循環裡重複被賦值了100次的1，但這簡直沒有必要。於是編譯器幫我們優化成下面的程式碼:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>;i++) &#123;</span><br><span class=\"line\">  System.out.println(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我們接著來看在Java領域中一個經典的案例，來看如果編譯器幫我們優化程式會發生什麼問題。</p>\n<p>單例模式的雙重檢查: 在getInstance()方法中，我們先判斷instance是否為null。如果是null，則鎖定Singleton.class並再次檢查instance是否為null，如果還是null則建立Singleton的一個實體。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(Singleton.class) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假設有兩個Tread A、B同時調用getInstance()方法，會同時發現instance&#x3D;&#x3D;null，於是同時對Singleton.class加鎖，此時JVM能保證只有一個Thread能加鎖成功(假設是Thread A)，另一條Thread就會處於等待狀態。接著Thread A會建立一個Singleton實體，之後釋放鎖。鎖釋放後，Thread B被喚醒，然後嘗試加鎖，此時可以加鎖成功，Thread B接著檢查instance &#x3D;&#x3D; null會發現已經有Singleton實體了，所以Thread B就不會再建立一個Singleton實體了。</p>\n<p>理論上這一切都很完美，但是實際上getInstance()方法卻有遐疵。<br>問題出在new操作上，我們以為的new操作是：</p>\n<ol>\n<li>分配一塊記憶體M</li>\n<li>在記憶體M上初始化Singleton物件</li>\n<li>然後將M的地址賦值給instance變數</li>\n</ol>\n<p>然而實際優化過的執行路徑卻是如下：</p>\n<ol>\n<li>分配一塊記憶體M</li>\n<li>將M的地址賦值給instance變數</li>\n<li>最後在記憶體M上初始化Singleton物件</li>\n</ol>\n<p>優化後會產生什麼問題？我們假設Thread A先執行getInstance()方法，當執行完指令2時，剛好發生Thread切換到Thread B，如果此時Thread B執行getInstance()方法時，Thread B會判斷到<code>instance != null</code>，所以直接返回instance，但是此時的instance是還沒有初始化過的。如果我們現在使用instance就發生NullPointerException。</p>\n<p><img src=\"/images/java/concurrentcy/visibility-atomic-ordering/order-problem.jpg\" alt=\"單例模式的雙重檢查異常執行路徑\"></p>\n<h2 id=\"結語\"><a href=\"#結語\" class=\"headerlink\" title=\"結語\"></a>結語</h2><p>以上在介紹可見性、原子性、有序性時，特地介紹<strong>CPU快取</strong>帶來的可見性問題，<strong>Thread切換</strong>帶來的原子性問題，<strong>編譯優化</strong>帶來的有序性問題，其實CPU快取、Thread切換以及編譯優化的目的都是提高效能。技術解決一個問題，同時也帶來了一個新的問題，所以在<strong>採用一項技術的同時，一定要清楚它帶來的問題是什麼，以及如何規避</strong>。</p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://time.geekbang.org/column/159\">https://time.geekbang.org/column/159</a>(01)</li>\n<li><a href=\"https://www.jianshu.com/p/45885e50d1c4\">https://www.jianshu.com/p/45885e50d1c4</a></li>\n<li><a href=\"https://zh.wikipedia.org/zh-tw/%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1\">https://zh.wikipedia.org/zh-tw/%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Task_switching_(psychology)\">https://en.wikipedia.org/wiki/Task_switching_(psychology)</a></li>\n<li><a href=\"https://zh.wikipedia.org/zh-tw/%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1\">https://zh.wikipedia.org/zh-tw/%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在撰寫併發程式時，Bug往往會詭異的出現，然後又詭異的消失，很難重現，也很難追蹤。但想要快速且精準的解決併發出現的問題，就要理解出現這些事件的本質，追本朔源，深入分析這些問題的源頭在哪裡。</p>\n<p>那為什麼併發程式會很容易出問題？它又是怎麼出現問題的？今天就讓我們聊聊這些問題吧!</p>","more":"<h2 id=\"併發程式背後的故事\"><a href=\"#併發程式背後的故事\" class=\"headerlink\" title=\"併發程式背後的故事\"></a>併發程式背後的故事</h2><p>CPU、Memory、IO設備在這些年內不斷的迭代更新。但是在這快速發展的過程中，有一個<strong>核心矛盾一直存在，就是這三者的速度差異</strong>。</p>\n<blockquote>\n<p>速度差異(快&amp;rarr;慢)： CPU &gt; Memory &gt; IO</p>\n</blockquote>\n<p>為了合理利用CPU的高性能，平衡這三者的速度差異，電腦體系結構、OS、程式編譯器都做出了貢獻，主要體現為：</p>\n<ol>\n<li>CPU增加了<code>快取(cache)</code>，來均衡與Memory的速度差異。</li>\n<li>OS增加了Process、Thread，以<a href=\"https://zh.wikipedia.org/zh-tw/%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1\">分時系統</a>來復用CPU，進而均衡CPU與IO的速度差異。</li>\n<li>程式編譯器優化程式執行順序，使得快取能夠得到更加合理的利用。</li>\n</ol>\n<p>現在我們所有程式都默默享受著這些成果，但是天下沒有免費的午餐，併發的許多詭異問題的根源也在這裡。</p>\n<h2 id=\"源頭一：-CPU快取導致的可見性問題\"><a href=\"#源頭一：-CPU快取導致的可見性問題\" class=\"headerlink\" title=\"源頭一： CPU快取導致的可見性問題\"></a>源頭一： CPU快取導致的可見性問題</h2><blockquote>\n<p>一個Thread對共享變量的修改，另外一個Thread能夠立刻看到，我們成為<strong>可見性</strong>。</p>\n</blockquote>\n<p>多核時期，每個CPU都有自己的快取，這時CPU快取與Memory的數據一致性就沒那麼容易解決了，當多個Thread在不同的CPU執行時，這些Thread操作的是不同的CPU快取。</p>\n<p>比如下圖中，Thread A操作的是CPU-1上的快取，而Thread B操作的是CPU-2上的快取，這時候Thread A對變數V的操作對於Thread B而言就不具備可見性了。</p>\n<p><img src=\"/images/java/concurrentcy/visibility-atomic-ordering/cpu-cache.png\" alt=\"多core CPU的快取與Memory關係圖\"></p>\n<p>下面我們再用一段程式驗證一下多核場景下的可見性問題。</p>\n<p>下面代碼，每執行一次add10K()方法，都會循環10000次count+&#x3D;1操作。在calc()方法中我們建立的兩個Thread，每個Thread調用一次add10K()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">add10K</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">idx</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (idx++ &lt; <span class=\"number\">10000</span>) &#123;</span><br><span class=\"line\">      count += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">calc</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 創建兩個Thread，執行add操作</span></span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">thA</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"built_in\">this</span>::add10K);</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">thB</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"built_in\">this</span>::add10K);</span><br><span class=\"line\">    <span class=\"comment\">// 啟動兩個Thread</span></span><br><span class=\"line\">    thA.start();</span><br><span class=\"line\">    thB.start();</span><br><span class=\"line\">    <span class=\"comment\">// 等待兩個Thread執行結束</span></span><br><span class=\"line\">    thA.join();</span><br><span class=\"line\">    thB.join();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我們設想的執行結果20000，因為在單一Thread裡調用兩次add10K()方法，count的值就是20000，但是實際上calc()的執行結果是介於10000到20000之間的隨機數，為什麼會這樣呢？</p>\n<p>我們假設Thread A和Thread B同時開始執行，在一開始時都會將<em>count&#x3D;0讀到各自的CPU快取中</em>，執行完count+&#x3D;1之後，各自的CPU快取中的值都是1，同時寫入Memory後，我們會發現Memory中的值會是1，而不是我們預期的2。之後由於各自的CPU快取裡都有count的值，兩個Thread都是基於CPU快取裡的count值來計算，所以導致最後count的值都會是小於20000。</p>\n<p>這就是CPU快取的可見性問題。</p>\n<h2 id=\"源頭二-Thread切換帶來的原子性問題\"><a href=\"#源頭二-Thread切換帶來的原子性問題\" class=\"headerlink\" title=\"源頭二: Thread切換帶來的原子性問題\"></a>源頭二: Thread切換帶來的原子性問題</h2><p>由於IO太慢，早期的OS就發明了Multi-Processing，即便在單核CPU上我們也可以一邊聽著歌，一邊寫程式，這個就是Multi-Processing的功勞。</p>\n<p>OS允許某一個某個Process執行一小段時間，例如50毫秒，過了50毫秒OS就會重新選擇一個Process來執行(俗稱:<a href=\"https://en.wikipedia.org/wiki/Task_switching_(psychology)\">任務切換Task Switching</a>，這個50毫秒稱為<a href=\"https://zh.wikipedia.org/zh-tw/%E6%97%B6%E9%97%B4%E7%89%87\">時間片</a>。</p>\n<p>Java的併發程式都是基於多執行緒的，自然也會涉及到任務切換，但這也是會產生bug的源頭之一。</p>\n<p>任務切換的時機大多是在時間片結束的時候，我們現在基本都使用高級語言程式，高級語言裡一條執行語句往往需要多條CPU指令來完成，例如上方代碼中的count+&#x3D;1，至少需要3條CPU指令。</p>\n<ul>\n<li>指令1: 先把變數count從內存加載到CPU的<a href=\"https://zh.wikipedia.org/zh-tw/%E5%AF%84%E5%AD%98%E5%99%A8\">暫存器</a>。</li>\n<li>指令2: 接著，在暫存器中執行+1操作。</li>\n<li>指令3: 把結果寫入Memory(CPU快取機制有可能寫入的是CPU快取而不是Memory)</li>\n</ul>\n<p>OS做任務切換，可以發生在任何一條<strong>CPU指令</strong>執行完。沒錯，是CPU指令，而不是高級語言裡的一條語句。對於上面的三條指令來說，對於上面的三條指令來說，我們假設count&#x3D;0，如果Thread A在指令1執行完做任務切換，Thread A和Thread B按照下圖的順序執行，那麼我們會發現兩個Thread都執行了count+&#x3D;1的操作，但是得到的結果不是我們所預期的2，而是1。</p>\n<p><img src=\"/images/java/concurrentcy/visibility-atomic-ordering/cpu-cache.png\" alt=\"非原子操作的執行路徑示意圖\"></p>\n<p>我們的直覺會覺得count+&#x3D;1這個操作是一個不可分割的整體，就像一個原子一樣，Thread的切換可以發生在count+&#x3D;1之前，也可以發生在count+&#x3D;1之後，但就是不會發生在中間。</p>\n<blockquote>\n<p>我們把一個或多個操作<strong>在CPU執行的過程中不被中斷</strong>的特性稱為<code>原子性</code></p>\n</blockquote>\n<h2 id=\"源頭三-編譯優化帶來的有序性問題\"><a href=\"#源頭三-編譯優化帶來的有序性問題\" class=\"headerlink\" title=\"源頭三: 編譯優化帶來的有序性問題\"></a>源頭三: 編譯優化帶來的有序性問題</h2><p>編譯器為了優化效能，有時候會改變程式中的程式先後順序，讓我們看看下面例子:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>;i++) &#123;</span><br><span class=\"line\">  x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  System.out.println(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在這段程式碼中，x在for循環裡重複被賦值了100次的1，但這簡直沒有必要。於是編譯器幫我們優化成下面的程式碼:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>;i++) &#123;</span><br><span class=\"line\">  System.out.println(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我們接著來看在Java領域中一個經典的案例，來看如果編譯器幫我們優化程式會發生什麼問題。</p>\n<p>單例模式的雙重檢查: 在getInstance()方法中，我們先判斷instance是否為null。如果是null，則鎖定Singleton.class並再次檢查instance是否為null，如果還是null則建立Singleton的一個實體。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(Singleton.class) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (instance == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假設有兩個Tread A、B同時調用getInstance()方法，會同時發現instance&#x3D;&#x3D;null，於是同時對Singleton.class加鎖，此時JVM能保證只有一個Thread能加鎖成功(假設是Thread A)，另一條Thread就會處於等待狀態。接著Thread A會建立一個Singleton實體，之後釋放鎖。鎖釋放後，Thread B被喚醒，然後嘗試加鎖，此時可以加鎖成功，Thread B接著檢查instance &#x3D;&#x3D; null會發現已經有Singleton實體了，所以Thread B就不會再建立一個Singleton實體了。</p>\n<p>理論上這一切都很完美，但是實際上getInstance()方法卻有遐疵。<br>問題出在new操作上，我們以為的new操作是：</p>\n<ol>\n<li>分配一塊記憶體M</li>\n<li>在記憶體M上初始化Singleton物件</li>\n<li>然後將M的地址賦值給instance變數</li>\n</ol>\n<p>然而實際優化過的執行路徑卻是如下：</p>\n<ol>\n<li>分配一塊記憶體M</li>\n<li>將M的地址賦值給instance變數</li>\n<li>最後在記憶體M上初始化Singleton物件</li>\n</ol>\n<p>優化後會產生什麼問題？我們假設Thread A先執行getInstance()方法，當執行完指令2時，剛好發生Thread切換到Thread B，如果此時Thread B執行getInstance()方法時，Thread B會判斷到<code>instance != null</code>，所以直接返回instance，但是此時的instance是還沒有初始化過的。如果我們現在使用instance就發生NullPointerException。</p>\n<p><img src=\"/images/java/concurrentcy/visibility-atomic-ordering/order-problem.jpg\" alt=\"單例模式的雙重檢查異常執行路徑\"></p>\n<h2 id=\"結語\"><a href=\"#結語\" class=\"headerlink\" title=\"結語\"></a>結語</h2><p>以上在介紹可見性、原子性、有序性時，特地介紹<strong>CPU快取</strong>帶來的可見性問題，<strong>Thread切換</strong>帶來的原子性問題，<strong>編譯優化</strong>帶來的有序性問題，其實CPU快取、Thread切換以及編譯優化的目的都是提高效能。技術解決一個問題，同時也帶來了一個新的問題，所以在<strong>採用一項技術的同時，一定要清楚它帶來的問題是什麼，以及如何規避</strong>。</p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://time.geekbang.org/column/159\">https://time.geekbang.org/column/159</a>(01)</li>\n<li><a href=\"https://www.jianshu.com/p/45885e50d1c4\">https://www.jianshu.com/p/45885e50d1c4</a></li>\n<li><a href=\"https://zh.wikipedia.org/zh-tw/%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1\">https://zh.wikipedia.org/zh-tw/%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Task_switching_(psychology)\">https://en.wikipedia.org/wiki/Task_switching_(psychology)</a></li>\n<li><a href=\"https://zh.wikipedia.org/zh-tw/%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1\">https://zh.wikipedia.org/zh-tw/%E5%88%86%E6%99%82%E7%B3%BB%E7%B5%B1</a></li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckytptgql0000guze6tpp827u","category_id":"ckzwb55uj0000bvzehf0i5xdz","_id":"ckzwb55ul0001bvzee2uf4503"},{"post_id":"ckzjn810b0000dmze8jg7d5bm","category_id":"ckzwb55uj0000bvzehf0i5xdz","_id":"ckzwb5t0m0002bvze372i6e0b"},{"post_id":"ckyclb86i0001pyze2pisccfe","category_id":"ckzwb55uj0000bvzehf0i5xdz","_id":"ckzwb89zl0003bvzed38sb142"},{"post_id":"ckxfufyry0000pgze896t3mk1","category_id":"ckzwb55uj0000bvzehf0i5xdz","_id":"ckzwb8fi70004bvzeadva6i7w"},{"post_id":"ckx7dl13z0000tyzeglwx1ta3","category_id":"ckzwb8jle0005bvzeeox99jmx","_id":"ckzwb8jlf0006bvze8f1v87w3"},{"post_id":"ckx7dl1440003tyze75t06rv9","category_id":"ckzwb8jle0005bvzeeox99jmx","_id":"ckzwb8ty70007bvze44fv5trh"},{"post_id":"ckzz01d5e00003kze372d9o15","category_id":"ckzwb55uj0000bvzehf0i5xdz","_id":"ckzz01d5h00023kze66iqheaf"},{"post_id":"cl10gxoz20001pzze42iqgpw8","category_id":"ckzwb8jle0005bvzeeox99jmx","_id":"cl10gxoz80003pzzefgrl08v6"},{"post_id":"cl7fz5o3200008szegp1473g5","category_id":"ckzwb55uj0000bvzehf0i5xdz","_id":"cl7fz5o3b00038sze2fsz6n4d"},{"post_id":"cl7fz5o3a00028szegwsigysf","category_id":"ckzwb55uj0000bvzehf0i5xdz","_id":"cl7fz5o3c00058szeh7v57bo3"},{"post_id":"cl7qd525d0000b5zehbv733aq","category_id":"ckzwb55uj0000bvzehf0i5xdz","_id":"cl7qd525e0003b5zeghl3fedu"}],"PostTag":[{"post_id":"ckx7dl13z0000tyzeglwx1ta3","tag_id":"ckx7dl1420001tyze3toh1drq","_id":"ckx7dl1440002tyze1ouw39d4"},{"post_id":"ckx7dl1440003tyze75t06rv9","tag_id":"ckx7dl1450004tyzebahafs01","_id":"ckx7dl1450005tyzeh5cu5ej9"},{"post_id":"ckx7dl1440003tyze75t06rv9","tag_id":"ckx7dl1420001tyze3toh1drq","_id":"ckx7dl1450006tyzeael5arll"},{"post_id":"ckxfufyry0000pgze896t3mk1","tag_id":"ckxfufys80001pgze1o3d3kfx","_id":"ckxfufysb0002pgze2u9792lu"},{"post_id":"ckyclb86i0001pyze2pisccfe","tag_id":"ckyclb86k0002pyzegkxgcudf","_id":"ckyclb86l0003pyze1ksf69c0"},{"post_id":"ckytptgql0000guze6tpp827u","tag_id":"ckytptgqo0001guzegnyy0kki","_id":"ckyxd4mah0000y0ze6j8yf3xa"},{"post_id":"ckzjn810b0000dmze8jg7d5bm","tag_id":"ckytptgqo0001guzegnyy0kki","_id":"ckzjn810k0001dmzeacfefc53"},{"post_id":"ckzz01d5e00003kze372d9o15","tag_id":"ckytptgqo0001guzegnyy0kki","_id":"cl10gxoyx0000pzze916a4ax7"},{"post_id":"cl10gxoz20001pzze42iqgpw8","tag_id":"cl10gxoz30002pzzehggca9u5","_id":"cl10gxoz90005pzze9i5d2ivi"},{"post_id":"cl10gxoz20001pzze42iqgpw8","tag_id":"cl10gxoz80004pzzegbikcl3x","_id":"cl10gxoz90006pzze6kd39ne1"},{"post_id":"cl7fz5o3200008szegp1473g5","tag_id":"cl7fz5o3700018sze5zu3bnxg","_id":"cl7fz5o3g00078szeaajb33hp"},{"post_id":"cl7fz5o3200008szegp1473g5","tag_id":"cl7fz5o3c00048szehi73cuxy","_id":"cl7fz5o3h00088szef3iw5mxj"},{"post_id":"cl7fz5o3a00028szegwsigysf","tag_id":"cl7fz5o3700018sze5zu3bnxg","_id":"cl7fz5o3h00098sze8mvydffj"},{"post_id":"cl7qd525d0000b5zehbv733aq","tag_id":"cl7fz5o3700018sze5zu3bnxg","_id":"cl7qd525e0001b5ze2w6z4hhy"},{"post_id":"cl7qd525d0000b5zehbv733aq","tag_id":"cl7fz5o3c00048szehi73cuxy","_id":"cl7qd525e0002b5zefedtexvd"}],"Tag":[{"name":"keycloak","_id":"ckx7dl1420001tyze3toh1drq"},{"name":"spring","_id":"ckx7dl1450004tyzebahafs01"},{"name":"other","_id":"ckxfufys80001pgze1o3d3kfx"},{"name":"middleware","_id":"ckyclb86k0002pyzegkxgcudf"},{"name":"golang","_id":"ckytptgqo0001guzegnyy0kki"},{"name":"golan","_id":"ckzz02xxk0000bzze6sea9xlv"},{"name":"PostgreSQL","_id":"cl10gxoz30002pzzehggca9u5"},{"name":"sql","_id":"cl10gxoz80004pzzegbikcl3x"},{"name":"java","_id":"cl7fz5o3700018sze5zu3bnxg"},{"name":"Thread","_id":"cl7fz5o3c00048szehi73cuxy"}]}}